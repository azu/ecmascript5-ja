<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8"/>
    <title>ECMAScript / Standard ECMA-262 Edition 5.1 訳</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
<header>
    <a href="http://www.webzoit.net/hp/it/internet/homepage/script/ecmascript/ecma262_51/">ECMAScript / Standard
        ECMA-262 Edition 5.1 訳</a>で
    公開されているものを1ページにまとめて多少整形したものです。
    <blockquote> ECMA-262 第5版の改訂版、『 ECMA-262 第5.1版』訳：webzoit.net(2012年4月)</blockquote>
    <p style="line-height: 1px; font-size: 13px;"><a
            href="http://www.webzoit.net/hp/it/internet/homepage/script/ecmascript/ecma262_51/">ECMA-262
        5.1 読解時の留意点と原文リソース</a></p>
</header>
<article>
    <h2>はじめに Standard ECMA-262 5.1 Edition</h2>


    <h3>はじめに</h3>

    <p>
        　このECMA標準規格は、中でも最もよく知られている JavaScript(Netscape)とJScript(マイクロソフト)といったいくつかの元になる技術に基づいています。
        その言語は、Netscape社のBrendan Eich氏によって考案され、同社製ブラウザNavigator 2.0の中で最初に登場しました。
        その後、Netscape社(のNavigator 2.0)とMicrosoft社のInternet Explorer 3.0から順次発表されるブラウザ全てに搭載されました。
    </p>

    <p>g
        　この標準の開発が始まったのは1996年11月です。
        このEcma標準規格の最初のエディションは1997年06月のEcmaの総会で採択されました。
    </p>

    <p>
        　そのEcma標準規格は、迅速な手続きの下に採択されるべくISO / IEC JTC 1に提出され、1998年04月に国際標準[ISO/IEC 16262]として承認されました。
        1998年06月のEcmaの総会では、ISO / IEC16262に完全に適合したECMA-262の第2版(セカンドエディション)が承認されました。
        第1版と第2版の間の変更は、本質的に編集されました。
        標準規格の第3版は、強力な正規表現、より良い文字列操作、新たな制御文、try/catch例外操作、エラーの厳密な定義、数値出力における書式化、更には、今後の国際化要件や将来の言語の成長を見越したマイナーチェンジ(細やかな変更)が行われました。
        ECMAScript標準規格の第3版は、1999年12月のEcmaの総会で採択され、2002年06月に[ISO/IEC 16262:2002]として発行されました。
    </p>

    <p>
        　第3版の発行以来、ECMAScriptは、基本的にすべてのWebブラウザでサポートされているプログラミング言語であり、ワールド・ワイド・ウェブと共に広く普及し(大規模な採用を実現し)ています。
        重要な作業は、ECMAScriptの第4版を開発することでした。
        しかしながら、作業は完遂できませんでしたし、ECMAScriptの第4版というものは1つも発行されていませんが、言語の継続的な進化を表明しています。
        ([ECMA-262 5 edition]として発行された)ECMAScriptの第5版は、ブラウザ実装間の共通化を図り、言語仕様の事実上の解釈を成文化し、第3版の発行以来浮上している新機能の為のサポートを追加します。
        このような機能には、アクセサプロパティ、オブジェクトの生成と検査への反映、プロパティの属性のプログラム操作、付加的な配列操作関数、JSONオブジェクトエンコード方式の書式サポート、強化されたエラーチェックとプログラムセキュリティを提供する厳格モード(strict
        mode)を含みます。
    </p>

    <p>
        　ECMAScriptの標準規格であるこの現行の5.1版は、国際標準規格[ISO/IEC 16262:2011]の第3版に完全に準拠しています。
    </p>

    <p>
        　ECMAScriptは、活気に満ちた言語であり、その言語の進化は留まるところを知りません。
        重要な技術強化については、この仕様の将来の版によって継続されます。
    </p>

    <p>
        　このECMA標準規格は、2011年06月の総会によって採択されています。
    </p>

    <h4>[注釈]</h4>

    <p>
        　ECMAScript Edition 4としてEcma標準規格番号であるECMA-262 Edition 4は予約されていましたが、Ecma発行過程では使われていません。
        その為、Ecmaの国際的な刊行物としてのECMA-262 Edition 4は存在しません。
    </p>


</article>
<article>


    <h2>1 スコープ / Scope </h2>


    <h3 id="x1">1 スコープ<a href="#x1">#</a></h3>

    <p>
        　この標準規格はECMAScriptのスクリプティング言語を定義します。
    </p>


</article>
<article>


    <h2>2 準拠 / Conformance </h2>


    <h3 id="x2">2 準拠・一致・適合<a href="#x2">#</a></h3>

    <p>
        　ECMAScriptに準拠した実装は、この仕様に記述されている全ての型、値、オブジェクト、プロパティ、関数、プログラム構文、セマンティックス(意味論)を提供し、サポートしなければいけません。
    </p>

    <p>
        　この標準規格に準拠した実装は、Unicode標準規格のバージョン 3.0 を含む以降と一致する文字、実装レベル3からエンコード方式として採用されている UCS-2 や UTF-16 の何れかを伴う[ISO/IEC
        10646-1]を構文解析するようにしましょう。
        もし、採用した[ISO/IEC 10646-1]のサブセットが特に指定されていない場合は、それはBMP / Basic Multilingual Plane
        (基本多言語水準)のサブセット、コレクション300であるものと推定されます。
        もし、ECMAScriptの採用したエンコード方式が特に指定されていない場合は、UTF-16エンコード方式であるものと推定されます。
    </p>

    <p>
        　ECMAScriptに準拠した実装は、この仕様に記述されている型、値、オブジェクト、プロパティと関数を追加して提供することを許可されます。
        特にECMAScriptに準拠した実装は、この仕様書内で説明されているオブジェクトの為に、この仕様で説明しなかったプロパティとそれらプロパティの値を提供することも許可されます。
    </p>

    <p>
        　ECMAScriptに準拠した実装は、この仕様に記載されていないプログラムと正規表現構文をサポートすることが許可されます。
        特にECMAScriptに準拠した実装は、この仕様の 7.6.1.2 で列挙されている"将来の(利用を想定した)予約語"を使用するプログラム構文をサポートすることが許可されます。
    </p>


</article>
<article>


    <h2>3 引用規格・引用文書 / Normative references </h2>


    <h3 id="x3">3 引用規格・引用文書<a href="#x3">#</a></h3>

    <p>
        　次の参照文書は、この文書のアプリケーションにおいて必須です。
        日付のある参照については、引用した版(エディション)でだけ適用します。
        日付のない参照については、(いくつかの改訂を含む)参照文書の最新版が適用します。
    </p>

    <p>
        [ ISO/IEC 9899:1996 ] プログラミング言語 -- C 及び改訂1、技術的正誤表1と2を含む
    </p>

    <p>
        [ ISO/IEC 10646-1:1993 ] 情報技術(IT) -- UCS/Universal Multiple-Octet Coded Character Set 及びその改訂と正誤表を付加
    </p>


</article>
<article>


    <h2>4 概要 / Overview </h2>


    <h3 id="x4">4 概要<a href="#x4">#</a></h3>

    <p>
        　このセクションには、ECMAScript言語の非標準の概要を含みます。
    </p>

    <p>
        　ECMAScriptは、ホスト環境内でオブジェクトの演算と操作を実行する為のオブジェクト指向のプログラミング言語です。
        ここで定義したようなECMAScriptは、演算処理を自己完結することは意図されず、他方、外部データの入力や算出結果の出力については、この仕様内に規定は何もありません。
        その代わり、ECMAScriptプログラムの演算環境が期待されることは、この仕様内で説明したオブジェクトと他の機能だけではなく、特定の環境仕様のホストオブジェクトは、ECMAScriptプログラムからアクセスされることが可能な特定のプロパティと(ECMAScriptプログラムから)呼ばれることが可能な関数を提供する場合があることを示すこと以外に、この仕様のスコープを超える説明と動作を持ちます。
        スクリプティング言語は、既存システムの機能のカスタマイズや自動化といった操作をする為に利用されるプログラミング言語です。
        このようなシステムにおいて便利な機能は、ユーザーインタフェースを通して既に利用可能であり、スクリプティング言語にはプログラム操作への機能性を公開する仕組みがあります。
        こうした方法では、既存システムは、スクリプト言語の機能を完了するオブジェクトと要件をホスト環境に提供するといわれています。
    </p>

    <p>
        　スクリプティング言語は玄人と素人プログラマの両方によって使われることが意図されます。
    </p>

    <p>
        　ECMAScriptは、元々Webスクリプティング言語にする為に設計されており、ブラウザ上でWebページをにぎわす仕組みとWebベースのクライアントサーバ技術の一部としてサーバサイドの演算を実行する仕組みを提供します。
        ECMAScriptは、ホスト環境の多様性における核となるコアなスクリプティング能力を提供することができ、それゆえにそのコアなスクリプティング言語は、あらゆる固有のホスト環境から離れてこの文書の中で記述されます。
    </p>

    <p>
        　ECMAScriptの機能のいくつかは、他のプログラミング言語の中で使われるそれに似ており、特に以下で説明しているようにJava(TM)、それ自身とスキーマが似ています。
    </p>

<pre>
====================================================
Gosling, James, Bill Joy and Guy Steele.
The Java(TM) Language Specification.
Addison Wesley Publishing Co., 1996.
Ungar, David, and Smith, Randall B.
Self: The Power of Simplicity.
OOPSLA '87 Conference Proceedings, pp.
227-241, Orlando, FL, October 1987.
IEEE Standard for the Scheme Programming Language.
IEEE Std 1178-1990.
====================================================
</pre>

    <p><a href="http://www.webzoit.net/hp/it/internet/homepage/script/ecmascript/ecma262_51/contents/4/4_1/"
          title="Webスクリプティング">4.1
        Webスクリプティング</a></p>

    <p><a href="http://www.webzoit.net/hp/it/internet/homepage/script/ecmascript/ecma262_51/contents/4/4_2/"
          title="言語概要">4.2 言語概要</a></p>

    <p><a href="http://www.webzoit.net/hp/it/internet/homepage/script/ecmascript/ecma262_51/contents/4/4_3/"
          title="用語と定義">4.3 用語と定義</a></p>


</article>
<article>


    <h2>4.1 Webスクリプティング / Web Scripting </h2>


    <h3 id="x4.1">4.1 Webスクリプティング<a href="#x4.1">#</a></h3>

    <p>
        　Webブラウザは、ウィンドウ、メニュー、ポップアップ、ダイアログボックス、テキスト領域、アンカー、フレーム、履歴、cookie、入出力を示すインスタンスやオブジェクトにおいて含まれているクライアントサイドの計算の為にECMAScriptのホスト環境を提供します。
        更にそのホスト環境は、フォーカス変更、ページと画像のロード、アンロード、エラーと中断、選択、フォームの送信、マウス操作のようなイベントの為のコードをスクリプティングして(書いて)調整するという手段を提供します。
        HTMLと表示ページ内に現れるスクリプティングコードは、ユーザーインタフェース要素と固定及び計算されたテキストと画像との組み合わせです。
        スクリプティングコードは、ユーザーとの対話に関係するものであってメインプログラムの為に必要なものは何もありません。
    </p>

    <p>
        　ウェブサーバは、クライアントやファイルからのオブジェクト再表示要求を含むサーバサイド演算について異なるホスト環境を提供し、ロックし、データを共有する仕組みがあります。
        ブラウザサイドとサーバサイドスクリプティングの両方を利用することによってWebベースのアプリケーションにおいてカスタマイズしたユーザーインタフェースを提供する間、クライアントサーバ間の演算を分離します。
    </p>

    <p>
        　各ウェブブラウザとウェブサーバは、ECMAScriptの実行環境を整えることでその自身のホスト環境を提供するECMAScriptをサポートします。
    </p>


</article>
<article>


    <h2>4.2 言語の概要 / Language Overview </h2>


    <h3 id="x4.2">4.2 言語の概要<a href="#x4.2">#</a></h3>


    <p>
        　次は、言語の全ての部分を説明しているわけではないのでECMAScriptの略式な概要となります。
        (よって)この概要は、必ずしも標準的な正規の部分ではありません。
    </p>

    <p>
        　ECMAScriptは、オブジェクトベースであり、基本言語とホスト要件は、オブジェクト(物体・対象体・対象物)によって提供され、ECMAScriptプログラムは通信オブジェクトの塊まり・集合(クラスタ)です。
        ECMAScriptのオブジェクトは、各プロパティ(特性・性質)が、どのように利用可能かを決めるゼロ以上のアトリビュート(属性)をそれぞれに持つプロパティの集合で、例えば、あるプロパティにおけるWritable(書き込み)属性が、falseにセットされている場合、プロパティの値を変更しようとするとそのECMAScriptコードの実行は失敗します。
        プロパティは、プリミティブ(原始的)な値や関数といった他のオブジェクトを保持するコンテナ(入れ物・容器)です。
        プリミティブな値は、次のビルトイン(組み込み)型である [ Undefined、Null、Boolean、Number、String ]
        の1つとして構成されるメンバでオブジェクトは、残りの他のビルトイン型であるオブジェクトのメンバ、関数は呼び出し可能なオブジェクトです。
        プロパティ経由でオブジェクトと関連付けられた関数はメソッドです。
    </p>

    <p>
        　ECMAScriptは、ECMAScriptの実体(エンティティ)の定義を包括する組み込みオブジェクトの集合を定義します。
        これらGlobalオブジェクトを含む組み込みオブジェクトは、Objectオブジェクト、Functionオブジェクト、Arrayオブジェクト、Stringオブジェクト、Booleanオブジェクト、Numberオブジェクト、Mathオブジェクト、Dateオブジェクト、RegExpオブジェクト、JSONオブジェクト、また、ErrorオブジェクトとしてErrorオブジェクト、EvalErrorオブジェクト、RangeErrorオブジェクト、ReferenceErrorオブジェクト、SyntaxErrorオブジェクト、TypeErrorオブジェクトとURIErrorオブジェクトです。
    </p>

    <p>
        　ECMAScriptは、組み込み演算子のセットも定義します。
        ECMAScriptの演算子は、単項演算子、多項演算子、加算演算子、ビットシフト演算子、関係演算子、等価演算子、バイナリビット演算子、バイナリ論理演算子、代入演算子、カンマ演算子など様々な演算子を含みます。
        ECMAScriptの構文は、意図的にJavaの構文に似せています。
        ECMAScriptの構文は、利用が容易なスクリプティング言語として提供する為に柔軟になっています。
        例えば、変数は、その型が宣言されたかどうか、型がプロパティと関連付けられたかどうかについて要求されませんし、定義した関数は、それらが呼ばれる前にテキストとして現れる宣言を持つ(ソースコード上、呼び出し位置より前に定義されている)ことを要求されません。
    </p>

    <p><a href="http://www.webzoit.net/hp/it/internet/homepage/script/ecmascript/ecma262_51/contents/4/4_2/4_2_1/"
          title="オブジェクト">4.2.1
        オブジェクト</a></p>


</article>
<article>

    <h3 id="x4.2.1">4.2.1 オブジェクト<a href="#x4.2.1">#</a></h3>

    <p>
        　ECMAScriptは、C++、Smalltalk、Javaのようなクラスを利用しません。
        その代わりにオブジェクトは、リテラル表記経由または、オブジェクトの生成とその後にそれらのプロパティに初期値を関連付けることによってそれらの全部または一部を初期化する実行コードを生成するコンストラクタ経由含む様々な方法で生成される場合があります。
        各コンストラクタは、プロトタイプベースの継承プロパティと共有プロパティを実装する為に使用される"prototype"という名前のプロパティを持つ関数です。
        オブジェクトは、new 式でコンストラクタを使用することによって生成されます。
        例えば、new Date(2009,11) という式は、新たなDateオブジェクトを生成します。
        new を使わないコンストラクタの呼び出しは、コンストラクタに依存する結果を持ちます。
        例えば、Date() は、任意のオブジェクトではなく、現在日付時刻についての文字列表現を生成します。
    </p>

    <p>
        　各オブジェクトは、そのコンストラクタのprototypeプロパティ(呼んだ当該オブジェクトのプロトタイプ)の値への暗黙のリファレンスを持ちます。
        更にprototypeは、そのプロトタイプ等々へのnullではない暗黙のリファレンスを持つ場合があり、これはプロトタイプチェーンと呼ばれます。
        リファレンスが、オブジェクト内のプロパティに作成される場合、それはその名前のプロパティを含むプロトタイプチェーン内にある最初のオブジェクトにあるその名前のプロパティへのリファレンスです。
        言い換えると、ちょっと前に言及した最初のオブジェクトは、そのようなプロパティについて検査されるということであり、もし、そのオブジェクトが名前付きプロパティを含む場合には、それは、リファレンスが参照するプロパティであることを指し、もし、オブジェクトが名前付きプロパティを含まない場合には、そのオブジェクトにおける次のプロパティが、検査され。。。といったようになります。
    </p>

    <div style="text-align:center ;">
        <p>
            <img id="explain" src="http://es5.github.com/figure1.gif">

        <div style="text-align:center ;">図1 オブジェクト／プロトタイプの関係</div>
        </p>
    </div>
    <p>
        　クラスベースのオブジェクト指向言語は、一般には、状態が、インスタンスによって引き継がれ、メソッドが、クラスによって引き継がれ、継承は、構造と動作についてのみなされます。
        ECMAScriptでは、その状態とメソッドが、オブジェクトによって引き継がれ、構造、動作、状態が全て継承されます。
    </p>

    <p>
        　固有のプロパティに直に含まれない全てのオブジェクトは、それらのプロトタイプが、そのプロパティとその値の共有を含みます。
        図 1 は、これを示しています。
    </p>

    <p>
        　CF は、任意のコンストラクタ(、または、任意のオブジェクト)です。
        cf1, cf2, cf3, cf4, cf5の5つのオブジェクトは、new 式を使って生成されています。
        これらのオブジェクトは、それぞれ q1 と q2 という名前のプロパティを含みます。
        波線は、暗黙のプロトタイプ関係を表現しているので、例えば、cf3のプロパティは、CFp となります。
        コンストラクタ CF は、それ自身に CFp, cf1, cf2, cf3, cf4, cf5には、(直接)見えない P1 と P2 という名称の2つのプロパティを持っています。
        プロパティ CFp にある CFP1 という名のプロパティは、q1、q2 や CFP1 という名前ではない CFp の暗黙のプロトタイプチェーン内で見つかった何らかのプロパティであるものとして(、 CF によってではなく、)
        cf1, cf2, cf3, cf4, cf5 によって共有されます。
        これらにおける注釈としては、 CF と CFp 間の(明示的なリンクはありますが、 CF と cf1, cf2, cf3, cf4, cf5 のそれぞれとの間に)暗黙のプロパティリンクは、存在しないということです。
    </p>

    <p>
        　クラスベースのオブジェクト言語とは異なり、プロパティは、それらに値を関連付けることによって動的にオブジェクトに追加されることが可能です。
        それは、つまり、コンストラクタは、構築されたオブジェクトのプロパティの全て、または、一部に対し、名称や値の関連付けを要求しないということです。
        上記のダイアグラムでは、CFp 内のプロパティに新たな値を関連付けることによって cf1, cf2, cf3, cf4, cf5に新たな共有プロパティを追加することができます。
    </p>

</article>
<article>
    <h3 id="x4.2.2">4.2.2 ECMAScriptの厳密なVariant型<a href="#x4.2.2">#</a></h3>

    <p>
        　ECMAScript言語は、言語の利用者が、言語内で利用可能な一部の機能の利用を制限することがあるという可能性を認識しています。
        それらは、エラーの発生しやすい機能であると考えるものを回避する為、強化したエラーチェック結果を得る為、もしくは彼らの選択肢の他の何らかの理由などセキュリティへの関心からその様にするかもしれません。
        この可能性へのサポートとしては、ECMAScriptは、言語の厳格なvariant型(どんな型でも格納可能な型)を定義します。
        言語の厳格なvariantは、通常のECMAScript言語の一部の構文とセマンティックの仕様と一部機能の詳細化したセマンティックスへの改訂を除外します。
        その言語の厳格でない書式によってエラーとして指定されない状況において例外エラーを投げることによって報告されなければならない付加的なエラー条件も指定します。
    </p>

    <p>
        　ECMAScript言語の厳格なvariantは、言語の strict mode (厳格モード)として参照されるのが、一般的です。
        厳格モードの選択とECMAScriptの構文とセマンティックをstrictモードとして利用することは、単独のECMAScriptのコードユニットのレベルで明示的に行われます。
        なぜならstrictモードは、構文上のコードユニットのレベルにおいて選択され、strictモードは、唯一このようなコードユニット内でローカル効果を持つ制限を課すからです。
        Strictモードは、複数のコードユニットを超えた構成を制御しなければならないECMAScriptのセマンティック上の一部の局面に対し、制約を設けたり、修正したりはしません。
        ECMAScriptプログラム全体としては、厳格モードと厳格モードでないECMAScriptコードユニット双方で構成される場合があります。
        このケースにおいてはstrictモードは唯一、実際に実行中のコードが、strictモードのコードユニット内で定義される際に適用されます。
    </p>

    <p>
        　この仕様への確認の為にECMAScriptの実装は、全く制限のないECMAScript言語とこの仕様によって定義したECMAScript言語のstrictモードのvariantの両方を実装しなければいけません。
        加えて実装は、単一の複合プログラムについて制約がない場合とstrictモードのコードユニットとの組み合わせをサポートしなければいけません。
    </p>

</article>
<article>


<h2>4.3 用語と定義 / Terms and definitions </h2>


<h3 id="x4.3">4.3 用語と定義<a href="#x4.3">#</a></h3>

<p>
    　この文書の目的においては、次の用語と定義が適用されます。
</p>

<h3 id="x4.3.1">4.3.1 『型』<a href="#x4.3.1">#</a></h3>

<p>
    　この仕様の<a href="http://www.webzoit.net/hp/it/internet/homepage/script/ecmascript/ecma262_51/contents/8/" title="8 型">第8項</a>内で定義したようなデータ値のセット
</p>

<h3 id="x4.3.2">4.3.2 『プリミティブ値』<a href="#x4.3.2">#</a></h3>

<p>
    　<a href="http://www.webzoit.net/hp/it/internet/homepage/script/ecmascript/ecma262_51/contents/8/"
        title="8 型">第8項</a>内で定義したようなUndefined型、Null型,
    Boolean型, Number型, String型の1つであるメンバ
</p>

<p>
    [注釈]
</p>

<p>
    　プリミティブな値とは、言語実装の最も低いレベルで表現されるまさに基準・原点です。
</p>

<h3 id="x4.3.3">4.3.3 『オブジェクト』<a href="#x4.3.3">#</a></h3>

<p>
    　Objectという型のメンバ
</p>

<p>
    [注釈]
</p>

<p>
    　オブジェクトとは、プロパティの集合と1つのプロトタイプオブジェクトを持ちます。
    プロトタイプは、null値になる場合があります。
</p>

<p>
    (注：ちなみにここで言うプロトタイプオブジェクトとは、標準組み込みプロトタイプオブジェクトであり、<i>obj</i>.prototype といったGlobalオブジェクト以外の各オブジェクトが持つ prototype
    プロパティの事ではない、つまり、 prototype プロパティを持たないJSONやMathも「プロトタイプがnull値」であるオブジェクトという意味。)
</p>

<h3 id="x4.3.4">4.3.4 『コンストラクタ』<a href="#x4.3.4">#</a></h3>

<p>
    　オブジェクトを生成、初期化する関数オブジェクト
</p>

<p>
    [注釈]
</p>

<p>
    　コンストラクタのprototypeプロパティの値は、継承の実装と共有したプロパティに利用されるプロトタイプオブジェクトです。
</p>

<h3 id="x4.3.5">4.3.5 『プロトタイプ』<a href="#x4.3.5">#</a></h3>

<p>
    　他のオブジェクトに共有したプロパティを提供するオブジェクト
</p>

<p>
    [注釈]
</p>

<p>
    　コンストラクタが、任意のオブジェクトを生成する場合には、そのオブジェクトは、プロパティ参照を解決する目的においてコンストラクタの"prototype"プロパティを暗に参照します。
    そのコンストラクタの"prototype"プロパティは、(注：任意のコンストラクタ名という意味であってconstructorプロパティのことではない)[ <i>constructor</i>.prototype
    ]というプログラム上の式によって参照されることが可能で、そのプロトタイプを共有している全てのオブジェクトによって継承を通して共有されます。
    あるいは、任意の新たなオブジェクトは、[ Object.create ]という組み込み関数を使用することによって明示的に指定したプロトタイプを伴って生成される場合があります。
</p>

<h3 id="x4.3.6">4.3.6 『ネイティブオブジェクト』<a href="#x4.3.6">#</a></h3>

<p>
    　ホスト環境ではなく、この仕様によって完全に定義されるセマンティックを持つECMAScriptの実装にあるオブジェクト
</p>

<p>
    [注釈]
</p>

<p>
    　標準規格のネイティブオブジェクトはこの仕様の中で定義されます。
    一部のネイティブオブジェクトは、組み込まれ、その他は、ECMAScriptプログラムの実行過程で構築される場合があります。
</p>

<h3 id="x4.3.7">4.3.7 『組み込みオブジェクト(ビルトインオブジェクト)』<a href="#x4.3.7">#</a></h3>

<p>
    　ECMAScriptプログラムの実行開始時点で現れるECMAScriptの実装によって提供されたホスト環境に依存しないオブジェクト
</p>

<p>
    [注釈]
</p>

<p>
    　標準組み込みオブジェクトはこの仕様内で定義され、ECMAScriptの実装については、ここで記載したり、他で定義したりする場合があります。
    各組み込みオブジェクトは、ネイティブオブジェクトです。
    組み込みコンストラクタとは、組み込みオブジェクトのことであり、コンストラクタのことでもあります。
</p>

<h3 id="x4.3.8">4.3.8 『ホストオブジェクト』<a href="#x4.3.8">#</a></h3>

<p>
    　完全なECMAScriptの実行環境をホスト環境によって提供したオブジェクト
</p>

<p>
    [注釈]
</p>

<p>
    　ネイティブでないなんらかのオブジェクトは、ホストオブジェクトです。
</p>

<h3 id="x4.3.9">4.3.9 『Undefined(未定義)値』<a href="#x4.3.9">#</a></h3>

<p>
    　変数が、値と関連付けられていない時に使用したプリミティブ値
</p>

<h3 id="x4.3.10">4.3.10 『Undefined(未定義)型』<a href="#x4.3.10">#</a></h3>

<p>
    　唯一の値がUndefined(未定義)値である型
</p>

<h3 id="x4.3.11">4.3.11 『null値』<a href="#x4.3.11">#</a></h3>

<p>
    　何らかのオブジェクトの意図的な欠如を表すプリミティブ値
</p>

<h3 id="x4.3.12">4.3.12 『Null型』<a href="#x4.3.12">#</a></h3>

<p>
    　唯一の値がnull値である型
</p>

<h3 id="x4.3.13">4.3.13 『Boolean値』<a href="#x4.3.13">#</a></h3>

<p>
    　Boolean型のメンバ
</p>

<p>
    [注釈]
</p>

<p>
    　Boolean値にはtrueとfalseの2つしかありません。
</p>

<h3 id="x4.3.14">4.3.14 『Boolean型』<a href="#x4.3.14">#</a></h3>

<p>
    　プリミティブ値 true/false で構成される型
</p>

<h3 id="x4.3.15">4.3.15 『Booleanオブジェクト』<a href="#x4.3.15">#</a></h3>

<p>
    　標準組み込みBooleanコンストラクタのインスタンスであるオブジェクト型のメンバ
</p>

<p>
    [注釈]
</p>

<p>
    　引数としてBoolean値を提供することによって new 式の中でBooleanコンストラクタを使って生成したBooleanオブジェクトです。
    結果となるオブジェクトは、値がBoolean値である内部プロパティを持ちます。
    Booleanオブジェクトは、Boolean値に強制変換することが可能です。
</p>

<h3 id="x4.3.16">4.3.16 『String値』<a href="#x4.3.16">#</a></h3>

<p>
    　ゼロ以上の16ビット符号なし整数の有限の序数並びであるプリミティブ値
</p>

<p>
    [注釈]
</p>

<p>
    　String値は、String型のメンバです。
    通常、その並び(シーケンス)にある各整数値は、UTF-16テキストの任意の単一の16ビットユニットを表わします。
    しかしながら、ECMAScriptは、16ビット符号なし整数にしなければならない場合を除き、その値におけるいかなる制限も要求もなされません。
</p>

<h3 id="x4.3.17">4.3.17 『String型』<a href="#x4.3.17">#</a></h3>

<p>
    　利用可能なString値全てのセット
</p>

<h3 id="x4.3.18">4.3.18 『Stringオブジェクト』<a href="#x4.3.18">#</a></h3>

<p>
    　標準組み込みStringコンストラクタのインスタンスであるObject型のメンバ
</p>

<p>
    [注釈]
</p>

<p>
    　任意のStringオブジェクトは、引数としてString値を提供することによって new 式の中でStringコンストラクタを使って生成されます。
    結果となるオブジェクトは、値がString値である内部プロパティを持ちます。
    Stringオブジェクトは、関数としてStringコンストラクタを呼ぶ(<a
        href="http://www.webzoit.net/hp/it/internet/homepage/script/ecmascript/ecma262_51/contents/15/15_5/15_5_1/"
        title="15.5.1 関数としてコールしたStringコンストラクタ">15.5.1</a>)ことによってString値に強制変換することが可能です。
</p>

<h3 id="x4.3.19">4.3.19 『Number値』<a href="#x4.3.19">#</a></h3>

<p>
    　倍精度64ビットバイナリ形式[ IEEE 754 ]の値と一致するプリミティブ値
</p>

<p>
    [注釈]
</p>

<p>
    　Number値は、Number型のメンバであり、数値における直接表現です。
</p>

<p>
    [注記]
</p>

<p>
    [ IEEE 754 ] / IEEE標準規格 754 『浮動小数点数演算』
</p>

<h3 id="x4.3.20">4.3.20 『Number型』<a href="#x4.3.20">#</a></h3>

<p>
    　特殊な[NaN / Not-a-Number]、正の無限大、負の無限大を含む全ての利用可能なNumber値のセット
</p>

<h3 id="x4.3.21">4.3.21 『Numberオブジェクト』<a href="#x4.3.21">#</a></h3>

<p>
    　標準組み込みNumberコンストラクタのインスタンスであるObject型のメンバ
</p>

<p>
    [注釈]
</p>

<p>
    　Numberオブジェクトは、引数としてNumber値を提供することによって new 式の中でNumberコンストラクタを使って生成されます。
    結果となるオブジェクトは、値がNumber値である内部プロパティを持ちます。
    Numberオブジェクトは、関数としてNumberコンストラクタを呼ぶ(15.7.1)ことによってNumber値に強制変換することが可能です。
</p>

<h3 id="x4.3.22">4.3.22 『無限大』<a href="#x4.3.22">#</a></h3>

<p>
    　正の無限大のNumber値である数値
</p>

<h3 id="x4.3.23">4.3.23 『NaN』<a href="#x4.3.23">#</a></h3>

<p>
    　[IEEE 754]で定める[NaN / Not-a-Number]値である数値
</p>

<p>
    [ IEEE 754 ] / IEEE標準規格 754 『浮動小数点数演算』
</p>

<h3 id="x4.3.24">4.3.24 『関数』<a href="#x4.3.24">#</a></h3>

<p>
    　標準組み込みFunctionコンストラクタのインスタンスであり、サブルーチンとして実行される場合があるObject型のメンバ
</p>

<p>
    [注釈]
</p>

<p>
    　その名前付きプロパティについて追記すると任意の関数は、実行可能なコードと呼び出された場合にどのような挙動を取るかを決める状態を含みます。
    関数のコードは、ECMAScriptで書かれたり、(他のコードで書かれECMAScriptでは)書かれなかったりします(、つまり、関数のコードは、必ずしもECMAScriptで書かれるとは限りません)。
</p>

<h3 id="x4.3.25">4.3.25 『組み込み関数』<a href="#x4.3.25">#</a></h3>

<p>
    　関数である組み込みオブジェクト
</p>

<p>
    [注釈]
</p>

<p>
    　 parseInt と Math.exp を含む組み込み関数の例など。
    実装は、この仕様に記載されていない実装依存(独自拡張)の組み込み関数を提供する場合があります。
</p>

<h3 id="x4.3.26">4.3.26 『プロパティ』<a href="#x4.3.26">#</a></h3>

<p>
    　オブジェクトの一部となる名称と値の関連付け
</p>

<p>
    [注釈]
</p>

<p>
    　プロパティの形式に応じて値は、データ値(任意のプリミティブ値、任意のオブジェクト、任意の関数オブジェクト等)として直接、またはアクセサ関数のペアによって間接的に表現される場合があります。
</p>

<h3 id="x4.3.27">4.3.27 『メソッド』<a href="#x4.3.27">#</a></h3>

<p>
    　プロパティの値である関数
</p>

<p>
    [注釈]
</p>

<p>
    　関数が、オブジェクトのメソッドとして呼ばれる場合、そのオブジェクトは、 this 値として関数に渡されます。
</p>

<h3 id="x4.3.28">4.3.28 『組み込みメソッド』<a href="#x4.3.28">#</a></h3>

<p>
    　組み込み関数であるメソッド
</p>

<p>
    [注釈]
</p>

<p>
    　標準組み込みメソッドは、この仕様内で定義され、ECMAScriptの実装が、他の付加的な組み込みメソッドを指定したり、提供したりする場合もあります。
</p>

<h3 id="x4.3.29">4.3.29 『属性(attribute)』<a href="#x4.3.29">#</a></h3>

<p>
    　あるプロパティの任意の特性を定義する内部値
</p>

<h3 id="x4.3.30">4.3.30 『独自のプロパティ(own property)』<a href="#x4.3.30">#</a></h3>

<p>
    　そのオブジェクトで直(じか)に含まれるプロパティ
</p>

<h3 id="x4.3.31">4.3.31 『継承したプロパティ』<a href="#x4.3.31">#</a></h3>

<p>
    　独自のプロパティではなく、オブジェクトのプロトタイプの(それ自身または継承した何らかの)オブジェクトのプロパティ
</p>


<h2>5 表記上の規則 / Notational Conventions </h2>


<h3 id="x5">5 表記上の規則<a href="#x5">#</a></h3>


<p><a href="http://www.webzoit.net/hp/it/internet/homepage/script/ecmascript/ecma262_51/contents/5/5_1/"
      title="構文と語彙の文法">5.1 構文と語彙の文法</a>
</p>

<p><a href="http://www.webzoit.net/hp/it/internet/homepage/script/ecmascript/ecma262_51/contents/5/5_2/"
      title="アルゴリズムの表記法">5.2
    アルゴリズムの表記法</a></p>


</article>
<article>


<h2>5.1 構文と語彙の文法 / Syntactic and Lexical Grammars </h2>

<h3 id="x5.1.1">5.1.1 文脈自由な文法<a href="#x5.1.1">#</a></h3>

<p>
    　文脈自由な文法は、プロダクション(生成物)の番号で構成されます。
    各プロダクションは、その左側にくるものとして非終端、ゼロ以上の非終端の並び(シーケンス)、その右側にくるものとして終端記号の並び(シーケンス)を呼ぶ抽象的な記号を持ちます。
    各文法において終端記号は、指定したアルファベットで描かれます。
</p>

<p>
    　識別した非終端1つから成る文章の開始は、目標記号と呼ばれ、言語を指定する任意の文脈自由な文法、すなわち、左側にある非終端におけるプロダクションの右側にある並びの中で何らかの非終端を繰り返し置換することによって得ることができる終端記号の利用可能な並び(おそらく無限大)のセットを与えられます。
</p>

<h3 id="x5.1.2">5.1.2 語彙とRegExp(正規表現)の文法<a href="#x5.1.2">#</a></h3>

<p>
    　ECMAScriptにおける語彙の文法については第7項で示されます。
    この文法は、その終端記号文字(Unicodeコードユニット)を持ち、それは、第6項で定義した SourceCharacter におけるルールと一致します。
    それは、目標記号 InputElementDiv や InputElementRegExp から始まるプロダクションの集合を定義し、そうした文字の並びが、どのように入力要素の並びに翻訳されるのかを説明します。
</p>

<p>
    　ホワイトスペースとコメントではない入力要素は、ECMAScriptにおける構文上の文法の為の終端記号を形成すると共にECMAScriptのトークン(字句)と呼ばれます。
    これらのトークンは、ECMAScript言語の予約語、識別子、リテラル、句読点記号です。
    更に行終端は、トークンとして考慮されるわけではありませんが、入力要素のストリームの一部にもなり、セミコロン自動挿入(7.9)の処理を導きます。
    単純なホワイトスペースと単一行コメントは廃棄され、構文上の文法における入力要素のストリーム内には現れません。
    MultiLineComment(一行以上に渡るか否かに関わらず、書式 /* ... */ のコメント)は、行終端がなければ、単に廃棄されたのと同様になりますが、
    MultiLineCommentが、1つ以上の行終端を含む場合には、1つの行終端に置き換えられ、構文上の文法における入力要素のストリームの一部となります。
</p>

<p>
    　ECMAScriptにおけるRegExp文法については、15.10 の中で示されます。
    この文法もまた、SourceCharacterによって定義されたのと同じ文字をその終端記号として持ちます。
    目標記号 Pattern から始まるプロダクションの集合を定義し、文字の並びが、どのようにして正規表現パターンに翻訳されるかを説明します。
</p>

<p>
    　語彙とRegExp文法から成るプロダクションは、分割する句読点(セパレータ)として2つのコロン"::"を持つことによって識別されます。
    語彙とRegExp文法は、複数のプロダクションを共有します。
</p>

<h3 id="x5.1.3">5.1.3 数値文字(数字)の文法<a href="#x5.1.3">#</a></h3>

<p>
    　その他の文法は、文字を数値に翻訳する為に利用されます。
    この文法は、数値リテラルを伴って実行する為に持っている語彙文法の一部に似ており、その終端記号 SourceCharacter と同じものを持ちます。
    この文法については、9.3.1 に出てきます。
</p>

<p>
    　数値文字列の文法のプロダクションは、句読点として3つのコロン":::"を持つことによって識別されます。
</p>

<h3 id="x5.1.4">5.1.4 構文上の文法<a href="#x5.1.4">#</a></h3>

<p>
    　ECMAScriptにおける構文上の文法は、第11項、12項、13項、14項で示されます。
    この文法は、その終端記号(5.1.2)として語彙的な文法によって定義したECMAScriptのトークン(字句)を持ちます。
    目標記号 Program から始まるプロダクションの集合を定義し、どのようにしてトークンの並び(シーケンス)が、構文的に正しいECMAScriptプログラムを形成することができるのかを説明します。
</p>

<p>
    　文字のストリームが、ECMAScriptプログラムとして解析される為にある場合、それは、まず、繰り返した語彙的な文法のアプリケーションによって入力要素のストリームに変換され、その入力要素のストリームは、その後、任意の1つの構文上の文法のアプリケーションによって解析されます。
    入力要素のストリーム内にあるトークンが、トークンが何もない目標非終端 Program の任意の1つのインスタンスとして解析できない場合、そのプログラムは、エラー内においては構文に沿っているといえます。
</p>

<p>
    　構文上の文法のプロダクションは、句読点としてまさに1つのコロン":"を持つことによって識別されます。
</p>

<p>
    　第11項、12項、13項、14項で提示されているように構文上の文法は、実際には正しいECMAScriptプログラムとして許容されるトークンのシーケンス(字句の並び)の完全な説明(account)ではありません。
    特定の追加の字句の並び、すなわち、(行終端文字の前の位置のように)確実な場所にあるシーケンス(並び)に追加された場合に限り、文法によって説明されるであろう字句の並びもまた、許容されます。
    更にその文法によって説明される特定の字句の並びは、終端文字が、特定の「厄介な」場所などに現れる場合には、受け入れを考慮されません。
</p>

<h3 id="x5.1.5">5.1.5 JSONの文法<a href="#x5.1.5">#</a></h3>

<p>
    　JSONの文法は、実際のオブジェクトにECMAScriptのオブジェクトの集合を定義している任意の文字列を翻訳する為に利用されます。
    JSONの文法は、15.12.1 に書かれています。
</p>

<p>
    　JSONの文法は、JSONの語彙的な文法と構文的な文法で構成されています。
    JSONの語彙的な文法は、文字列をトークンに翻訳する為に利用され、それは、ECMAScriptの語彙的な文法の一部に似ています。
    JSONの構文的な文法は、構文的に正しいJSONオブジェクト定義からどのようにJSONの語彙的な文法から成るトークンのシーケンスができるのかを定義します。
</p>

<p>
    　JSONの語彙的な文法から成るプロダクションは、分割句読点として2つのコロン"::"を持つことによって識別されます。
    JSONの構文的な文法は、ECMAScriptの語彙的な文法から成る何らかのプロダクションを利用します。
    JSONの構文的な文法は、ECMAScriptの構文的な文法の一部に似ています。
    JSONの構文的な文法から成るプロダクションは、分割する句読点として1つのコロン":"を使用することによって識別されます。
</p>

<h3 id="x5.1.6">5.1.6 文法表記<a href="#x5.1.6">#</a></h3>

<p>
    　語彙的な終端記号、RegExpの終端記号、数値文字の文法の終端記号、他の文法から成る終端記号の一部は、文法のプロダクションとそのような終端記号をテキストが直接参照するか否かについてのこの仕様を通して、その両方において固定幅フォントで表示されます。
    これらは、書いた通りに正確にプログラム内に現れるようにする為にあります。
    この方法で指定した全ての終端記号文字は、ASCIIの範囲から成る適切なUnicode文字であり、他のUnicode文字から成る似たような見た目の文字とは異なるものであると理解される為にあります。
    　非終端記号はイタリック体で表示されます。
    (webzoit.net内訳文においては、これを踏襲しない可能性があります。)
</p>

<p>
    　非終端の定義は1つ以上のコロンに続けて定義される非終端から成る名称によって始まります。
    (コロンの数は、属する文法のプロダクションによって示されます。)
    非終端について右辺に1つ以上の選択肢がある場合は、後続する行に続きます。
    例えば、構文上の定義、
</p>

<pre>
WhileStatement：
while ( Expression ) Statement
</pre>

<p>
    という非終端の WhileStatement という状態(state)は、トークン(字句) while 、トークン(字句) 左丸カッコ、Expression(式) 、トークン(字句)
    右丸カッコ、Statement(文)が続くことを表します。
    Expression (式)とStatement (文)の出現は、それら自身は、非終端となります。
    他で例えるなら、構文上の定義、
</p>

<pre>
ArgumentList：
	AssignmentExpression
	ArgumentList , ArgumentExpression
</pre>

<p>
    は、 ArgumentList が、単一の AssignmentExpression か、または、カンマに続けて、 AssignmentExpression が続く何れか1つの状態を表す場合があります。
    この ArgumentList の定義は、再帰的で、つまり、それ自身についての観点の中で定義されます。
    その結果は、各引数の式が、 ArgumentExpression である場合、 ArgumentList が、カンマ区切りの正の数の引数を含む場合があるということです。
    このような非終端の再帰定義は、一般的です。
</p>

<p>
    　添字の接尾辞"opt"が、終端や非終端の後に現れる場合、それはオプション記号を示します。
    実際には、右辺に2つ指定するオプション記号を含む選択肢は、1つは省略可能なオプション要素、1つはそれ(省略したもの)を含みます。
    この意味は、
</p>

<pre>
VariableDeclaration：
	Identifier Initialiseropt
</pre>

<p>
    は、
</p>

<pre>
VariableDeclaration：
	Identifier
	Identifier Initialiser
</pre>

<p>
    の便利な略記であり、
</p>

<p>
    　そしてまた、
</p>

<pre class="f8">
IterationStatement：
	for ( ExpressionNoInopt ; Expressionopt ; Expressionopt ) Statement
</pre>

<p>
    は、
</p>

<pre class="f9">
IterationStatement：
	for ( ; Expressionopt ; Expressionopt ) Statement
	for ( ExpressionNoIn ; Expressionopt ; Expressionopt ) Statement
</pre>

<p>
    の便利な省略形であり、それは、反復ステートメント
</p>

<pre class="f9">
IterationStatement：
	for ( ; ; Expressionopt ) Statement
	for ( ; Expression ; Expressionopt ) Statement
	for ( ExpressionNoIn ; ; Expressionopt ) Statement
	for ( ExpressionNoIn ; Expression ; Expressionopt ) Statement
</pre>

<p>
    の省略形であり、それは、
</p>

<pre class="f9">
IterationStatement：
	for ( ; ; ) Statement
	for ( ; ; Expression ) Statement
	for ( ; Expression ; ) Statement
	for ( ; Expression ; Expression ) Statement
	for ( ExpressionNoIn ; ; ) Statement
	for ( ExpressionNoIn ; ; Expression ) Statement
	for ( ExpressionNoIn ; Expression ; ) Statement
	for ( ExpressionNoIn ; Expression ; Expression ) Statement
</pre>

<p>
    の省略形なので、その非終端反復ステートメントは、実際には、右辺に8つの選択肢を持つということになります。
</p>

<p>
    　文法定義内でコロンに続く「下記の内の1つ」(、または、パターンのバリエーションを列挙後に「の内の1つ」)という単語がある場合、それらは、単一または複数行続く終端記号のそれぞれが、選択肢の定義であることを意味します。
    例えば、プロダクションを含むECMAScriptにおけるその語彙的な文法は、
</p>

<pre>
NonZeroDigit::下記の内の1つ
	1 2 3 4 5 6 7 8 9
</pre>

<p>
    　これは、
</p>

<pre>
NonZeroDigit::
	1
	2
	3
	4
	5
	6
	7
	8
	9
</pre>

<p>
    における単に便利な省略形ですが、もし、[empty(カラ)]というフレーズがプロダクションの右辺として表れた場合、それは、プロダクションの右辺が、終端や非終端を何も含まないということを示しています。
</p>

<p>
    　もし、
</p>

<pre>
"[lookahead ? set]"
(lookahead：前方参照設定／？は、∈の否定形／set)
</pre>

<p>
    というフレーズがプロダクションの右辺として現れる場合、それは、直後に続く入力トークンが与えられた set をメンバとする場合、そのプロダクションが、使用されない場合があるということを示します。
    その set は、波カッコで括られた終端のリストとして書かれることが可能です。
</p>

<p>
    　利便性において、その set は、非終端が拡張可能な場合に全ての終端の集合を提示する場合においては、非終端として書かれることも可能です。
    例えば、与えられる定義
</p>

<pre>
DecimalDigit::下記の内の1つ
	0 1 2 3 4 5 6 7 8 9
</pre>

<pre>
DecimalDigits ::
	DecimalDigit
	DecimalDigits DecimalDigit
</pre>

<p>
    　その定義
</p>

<pre>
LookaheadExample::
	n [lookahead ？ {1, 3, 5, 7, 9}] DecimalDigits
	DecimalDigit [lookahead ？ DecimalDigit]
	(lookahead：前方参照設定／？は、∈の否定形)
</pre>

<p>
    は、偶数で始まる1つ以上の10進数値が続く文字 n 、または、その他の10進数値が続かない文字 n の何れかとマッチします。
</p>

<p>
    　もし、そのフレーズ"[no LineTerminator
    here(ここに行終端はない)]"が構文上の文法のプロダクションの右辺に現れる場合、それは、そのプロダクションが、制限付きプロダクションであるということを示し、それは、LineTerminator(行終端)が示した位置にある入力ストリーム内に現れる場合、使用されない可能性があるということです。
    例えば、そのプロダクション
</p>

<pre>
ThrowStatement：
	throw [ここにLineTerminatorはない] Expression ;
</pre>

<p>
    は、仮にLineTerminator(行終端)が、プログラム上のトークン throw と Expression の間に現れる場合、そのプロダクションが使用されない可能性があるということを示しています。
</p>

<p>
    　LineTerminator(行終端)の存在が、制限付きのプロダクションによって禁じられる場合以外は、LineTerminator(行終端)の出現数が、そのプログラムの構文上の受容性に影響を与えることなく、入力要素のストリーム内で2つの連続したトークンの間に現れる場合があります。
    語彙的な文法または数値文字の文法から成るプロダクション内の選択肢が複数文字のトークンとして現れる場合、それは、そのようなトークンを作りだすであろう文字の並びを表します。
    任意のプロダクションの右辺は、そのフレーズ"but not(...ではなく、)"を使用することによって許可されない特定の拡張を指定する場合があり、その場合には、その拡張が除外されることを示します。
    例えば、そのプロダクション
</p>

<pre>
Identifier ::
ReservedWord ではない IdentifierName
</pre>

<p>
    は、<span style="border-bottom: dashed 1pt;">その非終端 Identifier は、ReservedWord と同一の文字の並びは、置き換えることができませんが、それ以外から成る任意の文字の並び IdentifierName によって置き換えられるという意味です。</span>
    (下線部の原文、読解不能の為、意訳)
</p>

<p>
    　最後にいくつかの非終端記号は、選択肢全てを列挙することが実用的でない(非現実的である)場合においては、(フォント)タイプ sans-serif
    での説明フレーズによって説明されます。(webzoit.net内訳文においては、これを踏襲しない可能性があります。)
</p>

<pre>
SourceCharacter ::
	any Unicode code unit
	(何らかのUnicodeコードユニット)
</pre>


</article>
<article>


    <h2>5.2 アルゴリズムの規則・慣例 / Algorithm Conventions </h2>


    <h3 id="x5.2">5.2 アルゴリズムの規則・慣例<a href="#x5.2">#</a></h3>

    <p>
        　その(アルゴリズムの)仕様は、よく、某アルゴリズム内で手順を指定する為に番号付きリストを使用します。
        これらのアルゴリズムは、ECMAScript言語の構築の構文を要求する指定を明確にする為に使用されます。
        そのアルゴリズムとは、任意の特定の実装技術の仕様の利用を暗に意図しているわけではありません。
        実際には、与えられた機能を実装するために利用できる、より効率的なアルゴリズムがあるかもしれません。
    </p>

    <p>
        　この仕様の複数の部分での利用を促進する為に、抽象操作と呼ばれる何らかのアルゴリズムは、名前付けされ、他のアルゴリズム内から名称によって参照される場合がある為、パラメータ機能の形式で書かれます。
    </p>

    <p>
        　任意のアルゴリズムが、結果としての値を生成する為にある場合には、その指示 "return x" は、そのアルゴリズムの結果が x という値であり、そのアルゴリズムが終端とすべきであることを示す為に使用されます。
        表記法 Result(n) は、「手順 n の結果」における略記として使用されます。
    </p>

    <p>
        　式の明確化の為、アルゴリズムの手順は、順序だった小手順(サブステップ)に細分化される場合があります。
        サブステップが示され、さらにそれら自身がインデントしたサブステップの中で細分化される場合もあります。
        番号付け規則の概要としては、まず、1番めのサブステップのレベルは、アルファベット小文字でラベルづけ、2番めのサブステップのレベルは小文字のローマ数字でラベルづけといったようにサブステップを識別する為に使用されます。
        もし、3レベル以上が要求される場合、これらのルールは、数値ラベルを使って4番めのレベルでといった具合に繰り返します。
    </p>

<pre class="f9">
[例]
1. トップレベルステップ
	a. サブステップ
	b. サブステップ
		i. サブサブステップ
		ii. サブサブステップ
			1. サブサブサブステップ
				a サブサブサブサブステップ
...etc.
</pre>

    <p>
        　あるステップやサブステップは、そのサブステップの条件である述部 "if" として書かれる場合があります。
    </p>

    <p>
        　このケースでは、サブステップは、述部が真である場合に限り適用されます。
        もし、あるステップやサブステップが単語を伴って始まる場合には、もし、他にあれば、述部の否定である述部であり、更にもし、あれば、それは同一レベルにある述部ステップです。
    </p>

    <p>
        　あるステップは、そのサブステップの反復アプリケーションを指定する場合があります。
    </p>

    <p>
        　あるステップは、そのアルゴリズムの不変の条件をアサート(主張)する場合があります。
        そのような主張は、明示的に不変条件のアルゴリズムを作る為に利用され、そうでなければ暗黙的に作られます。
        そのような主張は、追加のセマンティック要件を追加しません、したがって、実装によってチェックされる必要はありません。
        それらは単にアルゴリズムを明確にする為に利用されます。
    </p>

    <p>
        　加算、減算、否定、乗算、除算といったような数学的演算、更に、この項の中で後に定義する数学関数は、正のゼロとして認識される無限大と負のゼロを含まない数学的なリアルな値として数学的結果を正確に計算する際に常に理解されるべきです。
        浮動小数点演算というモデルである標準的なアルゴリズムは、無限大、符号付きゼロ、丸め処理実行の為に必要に応じた明示的な手順を含みます。
        もし、数学演算や関数が浮動小数点数を適用される場合には、それは、浮動小数点数を無限大にしなければならないとか、もし、+0とあれば、それは数学的には単に0と一致するというように浮動小数点数を適用されるものとして理解されなければいけません。
    </p>

    <p>
        　数学関数 abs(x) は、x の絶対値を得ることができ、x が(ゼロより小さい)負である場合は -x 、それ以外の場合には、その値は、x それ自身です。
    </p>

    <p>
        　数学関数 sign(x) は、 x が正なら1を生成し、負なら-1を生成します。
        sign 関数は、x がゼロというケースにおいては、この標準では利用されません。
    </p>

    <p>
        　表記(moduloは剰余)
    </p>

<pre>
 x modulo y
</pre>

    <p>
        (yは有限でゼロでなければならない)は、ある整数 q において
    </p>

<pre>
abs(k) &lt; abs(y)
</pre>

    <p>
        と
    </p>

<pre>
x-k = q´y
</pre>

    <p>
        のように y (または、ゼロ)として同一の符号の値 k を算出します。
    </p>

    <p>
        　数学関数 floor(x) は、x より大きくない(正の無限大に最も近い)最大の整数を返します。
    </p>

    <p>
        [注] floor(x) = x-(x modulo 1)
    </p>

    <p>
        　もし、あるアルゴリズムが例外を投げる(スローする)為に定義される場合には、アルゴリズムの実行が終端であり、返される結果はありません。
        アルゴリズムを呼ぶこと自体もまた、アルゴリズムの手順が、「もし、例外が投げられ(スローされ)た場合...」というような専門用語を使うことによって例外として明示的に扱うようなところまで達しない限り、終端であるものとされています。
        一度、そのような例外に遭遇してしまったアルゴリズムの手順は、もはや、そうした例外が現れていることすら考慮されなくなります。
    </p>


</article>
<article>


    <h2>6 ソーステキスト / Source Text </h2>


    <h3 id="x6">6 ソーステキスト<a href="#x6">#</a></h3>

    <p>
        　ECMAScriptのソーステキストは、バージョン 3.0 以降のUnicode文字のエンコード方式である文字列として表現されます。
        そのテキストは、Unicodeテクニカルレポート #15に記述したように Unicode Normalization Form C (canonical composition) / Unicode正規化形式 C
        に正規化されていることが期待されます。
        ECMAScriptの実装は、テキストの正規化を実行することやそれら自身のテキストの正規化を実行したことによる動作は要求されません。
        ECMAScriptのソーステキストは、この仕様の目的において16ビットコードユニットのシーケンスであるものとみなされます。
        このようにソーステキストは、有効な UTF-16 文字エンコード方式ではない16ビットコードユニットの並びを含む場合があります。
        もし、実際のソーステキストが16ビットコードユニット以外の書式のエンコード方式である場合には、それは、まず最初にUTF-16への変換をしたかのように処理されなければいけません。
    </p>

<pre>
【構文】
SourceCharacter ::
any Unicode code unit
(何らかのUnicodeコードユニット)
</pre>

    <p>
        　この文書の残りを通じて「コードユニット」( "code unit" / コード単位)というフレーズと「文字」( "character"
        )という単語は、テキストの任意の1つの16ビット単位を表す為に使用した16ビット符号なしの値を参照する為に使用されるでしょう。
        「Unicode文字」( "Unicode character" )というフレーズは、単一のUnicodeスカラー値によって表された抽象的な言語や表記単位への参照のために利用されるでしょう。
        (これは16ビットより長くなる場合や1コードユニット以上で表される場合があるということです。)
        「コードユニット」( "code unit" )というフレーズは、このようなUnicodeスカラー値を参照します。
        「Unicode文字」( "Unicode character"
        )は、単独のUnicodeスカラー値によって表されるエンティティ(実体)だけを参照し、結合した文字並びの構成(コンポーネント)は、ユーザーが単独の文字としての並び全体であるものと考えるような場合でさえ、それはまだ、個々の「Unicode文字」(
        "Unicode character" )です。
    </p>

    <p>
        　文字列リテラル、正規表現リテラル、識別子においては、ある文字(コードユニット)が、6文字で構成されるUnicodeのエスケープシーケンス、すなわち \u に加えて16進数文字が4つ続くものとして表されます。
        コメント内では、このようなエスケープシーケンスは、コメントの一部として効果的に無視されます。
        文字リテラルや正規表現リテラル内では、Unicodeのエスケープシーケンスは、リテラルの値1文字に寄与して(リテラルの値1文字として使用されて)います。
        識別子内では、エスケープシーケンスは、識別子1文字に寄与して(として使用されて)います。
    </p>

    <p>
        [注釈：]
        この文書では時折、"string(文字列)"内の"character(文字)"間の"transformation(変換)"を参照し、その文字(character)のコードユニットである16ビット符号なし整数は、実際には、16ビット符号なしの値を使用して表現される"string"内の"character"なので、実際には変換するものはありません。
    </p>

    <p>
        　ECMAScriptは、Unicodeエスケープシーケンスの挙動についてプログラミング言語 Java を参考にしています。
        Javaプログラムにおいては、もし、Unicodeエスケープシーケンス \u000A が、例えば、単一行コメント内に現れる場合には、それは、行終端(Unicode文字 000A は
        ラインフィード／改行／\n)として解釈されることになり、それゆえに次の文字はコメントの一部ではありません。
        似たようなケースとして、もし、Unicodeエスケープシーケンス \u000A
        が、Javaプログラム内の文字リテラル内に現れる場合には、それは、同様に行終端として解釈され、文字リテラル内で受け入れられず、ラインフィードが文字列リテラルの文字列値の一部となってしまう要因にもなるので \u000A
        の代わりに \n にしなければいけません。
        ECMAScriptプログラムでは、コメント内に現れるUnicodeエスケープシーケンスは、決して解釈されることはなく、それゆえにコメントの終端には寄与しません(として使用されません)。
        似たようにECMAScriptプログラム内で文字リテラル内に現れるUnicodeエスケープシーケンスは常にリテラルのString値に寄与する(使われる)文字であり、それは、決して行終端や文字リテラルの終端と考えられるクォートマークとして解釈されることはありません。
    </p>


</article>
<article>


    <h2>7 語彙的な表記 / Lexical Conventions </h2>


    <h3>7 語彙的な表記<a href="#x7">#</a></h3>


    <p>
        　ECMAScriptプログラムのソーステキストは、まず最初にトークン、行終端、コメントやホワイトスペースといった入力要素の並びに変換されます。
        ソーステキストは、左から右へスキャンされ、反復的に次の入力要素として最も長い利用可能な文字の並びを取り出します。
        語彙的な文法においては2つの目標記号があります。
        InputElementDiv 記号は、先行する除算(/)演算子、除算代入(/=)演算子が許容される場合、それらの構文的な文法コンテキスト内で利用されます。
        InputElementRegExp 記号は、他の構文的な文法コンテキスト内で利用されます。
    </p>

    <p>
        [注釈：]除算(/)や除算代入(/=)の両方が先行する場合、構文上の文法コンテキストは何もなく、先行する正規表現リテラル( RegularExpressionLiteral )が許容されます。
    </p>

    <p>
        　これは、例えば次の例においてセミコロン挿入(7.9項参照)による影響を受けないということです。
    </p>

<pre>
a = b
/hi/g.exec(c).map(d);
</pre>

    <p>
        　LineTerminator(行終端)の直後にくる非ホワイトスペースや非コメント文字の先頭が、スラッシュ(/)である場合、その構文上のコンテキストは、除算や除算代入を許容し、LineTerminator(行終端)位置で挿入されるセミコロンはありません。
    </p>

    <p>
        　つまり、上記の例は、
    </p>

<pre>
a = b / hi / g.exec(c).map(d);
</pre>

    <p>
        (改行のない一行の文)と同じ様に解釈されるということです。
    </p>

<pre>
【構文】
InputElementDiv ::
	WhiteSpace
	LineTerminator
	Comment
	Token
	DivPunctuator

InputElementRegExp ::
	WhiteSpace
	LineTerminator
	Comment
	Token
	RegularExpressionLiteral
</pre>


</article>
<article>


    <h2>7.1 Unicodeの書式制御文字 / Unicode Format-Control Characters </h2>


    <h3 id="x7.1">7.1 Unicodeの書式制御文字<a href="#x7.1">#</a></h3>

    <p>
        　Unicodeの書式制御文字(参考例としてカテゴリ内の文字、LEFT-TO-RIGHT マークや RIGHT-TO-LEFT マークのようなUnicode文字データベースにある Cf
        )は、(マークアップ言語のように)これにおけるより高度なプロトコル(手順・規約)がない中でテキストの範囲における書式を制御する為に利用する制御コードです。
        それは、編集や表示を促す為のソーステキスト内にある書式制御文字を受け入れるのに便利です。
    </p>

    <p>
        　全ての書式制御文字は、コメント内、文字列リテラル内、正規表現リテラル内で利用されます。
        &lt;ZWNJ&gt; と &lt;ZWJ&gt; は、特定の言語の単語やフレーズの形式を区別するのに必要とされ、利用される書式制御文字です。
        ECMAScriptのソーステキスト &lt;ZWNJ&gt; と &lt;ZWJ&gt; は、最初の文字の後、識別子の中で利用される場合もあります。
        &lt;BOM&gt; は、Unicodeとして解釈される為にテキストの先頭に配置され、優先的にテキストのエンコード方式とバイトオーダーの検出を許可する為に使われる書式制御文字です。
        この目的において意図された連結するファイルの結果としてといった例などにおいて &lt;BOM&gt; 文字は、テキストの先頭の後に現れることもあり得ます。
        &lt;BOM&gt; 文字は、ホワイトスペース文字として扱われます。(7.2項参照)
        コメントや文字リテラルの外側にある特定の書式制御文字と正規表現リテラルの特別な処理は、Table 1.で要約されています。
    </p>

    <div class="pre-div">
<pre>
Table 1. 書式制御文字のコードユニット値の利用方法
----------------------------------------------------------------------------------------
コードユニット値	名称			正式名		使用方法
----------------------------------------------------------------------------------------
\u200C			Zero width non-joiner	&lt;ZWNJ&gt;		識別子部分
\u200D			Zero width joiner	&lt;ZWJ&gt;		識別子部分
\uFEFF			Byte Order Mark		&lt;BOM&gt;		ホワイトスペース
----------------------------------------------------------------------------------------
</pre>
    </div>


</article>
<article>


    <h2>7.2 ホワイトスペース / White Space </h2>


    <h3 id="x7.2">7.2 ホワイトスペース<a href="#x7.2">#</a></h3>

    <p>
        　ホワイトスペース文字は、ソーステキストの可読性を向上させる為や(語彙的にそれ以上は分割できない)トークンを分割する為に利用されますが、それ以外にはそれほど重要ではありません。
        ホワイトスペース文字は、一部2つのトークンの間、また入力の始まりや終わりに現れる場合があります。
        ホワイトスペース文字は、リテラル値の一部を形成するのに重要な文字として想定される文字列リテラル(StringLiteral)内、正規表現リテラル(RegularExpressionLiteral)内やコメント内などに現れる場合もありますが、それ以外の他の種類において現れることはできません。
    </p>

    <p>
        　ECMAScriptのホワイトスペース文字は、Table 2 に列挙されます。
    </p>

    <div class="pre-div">
<pre class="f8">
Table 2 ホワイトスペース文字
-----------------------------------------------------------------------------
コードユニット値	名称					公式記号名
-----------------------------------------------------------------------------
\u0009			Tab					&lt;TAB&gt;
\u000B			Vertical Tab				&lt;VT&gt;
\u000C			Form Feed				&lt;FF&gt;
\u0020			Space					&lt;SP&gt;
\u00A0			No-break space				&lt;NBSP&gt;
\uFEFF			Byte Order Mark				&lt;BOM&gt;
その他カテゴリ"Zs"	他の何らかの Unicode "space separator"	&lt;USP&gt;
-----------------------------------------------------------------------------
</pre>
    </div>

    <p>
        　ECMAScriptの実装は、Unicode 3.0で定義されたホワイトスペース文字の全てを認識しなけばいけません。
        Unicode標準規格の最新エディションは、他のホワイトスペース文字を定義する場合もあります。
        ECMAScriptの実装によっては、Unicode標準規格の最新エディションにおけるホワイトスペース文字を認識する場合もあります。
    </p>

<pre>
【構文】
WhiteSpace ::
	&lt;TAB&gt;
	&lt;VT&gt;
	&lt;FF&gt;
	&lt;SP&gt;
	&lt;NBSP&gt;
	&lt;BOM&gt;
	&lt;USP&gt;
</pre>


</article>
<article>


    <h2>7.3 行終端 / Line Terminators </h2>


    <h3 id="x7.3">7.3 行終端<a href="#x7.3">#</a></h3>

    <p>
        　ホワイトスペース文字のように行終端文字は、ソーステキストの可読性向上と相互に(単独の語彙単位に)字句を区切る為に利用されます。
        しかしながら、ホワイトスペース文字とは異なり、行終端は、いくつかの構文上の文法の動作を超えた影響を持つ場合があります。
        一般には、行終端は2つの軸の間に現れますが、一部、構文上の文法によって禁じられる場所に存在する場合もあります。
        行終端はまた、自動セミコロン挿入(7.9)の過程に影響します。
        行終端は、文字列リテラル(StringLiteral)を除くいかなる字句内にも現れることはできません。
        行終端は、唯一、行継続(LineContinuation)の一部として文字列リテラル(StringLiteral)内に現れます。
    </p>

    <p>
        　1つの行終端は、MultiLineComment(複数行コメント) (7.4)内に現れることはできますが、単独行コメント(SingleLineComment)内に現れることはできません。
    </p>

    <p>
        　ホワイトスペース文字の集合内に含まれる行終端は、正規表現の中で\sクラスでマッチさせます。
    </p>

    <p>
        　ECMAScript行終端文字は、Table 3内で列挙されます。
    </p>

    <div class="pre-div">
<pre>
Table 3 行終端文字
----------------------------------------------------------
コードユニット値	名称			正式名
----------------------------------------------------------
\u000A			Line Feed		&lt;LF&gt;
\u000D			Carriage Return		&lt;CR&gt;
\u2028			Line separator		&lt;LS&gt;
\u2029			Paragraph separator	&lt;PS&gt;
----------------------------------------------------------
</pre>
    </div>

    <p>
        　Table 3にある文字に限っては、行終端として扱われます。
        他の新しい行や行改行文字は、行終端としてではなくホワイトスペースとして扱われます。
        &lt;CR&gt;&lt;LF&gt; が一般的である文字シーケンス(文字並び)は、行終端として利用します。
        それは、行番号を報告する目的において単独の文字として認識されるべきです。
    </p>

<pre>
【構文】
LineTerminator(行終端) ::
	&lt;LF&gt;
	&lt;CR&gt;
	&lt;LS&gt;
	&lt;PS&gt;

LineTerminatorSequence(行終端並び) ::
	&lt;LF&gt;
	&lt;CR&gt;
	[ 前方参照  ？ &lt;LF&gt; ](？は、∈ の否定形)
	&lt;LS&gt;
	&lt;PS&gt;
	&lt;CR&gt;&lt;LF&gt;
</pre>


</article>
<article>


    <h2>7.4 コメント / Comments </h2>


    <h3 id="x7.4">7.4 コメント<a href="#x7.4">#</a></h3>

    <p>
        　コメントは、単一行または複数行何れにすることもできます。
        複数行コメントはネストできません。
    </p>

    <p>
        　なぜなら単一行コメントは、一部、LineTerminator(行終端)文字を含むことができますし、一般規則からして字句は常に同じ長さであり、単独行コメントは常に行の最後までを印付けする //
        (スラッシュ2つ)から始まり文字全てから成るからです。
        しかしながら、行の最後にある行終端(LineTerminator)は、単一行コメントの一部となることは考慮されません。
        それは語彙的な文法によって分けて認識され、構文上の文法における入力要素のストリームの一部になります。
        この点は、自動セミコロン挿入の経過に影響しない単一行コメントの存在や欠如という意味でとても重要です。(7.9参照)
    </p>

    <p>
        　コメントは、ホワイトスペースのように振る舞い、それ以外は廃棄され、もし、複数行コメント(MultiLineComment)が行終端文字を含む場合には、入力コメントが構文上の文法によって構文解析する目的において行終端(LineTerminator)にすることが考慮されます。
    </p>

    <div class="pre-div">
<pre>
【構文】
Comment (コメント) ::
MultiLineComment (複数行コメント)
SingleLineComment (単一行コメント)

MultiLineComment (複数行コメント)::
/* MultiLineCommentCharsopt */
( /* 複数行コメント文字[オプション] */ )
</pre>
    </div>

    <div class="pre-div">
<pre class="f8">
MultiLineCommentChars ::
(複数行コメント文字)
MultiLineNotAsteriskChar MultiLineCommentCharsopt
アスタリスクのない複数行文字 複数行コメント文字[オプション]
</pre>
    </div>

    <div class="pre-div">
<pre>
* PostAsteriskCommentCharsopt
(後置アスタリスクコメント文字[オプション])
</pre>
    </div>

    <div class="pre-div">
<pre class="f8">
PostAsteriskCommentChars ::
(後置アスタリスクコメント文字)
MultiLineNotForwardSlashOrAsteriskChar MultiLineCommentCharsopt
(先行するスラッシュやアスタリスクのない複数行文字 複数行コメント文字[オプション])
</pre>
    </div>

    <div class="pre-div">
<pre>
* PostAsteriskCommentCharsopt
(後置アスタリスクコメント文字[オプション])
</pre>
    </div>

    <div class="pre-div">
<pre>
MultiLineNotAsteriskChar ::
(アスタリスクのない複数行文字)
アスタリスクではない SourceCharacter(ソース文字)

</pre>
    </div>

    <div class="pre-div">
<pre>
MultiLineNotForwardSlashOrAsteriskChar ::
(先行するスラッシュやアスタリスクのない複数行文字)
SourceCharacter but not forward-slash / or asetrisk *
(先行するスラッシュやアスタリスクのないソース文字)
</pre>
    </div>

    <div class="pre-div">
<pre>
SingleLineComment (単独行コメント) ::
// SingleLineCommentCharsopt
(// 単独行コメント文字[オプション])

SingleLineCommentChars (単一行コメント文字) ::
SingleLineCommentChar SingleLineCommentCharsopt
(単一行コメント文字 単一行コメント文字[オプション])

SingleLineCommentChar (単一行コメント文字) ::
LineTerminator ではない SourceCharacter
(行終端ではないソース文字)
</pre>
    </div>


</article>
<article>


    <h2>7.5 字句(トークン) / Tokens </h2>


    <h3 id="x7.5">7.5 字句(トークン)<a href="#x7.5">#</a></h3>

<pre>
構文
Tokens (字句) ::
IdentifierName (識別子名)
Punctuator (句読点)
NumericLiteral (数値リテラル)
StringLiteral (文字列リテラル)
</pre>

    <p>
        [注釈：]DivPunctuator(区分句読点)とRegularExpressionLiteral(正規表現リテラル)も字句を定義しますが、Tokenプロダクションには含まれません。
    </p>


</article>
<article>


<h2>7.6 識別子名と識別子 / Identifier Names and Identifiers </h2>


<h3 id="x7.6">7.6 識別子名と識別子<a href="#x7.6">#</a></h3>

<p>
    　字句である識別子名は、一部わずかな修飾子を伴うUnicode標準仕様の第5章の『Identifiers(識別子)』セクション(節)で与えられる文法によって解析されます。
    あるIdentifierNameという、ある識別子( 7.6.1 参照)は、予約語(ReservedWord)ではありません。
    Unicode識別子の文法は、Unicode標準仕様によって記述される非正規・正規の文字カテゴリ双方を基準にします。
    Unicode標準仕様の第3版内のカテゴリに記述された中にある文字は、完全準拠するECMAScript実装によってそれらのカテゴリにあるものとして扱われます。
</p>

<p>
    　この標準仕様は、文字追加の仕様を記述します。
    ダラー記号( $ )とアンダースコア( _ )は、IdentifierName(識別子名)内のどこにあっても解釈されます。
</p>

<p>
    　Unicodeエスケープシーケンスもまた、当該IdentifierName(識別子名)においてUnicodeEscapeSequence(Unicodeエスケープシーケンス)のCVによって算出される際に単独の文字に寄与するIdentifierName(識別子名)の中で解釈されます。(
    7.8.4 参照)
    先行するUnicodeEscapeSequence(Unicodeエスケープシーケンス) \ は、IdentifierName(識別子名)における文字に寄与し(使用され)ません。
    Unicodeエスケープシーケンス(UnicodeEscapeSequence)は、不正ではないIdentifierName(識別子名)について文字を配置する為に利用されることはできません。
    言い換えると、もし、UnicodeEscapeSequence(Unicodeエスケープシーケンス) \
    が、当該UnicodeEscapeSequence(Unicodeエスケープシーケンス)のCVによって置き換えられる場合、その結果は、まだ元のIdentifierName(識別子名)と正確に同じ文字の並びを持つ有効なIdentifierName(識別子名)としなければいけません。
    この仕様内の識別子についての全ての解釈は、一部の固有文字に寄与(使用)する為に利用されたエスケープシーケンスか否かに関わらず、それら実際の文字を基準にします。
</p>

<p>
    　Unicode標準仕様と一致するまさに等価である2つのIdentifierName(識別子名)であっても、厳密に同一のコード単位の並びによって表されない限り、イコールではありません。
    (言い換えるとECMAScript実装はIdentifierName(識別子名)をビット単位で比較する為にだけ、唯一要求されます。)
    その意図は、コンパイラに到達する前に正規化形式 Cに変換されるソーステキストであるということです。
</p>

<p>
    　ECMAScript実装はUnicode標準仕様の最新版で定義した識別子文字を認識する場合があります。
    もし、移植性が気になる場合には、プログラマはUnicode 3.0で定義した識別子文字だけを採用するべきです。
</p>

<div class="pre-div">
<pre>
【構文】
識別子(Identifier) ::
予約語(ReservedWord)ではない識別子(IdentifierName)

識別子名(IdentifierName) ::
識別子開始(IdentifierStart)
識別子名 識別子部(IdentifierName IdentifierPart)

識別子開始(IdentifierStart) ::
Unicode文字(UnicodeLetter)
$
_
\ Unicodeエスケープシーケンス(UnicodeEscapeSequence)
</pre>
</div>

<div class="pre-div">
<pre>
IdentifierPart (識別子部分) ::
	IdentifierStart (識別子の開始)
	UnicodeCombiningMark (Unicode結合マーク)
	UnicodeDigit (Unicode数字)
	UnicodeConnectorPunctuation (Unicode接続句読点)
	&lt;ZWNJ&gt;
	&lt;ZWJ&gt;
</pre>
</div>

<div class="pre-div">
<pre>
UnicodeLetter(Unicode文字) ::
"Uppercase letter (Lu)"、"Lowercase letter (Ll)"、"Titlecase letter (Lt)"、"Modifier letter (Lm)"、"Other letter (Lo)"や"Letter number (Nl)"といったUnicodeカテゴリにある一部の文字
("大文字 (Lu)"、"小文字 (Ll)"、"タイトル大文字 (Lt)"、"修飾文字 (Lm)"、"その他文字 (Lo)"や"文字番号 (Nl)"といったUnicodeカテゴリにある一部の文字)
</pre>
</div>

<div class="pre-div">
<pre>
UnicodeCombiningMark(Unicode結合マーク) ::
"Non-spacing mark (Mn)"や"Combining spacing mark (Mc)"といったUnicodeカテゴリにある一部の文字
("非スペースマーク (Mn)"や"結合スペースマーク (Mc))"といったUnicodeカテゴリにある一部の文字)
</pre>
</div>

<div class="pre-div">
<pre>
UnicodeDigit(Unicode数字) ::
"Decimal number (Nd)(十進数 (Nd))"といったUnicodeカテゴリにある一部の文字
</pre>
</div>

<div class="pre-div">
<pre>
UnicodeConnectorPunctuation(Unicode接続句読点) ::
"Connector punctuation (Pc)(接続句読点 (Pc))"といったUnicodeカテゴリにある一部の文字
</pre>
</div>

<p>
    非終端のUnicodeエスケープシーケンス(UnicodeEscapeSequence)の定義は、 7.8.4 でなされます。
</p>

<h3 id="x7.6.1">7.6.1 予約語<a href="#x7.6.1">#</a></h3>

<p>
    　予約語は、識別子として使うことができないIdentifierName(識別子名)です。
</p>

<pre>
【構文】
	ReservedWord (予約語) ::
	Keyword (キーワード)
	FutureReservedWord (将来の予約語)
	NullLiteral (Nullリテラル)
	BooleanLiteral (Booleanリテラル)
</pre>

<h3 id="x7.6.1.1">7.6.1.1 キーワード<a href="#x7.6.1.1">#</a></h3>

<p>
    　次に続く字句は、ECMAScriptのキーワードであり、一部は、ECMAScriptのプログラム内で識別子として使われない場合もあります。
</p>

<pre>
【構文】
Keyword (キーワード)::
	break
	do
	instanceof
	typeof
	case
	else
	new
	var
	catch
	finally
	return
	void
	continue
	for
	switch
	while
	debugger
	function
	this
	with
	default
	if
	throw
	delete
	in
	try
</pre>

<p>
    の何れか1つ
</p>

<h3 id="x7.6.1.2">7.6.1.2 将来の予約語<a href="#x7.6.1.2">#</a></h3>

<p>
    　次に続く単語は、推奨する拡張子内のキーワードとして使われるので、それら拡張子が将来採用される可能性を受け入れる為に予約されます。
</p>

<pre>
【構文】
FutureReservedWord (将来の予約語) ::
	class
	enum
	extends
	super
	const
	export
	import
</pre>

<p>
    の何れか1つ
</p>

<p>
    　次に続く字句は、厳密モード(strict mode)のコード内に現れる場合にFutureReservedWord(将来の予約語)にすることが考慮されます。( 10.1.1 参照)
    エラーを生成するであろうFutureReservedWord(将来の予約語)の出現のある文脈内においてstrictモード内にあるこれらの字句の一部の出現は、評価エラーをも生成しなければいけません。
</p>

<pre>
	implements
	let
	private
	public
	yield
	interface
	package
	protected
	static
</pre>


</article>
<article>


    <h2>7.7 句読点・句読文字 / Punctuators </h2>


    <h3 id="x7.7">7.7 句読点・句読文字<a href="#x7.7">#</a></h3>

<pre>
Syntax Punctuator(構文上の句読文字) ::
	{
	}
	(
	)
	[
	]
	.
	;
	,
	</pre>

    <p>
        の何れか1つ
    </p>

<pre>
DivPunctuator(区分句読文字) ::
	/
	/=
</pre>

    <p>
        の何れか1つ
    </p>


</article>
<article>


<h2>7.8 リテラル / Literals </h2>


<h3 id="x7.8">7.8 リテラル<a href="#x7.8">#</a></h3>

<pre>
【構文】
Literal ::
	NullLiteral
	BooleanLiteral
	NumericLiteral
	StringLiteral
	RegularExpressionLiteral
</pre>

<h3 id="x7.8.1">7.8.1 Nullリテラル(NullLiteral)<a href="#x7.8.1">#</a></h3>

<pre>
【構文】
Null Literal ::
	null
</pre>

<p>
    【セマンティクス(意味論・統語論)】
</p>

<p>
    nullリテラルnullという値は、唯一のNullタイプという値、すなわちnullです。
</p>

<h3 id="x7.8.2">7.8.2 Booleanリテラル(BooleanLiteral)<a href="#x7.8.2">#</a></h3>

<pre>
【構文】
BooleanLiteral ::
	true
	false
</pre>

<p>
    【セマンティクス(意味論・統語論)】
</p>

<p>
    Booleanリテラルtrueという値は、Booleanタイプの値、すなわちtrueです。
</p>

<p>
    Booleanリテラルfalseという値は、Booleanタイプの値、すなわちfalseです。
</p>

<h3 id="x7.8.3">7.8.3 数値リテラル(NumericLiteral)<a href="#x7.8.3">#</a></h3>

<div class="pre-div">
<pre class="f9">
【構文】

数値リテラル(NumericLiteral) ::
	10進リテラル(DecimalLiteral)
	16進整数リテラル(HexIntegerLiteral)

10進リテラル(DecimalLiteral) ::
	10進整数リテラル . 10進数字[オプション] 指数部[オプション]
	(DecimalIntegerLiteral . DecimalDigitsopt ExponentPartopt)
	 . 10進数字[オプション] 指数部[オプション]
	( . DecimalDigitsopt ExponentPartopt)
	10進整数リテラル 指数部[オプション]
	(DecimalIntegerLiteral ExponentPartopt)


10進整数リテラル(DecimalIntegerLiteral) ::
	0
	非ゼロ数字 10進数字[オプション]
	(NonZeroDigit DecimalDigitsopt)


10進数字 (DecimalDigits) ::
	DecimalDigit
	DecimalDigits DecimalDigit


10進数字 (DecimalDigit) ::
	0 1 2 3 4 5 6 7 8 9
の何れか1つ

非ゼロ数字 (NonZeroDigit) ::
	1 2 3 4 5 6 7 8 9
の何れか1つ

指数部 (ExponentPart) ::
	指数指標 符号付き整数
	(ExponentIndicator SignedInteger)

指数指標 (ExponentIndicator) ::
	e	E
の何れか1つ

符号付き整数 (SignedInteger) ::
	10進数字 (DecimalDigits)
	+ 10進数字 (+ DecimalDigits)
	- 10進数字 (- DecimalDigits)

16進整数リテラル (HexIntegerLiteral) ::
	0x 16進数字(0x HexDigit)
	0X 16進数字(0X HexDigit)
	16進整数リテラル 16進数字(HexIntegerLiteral HexDigit)

16進数字(HexDigit) ::
	0 1 2 3 4 5 6 7 8 9 a b c d e f A B C D E F
の何れか1つ
</pre>
</div>

<p>
    　数値リテラル(NumericLiteral)のすぐ後に続くソース文字は、識別子の開始(IdentifierStart)または10進数字(DecimalDigit)にしてはいけません。
</p>

<p>
    [注釈]
</p>

<pre>
例)	3in
</pre>
<p>
    　3in というのはエラーであり、"3"と"in"という2つの入力要素ではありません(とはみなされません)。
</p>

<p>
    【セマンティクス】
</p>

<p>
    　ある数値リテラルは数字タイプの値に当てはまります。
    この値は2つの段階を経て決められます。
    まず最初に、1つの数学的な値(Mathematical Value / MV)は、リテラルから派生します。
    次にこの数学的な値は以下に記述するように丸められます(丸め処理が行われます)。
</p>

<div class="pre-div">
<pre>
・NumericLiteral(数値リテラル)から成るMV :: [ 10進リテラル(DecimalLiteral) ]は、10進リテラル(DecimalLiteral)から成るMV.
・NumericLiteral(数値リテラル)から成るMV :: [ 16進整数リテラル(HexIntegerLiteral) ]は、16進整数リテラル(HexIntegerLiteral)から成るMV.
・DecimalLiteral(10進リテラル)から成るMV :: [ 10進整数リテラル(DecimalIntegerLiteral) .  ]は、10進整数リテラル(DecimalIntegerLiteral)から成るMV.
・DecimalLiteral(10進リテラル)から成るMV :: [ 10進整数リテラル(DecimalIntegerLiteral) . 10進数字(DecimalDigit) ]は、10進整数リテラル(DecimalIntegerLiteral)から成るMV plus (10進数字(DecimalDigit)から成るMVs の [ 10^-n ]倍(10のマイナスn乗))、[ n ]は、10進数字(DecimalDigits)... にある文字の数.
・DecimalLiteral(10進リテラル)から成るMV :: [ 10進整数リテラル(DecimalIntegerLiteral) . 指数部(ExponentPart) ]は、10進整数リテラル(DecimalIntegerLiteral)から成るMV の[ 10e ]倍、[ e ]は、指数部(ExponentPart)から成るMV.
・DecimalLiteral(10進リテラル)から成るMV :: [ 10進整数リテラル(DecimalIntegerLiteral) . 10進数字(DecimalDigits)... 指数部(ExponentPart) ]は、(10進整数リテラル(DecimalIntegerLiteral)から成るMV プラス (10進数字(DecimalDigit)から成るMVs の [ 10^-n ]倍(10のマイナスn乗))) [ 10e倍 ]、[ n ]は、10進数字(DecimalDigits)... にある文字の数、[ e ]は、指数部(ExponentPart)から成るMV.
・DecimalLiteral(10進リテラル)から成るMV :: [ . 10進数字(DecimalDigit) ]は、10進数字(DecimalDigit)から成るMVs の [ 10^-n ]倍(10のマイナスn乗)、[ n ]は、10進数字(DecimalDigits)... にある文字の数.
・DecimalLiteral(10進リテラル)から成るMV :: [ . 10進数字(DecimalDigits)... 指数部(ExponentPart) ]は、10進数字(DecimalDigit)から成るMVs の [ 10^-n ]倍(10のマイナスn乗)、[ n ]は、10進数字(DecimalDigits)... にある文字の数、[ e ]は、指数部(ExponentPart)から成るMV.
・DecimalLiteral(10進リテラル)から成るMV :: [ 10進整数リテラル(DecimalIntegerLiteral) ]は、10進整数リテラル(DecimalIntegerLiteral)から成るMV.
・DecimalLiteral(10進リテラル)から成るMV :: [ 10進整数リテラル(DecimalIntegerLiteral) 指数部(ExponentPart) ]は、10進整数リテラル(DecimalIntegerLiteral)から成るMV の[ 10e ]倍、[ e ]は、指数部(ExponentPart)から成るMV.
・DecimalIntegerLiteral(10進整数リテラル)から成るMV :: [ 0 ] は、 0.
・DecimalIntegerLiteral(10進整数リテラル)から成るMV :: [ 非ゼロ数字(NonZeroDigit) ]は、 非ゼロ数字(NonZeroDigit)から成るMV.
・DecimalIntegerLiteral(10進整数リテラル)から成るMV :: [ 非ゼロ数字(NonZeroDigit) 10進数字(DecimalDigit) ]は、[ (非ゼロ数字(NonZeroDigit)から成るMV の[ 10^n ]倍(10のn乗)) プラス 10進数字(DecimalDigit)から成るMVs ]、[ n ]は、10進数字(DecimalDigits)... にある文字の数.
・DecimalDigit(10進数字)から成るMVs :: [ 10進数字(DecimalDigit) ]は、10進数字(DecimalDigit)から成るMV.
・DecimalDigit(10進数字)から成るMVs :: [ 10進数字(DecimalDigits)... 10進数字(DecimalDigit) ]は、[ (10進数字(DecimalDigit)から成るMVsの[ 10 ]倍) プラス 10進数字(DecimalDigit)から成るMV ].
・ExponentPart(指数部)から成るMV :: [ 指数指標(ExponentIndicator) 符号付き整数(SignedInteger) ]は、符号付き整数(SignedInteger)から成るMV.
・SignedInteger(符号付き整数)から成るMV :: [ 10進数字(DecimalDigit) ]は、10進数字(DecimalDigit)から成るMVs.
・SignedInteger(符号付き整数)から成るMV :: [ + 10進数字(DecimalDigit) ]は、10進数字(DecimalDigit)から成るMVs.
・SignedInteger(符号付き整数)から成るMV :: [ - 10進数字(DecimalDigit) ]は、10進数字(DecimalDigit)から成るMVsの負の値.
・DecimalDigit(10進数字)から成るMV :: [ 0 ] または、16進数字から成る :: [ 0 ]は、 0.
・DecimalDigit(10進数字)から成るMV :: [ 1 ] または、NonZeroDigit(非ゼロ数字)から成る :: [ 1 ] または、16進数字から成る :: [ 1 ]は、 1.
・DecimalDigit(10進数字)から成るMV :: [ 2 ] または、NonZeroDigit(非ゼロ数字)から成る :: [ 2 ] または、16進数字から成る :: [ 2 ]は、 2.
・DecimalDigit(10進数字)から成るMV :: [ 3 ] または、NonZeroDigit(非ゼロ数字)から成る :: [ 3 ] または、16進数字から成る :: [ 3 ]は、 3.
・DecimalDigit(10進数字)から成るMV :: [ 4 ] または、NonZeroDigit(非ゼロ数字)から成る :: [ 4 ] または、16進数字から成る :: [ 4 ]は、 4.
・DecimalDigit(10進数字)から成るMV :: [ 5 ] または、NonZeroDigit(非ゼロ数字)から成る :: [ 5 ] または、16進数字から成る :: [ 5 ]は、 5.
・DecimalDigit(10進数字)から成るMV :: [ 6 ] または、NonZeroDigit(非ゼロ数字)から成る :: [ 6 ] または、16進数字から成る :: [ 6 ]は、 6.
・DecimalDigit(10進数字)から成るMV :: [ 7 ] または、NonZeroDigit(非ゼロ数字)から成る :: [ 7 ] または、16進数字から成る :: [ 7 ]は、 7.
・DecimalDigit(10進数字)から成るMV :: [ 8 ] または、NonZeroDigit(非ゼロ数字)から成る :: [ 8 ] または、16進数字から成る :: [ 8 ]は、 8.
・DecimalDigit(10進数字)から成るMV :: [ 9 ] または、NonZeroDigit(非ゼロ数字)から成る :: [ 9 ] または、16進数字から成る :: [ 9 ]は、 9.
・HexDigit(16進数字) :: [ a ] または、16進数字から成る :: [ A ]は、 10.
・16進数字(HexDigit) :: [ b ] または、16進数字から成る :: [ B ]は、 11.
・16進数字(HexDigit) :: [ c ] または、16進数字から成る :: [ C ]は、 12.
・16進数字(HexDigit) :: [ d ] または、16進数字から成る :: [ D ]は、 13.
・16進数字(HexDigit) :: [ e ] または、16進数字から成る :: [ E ]は、 14.
・16進数字(HexDigit) :: [ f ] または、16進数字から成る :: [ F ]は、 15.
・16進整数リテラル(HexIntegerLiteral)から成るMV :: [ 0x 16進数字(DecimalDigit) ]は、16進数字(HexDigit).
・16進整数リテラル(HexIntegerLiteral)から成るMV :: [ 0X 16進数字(DecimalDigit) ]は、16進数字(HexDigit).
・16進整数リテラル(HexIntegerLiteral)から成るMV :: [ 16進整数リテラル(HexIntegerLiteral) 16進数字(HexDigit) ]は、[ (16進整数リテラル(HexIntegerLiteral)から成るMVの16倍) プラス 16進数字(HexDigit) ].
</pre>
</div>

<p>
    　一度、数値リテラルにおける正確なMVが決められると、それはNumber型の値に丸められます。
    もし、MVが0だった場合、その丸め値は、[ +0
    ]であり、そうでなければ、リテラルが10進リテラル(DecimalLiteral)であり、そのリテラルが20以上である有効な数字を持ち、Number(型の)値が、20番めの数字以降の有効な数字ごとに置き換えられることによって生成されたリテラルから成るMVにおけるNumber(型の)値、または数字0を伴う20番め以降の有効な数字ごとに置き換えられることによって生成されるリテラルから成るMVにおけるNumber(型の)値であり、そしてまた有効な数字の位置である20番めにリテラルを増分する場合でない限り、丸め値は、(8.5
    に書いたように)MVにおけるNumber(型の)値にしなければいけません。
    1つの数字は、もし、それが指数部の一部でない場合で且つ
</p>
<ul>
    <li>それが0ではない、または</li>
    <li>その左側が非ゼロ数字で、その右側に指数部内にない非ゼロ数字がある</li>
</ul>
<p>
    という場合、かなり重要です。
    準拠する実装は、strictモードのコードを処理する際( 10.1.1 参照)には、B.1.1
    で説明したように8進数値リテラル(OctalIntegerLiteral)を含む為に数値リテラル(NumericLiteral)の構文を拡張してはいけません。
</p>

<h3 id="x7.8.4">7.8.4 文字列リテラル(String Literals)<a href="#x7.8.4">#</a></h3>

<p>
    　文字列リテラルは、シングルクォートやダブルクォートで括られるゼロ個以上の文字です。
    各文字は、エスケープシーケンスによって表現される場合もあります。
    全ての文字は、書いた文字の通り、または、閉じるクォート、バックスラッシュ、キャリッジリターン、行セパレータ、段落セパレータ、ラインフィードを除く、文字列リテラル内に現れる場合があります。
    一部の文字は、エスケープシーケンスから成る書式内に現れる場合もあります。
</p>

<div class="pre-div">
<pre>
【構文】
StringLiteral ::
" DoubleStringCharactersopt " ' SingleStringCharactersopt '

DoubleStringCharacters ::
DoubleStringCharacter DoubleStringCharactersopt

SingleStringCharacters ::
SingleStringCharacter SingleStringCharactersopt

DoubleStringCharacter ::
SourceCharacter but not one of " or \ or LineTerminator \ EscapeSequence LineContinuation

SingleStringCharacter ::
SourceCharacter but not one of ' or \ or LineTerminator \ EscapeSequence LineContinuation

LineContinuation ::
\ LineTerminatorSequence

EscapeSequence ::
CharacterEscapeSequence 0 [lookahead ? DecimalDigit] HexEscapeSequence UnicodeEscapeSequence

CharacterEscapeSequence ::
SingleEscapeCharacter NonEscapeCharacter

SingleEscapeCharacter ::
one of ' " \ b f n r t v

NonEscapeCharacter ::
SourceCharacter but not one of EscapeCharacter or LineTerminator

EscapeCharacter ::
SingleEscapeCharacter
DecimalDigit
x
u

HexEscapeSequence ::
x HexDigit HexDigit

UnicodeEscapeSequence ::
u HexDigit HexDigit HexDigit HexDigit
</pre>
</div>

<p>
    　非終端の16進数字(HexDigit)の定義は、7.8.3 にあります。
</p>

<p>
    　ソース文字(SourceCharacter)は、第6項で定義されます。
</p>

<p>
    【セマンティクス】
</p>

<p>
    　文字列リテラルはString型の値に当てはめられます。
    リテラルから成るString値(String value / SV)は、文字列リテラルの様々な部分に寄与する文字値(character values / CV)の為に説明されます。
    このプロセスの一部として、文字列リテラル内の一部の文字は、次や7.8.3 で説明したように数学的な値(mathematical value / MV)を持つものとして解釈されます。
</p>

<div class="pre-div">
<pre>
・文字列リテラル(StringLiteral)のSV :: "" は、カラ(空／empty)文字シーケンス.
・文字列リテラル(StringLiteral)のSV :: '' は、カラ(空／empty)文字シーケンス.
・文字列リテラル(StringLiteral)のSV :: " ダブルString文字...(DoubleStringCharacters) " は、ダブルString文字(DoubleStringCharacters)のSV.
・文字列リテラル(StringLiteral)のSV :: ' シングルString文字...(SingleStringCharacters) ' は、シングルString文字(SingleStringCharacters)のSV.
・ダブルString文字(DoubleStringCharacters)のSV :: ダブルString文字(DoubleStringCharacter)は、一文字のシーケンス(並び)、ダブルString文字(DoubleStringCharacter)のCV.
・ダブルString文字(DoubleStringCharacters)のSV :: ダブルString文字(DoubleStringCharacter) ダブルString文字...(DoubleStringCharacters)は、指示内のダブルString文字(DoubleStringCharacters)のSVにある全ての文字に続くダブルString文字(DoubleStringCharacter)のCVのシーケンス(並び).
・シングルString文字(SingleStringCharacters)のSV :: シングルString文字(SingleStringCharacter)は、一文字のシーケンス(並び)、シングルString文字(SingleStringCharacter)のCV.
・シングルString文字(SingleStringCharacters)のSV :: シングルString文字(SingleStringCharacter シングルString文字...(SingleStringCharacters)は、指示内のシングルString文字(SingleStringCharacters)のSVにある全ての文字に続くシングルString文字(SingleStringCharacter)のCVのシーケンス(並び).
・行継続(LineContinuation)のSV :: \ 行終端シーケンス(LineTerminatorSequence) は、カラ(空／empty)文字シーケンス.
・ダブルString文字(DoubleStringCharacter)のCV :: " や \ や行終端(LineTerminator)の1つではないソース文字(SourceCharacter)は、その文字自身がソース文字(SourceCharacter).
・ダブルString文字(DoubleStringCharacter)のCV :: \ エスケープシーケンス(EscapeSequence)は、エスケープシーケンス(EscapeSequence)のCV.
・ダブルString文字(DoubleStringCharacter)のCV :: LineContinuation は、カラ(空／empty)文字シーケンス.
・シングルString文字(SingleStringCharacter)のCV :: ' や \ や行終端(LineTerminator)の1つではないソース文字(SourceCharacter)は、その文字自身がソース文字(SourceCharacter).
・シングルString文字(SingleStringCharacter)のCV :: \ エスケープシーケンス(EscapeSequence)は、エスケープシーケンス(EscapeSequence)のCV.
・シングルString文字(SingleStringCharacter)のCV :: LineContinuation は、カラ(空／empty)文字シーケンス.
・エスケープシーケンス(EscapeSequence)のCV :: 文字エスケープシーケンス(CharacterEscapeSequence)は、文字エスケープシーケンス(CharacterEscapeSequence)のCV.
・エスケープシーケンス(EscapeSequence)のCV :: 0 [lookahead ? DecimalDigit] は、 &lt;NUL&gt; 文字 (Unicode値 0000).
・エスケープシーケンス(EscapeSequence)のCV :: 16進エスケープシーケンス(HexEscapeSequence)は、 16進エスケープシーケンス(HexEscapeSequence)のCV.
・エスケープシーケンス(EscapeSequence)のCV :: Unicodeエスケープシーケンス(UnicodeEscapeSequence)は、 Unicodeエスケープシーケンス(UnicodeEscapeSequence)のCV.
・文字エスケープシーケンス(CharacterEscapeSequence)のCV :: シングルエスケープ文字(SingleEscapeCharacter)は、 Table 4と一致するシングルエスケープ文字(SingleEscapeCharacter)であるコードユニット値である文字：
</pre>
</div>

<div class="pre-div">
    <table border="1" class="pre-div">
        <tr>
            <th colspan="4">Table 4 - String 1文字エスケープシーケンス</th>
        </tr>
        <tr>
            <th>エスケープシーケンス</th>
            <th>コードユニット値</th>
            <th>名称</th>
            <th>記号</th>
        </tr>
        <tr>
            <th>\b</th>
            <th>\u0008</th>
            <td>backspace</td>
            <th>&lt;BS&gt;</th>
        </tr>
        <tr>
            <th>\t</th>
            <th>\u0009</th>
            <td>horizontal tab</td>
            <th>&lt;HT&gt;</th>
        </tr>
        <tr>
            <th>\n</th>
            <th>\u000A</th>
            <td>line feed (new line)</td>
            <th>&lt;LF&gt;</th>
        </tr>
        <tr>
            <th>\v</th>
            <th>\u000B</th>
            <td>vertical tab</td>
            <th>&lt;VT&gt;</th>
        </tr>
        <tr>
            <th>\f</th>
            <th>\u000C</th>
            <td>form feed</td>
            <th>&lt;FF&gt;</th>
        </tr>
        <tr>
            <th>\r</th>
            <th>\u000D</th>
            <td>carriage return</td>
            <th>&lt;CR&gt;</th>
        </tr>
        <tr>
            <th>\"</th>
            <th>\u0022</th>
            <td>double quote</td>
            <th>"</th>
        </tr>
        <tr>
            <th>\'</th>
            <th>\u0027</th>
            <td>single quote</td>
            <th>'</th>
        </tr>
        <tr>
            <th>\\</th>
            <th>\u005C</th>
            <td>backslash</td>
            <th>\</th>
        </tr>
    </table>
</div>

<div class="pre-div">
<pre>
・文字エスケープシーケンス(CharacterEscapeSequence)のCV ::
　非エスケープ文字(NonEscapeCharacter)は、非エスケープ文字(NonEscapeCharacter)のCV

・非エスケープ文字(NonEscapeCharacter)のCV ::
　エスケープ文字(EscapeCharacter)や行終端ではないソース文字(SourceCharacter)は、ソース文字(SourceCharacter)自体がその文字自身

・16進エスケープシーケンス(HexEscapeSequence)のCV ::
　x 16進数字 16進数字( x HexDigit HexDigit)は、
　コードユニット値が(最初の16進数字の MV 16通り) プラス 2番めの16進数字の MV である文字

・Unicodeエスケープシーケンス(UnicodeEscapeSequence)のCV ::
　u 16進数字 16進数字 16進数字 16進数字( u HexDigit HexDigit HexDigit HexDigit)は、
　コードユニット値が(最初の16進数字の MV 4,096通り) プラス (2番めの16進数字の MV 256通り) プラス (3番めの16進数字16通り) プラス 4番めの16進数字の MV である文字
</pre>
</div>

<p>
    　準拠する実装は、strictモードのコードを処理する際には、B.1.2で説明したように8進エスケープシーケンスを含む為にエスケープシーケンス(EscapeSequence)の構文を拡張しない場合があります。
</p>

<p>
    [注釈]
</p>

<p>
    　ある1つの行終端文字は、カラ文字シーケンスを生成する為の行継続の一部である場合を除き、文字列リテラル内に現れることはできません。
    文字列リテラルのString値の一部とする為の行終端文字による修正方法は、\n や \u000A のようなエスケープシーケンスを利用することです。
</p>

<h3 id="x7.8.5">7.8.5 正規表現リテラル(Regular Expression Literals)<a href="#x7.8.5">#</a></h3>

<p>
    　正規表現リテラルは、リテラルが評価されるたびにRegExpオブジェクト(15.10 参照)に変換される入力要素です。
    正規表現オブジェクトを評価するプログラム内にある2つの正規表現リテラルは、リテラルの内容が識別される場合でさえ、それぞれが === として比較されることはありません。
    RegExpオブジェクトは、新たなRegExp(15.10.4 参照)や関数(15.10.3)の場合にはRegExpコンストラクタを呼ぶことによって実行時に生成される場合もあります。
    生成される結果は、続く正規表現リテラルにおけるシンタックスを説明し、正規表現リテラルの終わりまで探す為の入力要素の走査によって使われます。
    正規表現本体(RegularExpressionBody)と正規表現フラグ(RegularExpressionFlags)を構成する複数文字の文字列は、正規表現コンストラクタとして解釈されずに渡され、独自の、より厳格な文法に従ってそれらを解釈します。
    実装は、正規表現コンストラクタの文法を拡張する場合がありますが、これらのプロダクションで使用した正規表現本体(RegularExpressionBody)と正規表現フラグ(RegularExpressionFlags)、または、そのプロダクションを拡張してはいけません。
</p>

<div class="pre-div">
<pre>
【構文】

RegularExpressionLiteral ::
/ RegularExpressionBody / RegularExpressionFlags

RegularExpressionBody ::
RegularExpressionFirstChar RegularExpressionChars

RegularExpressionChars ::
[empty] RegularExpressionChars RegularExpressionChar

RegularExpressionFirstChar ::
RegularExpressionNonTerminator but not one of * or \ or / or [ RegularExpressionBackslashSequence RegularExpressionClass

RegularExpressionChar ::
RegularExpressionNonTerminator but not one of \ or / or [ RegularExpressionBackslashSequence RegularExpressionClass

RegularExpressionBackslashSequence ::
\ RegularExpressionNonTerminator

RegularExpressionNonTerminator ::
SourceCharacter but not LineTerminator

RegularExpressionClass ::
[ RegularExpressionClassChars ]

RegularExpressionClassChars ::
[empty] RegularExpressionClassChars RegularExpressionClassChar

RegularExpressionClassChar ::
RegularExpressionNonTerminator but not one of ] or \ RegularExpressionBackslashSequence

RegularExpressionFlags ::
[empty] RegularExpressionFlags IdentifierPart
</pre>
</div>

<p>
    [注釈]
</p>

<p>
    　正規表現リテラルは、カラにならない場合もあります。
    正規表現リテラルが、カラにならない場合、カラの正規表現リテラルを表現する代わりに文字
</p>

<pre>
//
</pre>

<p>
    (スラッシュ2つ)で始まる単一行コメントを使用します。
    カラの正規表現を書くには、
</p>

<pre>
/(?:)/
</pre>

<p>
    を使用します。
</p>

<p>
    【セマンティクス】
</p>

<p>
    　正規表現リテラルは、標準組み込みコンストラクタRegExpのインスタンスであるObject型の値を評価します。
    この値は、2つの段階を経て決められます。
    まず、正規表現の正規表現本体(RegularExpressionBody)と正規表現フラグ(RegularExpressionFlags)の拡張を構成する複数文字は、それぞれ2つの文字列パターンとフラグについて解釈されずに収集されます。
    その時、そのリテラルが評価されるごとに、その名前を持つ標準組み込みコンストラクタRegExpをまるで新たなRegExp(Pattern, Flags)という式によって生成されるかのように新たなオブジェクトが生成されます。
    新たに構築されるオブジェクトは、正規表現リテラル(RegularExpressionLiteral)の値になります。
    もし、new RegExp をコールすると 15.10.4.1 に書いたようなエラーを生成する場合、そのエラーは、初期エラー(第16項)として扱われなければいけません。
</p>


</article>
<article>


<h2>7.9 自動セミコロン挿入 / Automatic Semicolon Insertion </h2>


<h3 id="x7.9">7.9 自動セミコロン挿入<a href="#x7.9">#</a></h3>

<p>
    　厳密なECMAScriptステートメント(emptyステートメント、variableステートメント、expressionステートメント、do-whileステートメント、continueステートメント、breakステートメント、returnステートメント、throwステートメント)は、セミコロンを伴った終端にしなければいけません。
    そのようなセミコロンは、常にソーステキスト内に明示的に現れる場合があります。
    利便性の為ではありますが、そのようなセミコロンが、特定の状況下ではソーステキストから省略される場合もあります。
    これらの状況は、それらの状況におけるソースコード字句(トークン)ストリームにセミコロンが自動的に挿入されると言うことによって説明されます。
</p>

<h3 id="x7.9.1">7.9.1 自動セミコロン挿入のルール／規則<a href="#x7.9.1">#</a></h3>

<p>
    　セミコロン挿入の基本ルールは3つあります。
</p>
<ol>
    <li>
        左から右に実行されるプログラムである場合、字句(対象となる字句)が、その文法から成る一部の生成結果によって受け入れられないという状況に遭遇した場合には、1つ以上の真である条件に続く対象の字句である場合、その字句の前にセミコロンが自動的に挿入されます。
    </li>
    <ul>
        <li>対象となる文字が、最低1つの行終端(LineTerminator)によって字句の前方から分割される場合</li>
        <li>対象となる文字が、 } (右波カッコ)である場合</li>
    </ul>
    <li>
        左から右に実行されるプログラムである場合、字句の入力ストリームの終わりが、単独で完了したECMAScriptプログラムのようにパーサーが入力字句ストリームを解析できないという状況に遭遇した場合には、セミコロンが、入力ストリームの終わりに自動的に挿入されます。
    </li>
    <li>
        左から右に実行されるプログラムである場合、字句は、その文法から成る一部の生成される結果によって受け入れられるという状況に遭遇したものの、その生成結果が制限付きの生成結果で、字句が、(そしてそれゆえにそのような字句は制限付き字句と呼ばれる)その制限付き生成結果内にある注釈[no
        LineTerminator
        here(ここに行終端はない)]の直後に続く終端または非終端における最初の字句であり、その制限付き字句が、少なくとも1つの行終端(LineTerminator)によって前方の字句から分割される場合には、セミコロンが制限付き字句の前に自動的に挿入されます。
    </li>
</ol>
<p>
    　しかしながら、それらは先行するルールにおける付加的な上書き条件です。
    もし、そのセミコロンが、その際にカラのステートメントとして解析されたり、そのセミコロンがステートメント(12.6.3 for 文
    参照)におけるヘッダ内にある2つのセミコロンの内の1つになる場合には、セミコロンが、自動的に挿入されることはありません。
</p>

<p>
    [注釈]
</p>

<p>
    次の内容は当該文法内で制限付き生成結果に限定されます。
</p>

<pre>
PostfixExpression :
LeftHandSideExpression [no LineTerminator here] ++
LeftHandSideExpression [no LineTerminator here] --

(
後置式 :
左側の式 [ここに行終端はない] ++
左側の式 [ここに行終端はない] --
)

ContinueStatement :
continue [no LineTerminator here] Identifier ;

(
continue 文 :
continue [ここに行終端はない] 識別子(ラベル) ;
)

BreakStatement :
break [no LineTerminator here] Identifier ;

(
break 文 :
break [ここに行終端はない] 識別子(ラベル) ;
)

ReturnStatement :
return [no LineTerminator here] Expression ;

(
return 文 :
return [ここに行終端はない] 式 ;
)

ThrowStatement :
throw [no LineTerminator here] Expression ;

(
throw 文 :
throw [ここに行終端はない] 式 ;
)
</pre>

<p>
    　これら制限付き生成結果の実用的な効果は、次のようなものです。
    ++ や -- という字句が現れる場合、パーサーは、後置演算子、つまり先行する字句と ++ や -- という字句の間に少なくとも1つの行終端(LineTerminator)が現れる場合には、 ++ や --
    という字句の前にセミコロンが自動的に挿入されてしまいます。
    continue/break/return/throwといった字句が現れ、行終端(LineTerminator)が、次の字句の前に現れる場合には、セミコロンは、continue/break/return/throwといった字句の後に自動的に挿入されてしまいます。
</p>

<p>
    　(よって)ECMAScriptプログラマへの結果的且つ実用的なアドバイスとしては、後置 ++ や -- 演算子は、そのオペランドと同一行に現れるべきです。
    returnやthrowステートメント内の式は、returnやthrow字句と同一行で始まるべきです。
    breakやcontinueステートメント内の識別子は、breakやcontinue字句と同一行にあるべきです。
</p>


<h3 id="x7.9.2">7.9.2 自動セミコロン挿入の例<a href="#x7.9.2">#</a></h3>

<p>ソース</p>
<pre>
{ 1 2 } 3
</pre>

<p>
    は、ECMAScript文法上、セミコロン自動挿入ルール上も有効な文ではありません。
</p>

<p>対照的なソース</p>
<pre>
{ 1
 2 } 3
</pre>

<p>
    もまた、有効なECMAScript文ではありませんが、自動セミコロン挿入によって次のように変換されます。
</p>

<pre>
{ 1
;2 ;} 3;
</pre>

<p>
    は、有効なECMAScript文です。
</p>

<p>ソース</p>
<pre>
for (a; b
)
</pre>

<p>
    は、有効なECMAScript文ではなく、文として構成するヘッダとしてセミコロンが必要とされる為、自動セミコロン挿入によって変更されません。
    自動セミコロン挿入は、文として構成するヘッダ内にある2つのセミコロンの内1つだけ挿入するということはありません。
</p>

<p>ソース</p>
<pre>
return
a + b
</pre>
<p>
    は、自動セミコロン挿入によって次のように変換されます。
</p>
<pre>
return;
a + b;
</pre>

<p>
    [注釈]
</p>

<p>
    　式 a + b は、行終端(LineTerminator)が字句returnからそれを分割する為、return文によって返却される値として扱われることはありません。
</p>

<p>ソース</p>
<pre>
a = b
++c
</pre>

<p>
    は、自動セミコロン挿入によって次のように変換されます。
</p>

<pre>
a = b;
++c;
</pre>

<p>
    [注釈]
</p>

<p>
    　字句 ++ は、行終端(LineTerminator)が、b と ++ 間に現れる為、変数bに適用される後置演算子としては扱われません。
</p>

<p>ソース</p>
<pre>
if (a  b)
else c = d
</pre>

<p>
    は、有効なECMAScript文ではなく、自動的に挿入したセミコロンは、その際に空文として解釈される為、その時点において適用する文法のプロダクションであったとしても他の字句の前に自動セミコロン挿入によって変更されることはありません。
</p>

<p>ソース</p>
<pre>
a = b + c
(d + e).print()
</pre>

<p>
    は、2行めから始まるカッコで括られた式が関数呼び出し(ファンクションコール)における引数リストとして解釈されることが可能である為、自動セミコロン挿入によって変換されることはありません。
</p>

<pre>
a = b + c(d + e).print()
</pre>

<p>
    　左カッコで始まらなければならない文に関連する状況では、それは自動挿入セミコロンに頼ることなく先行する文の末尾に明示的にセミコロンを置くことはプログラマとして良い考えです。
</p>


</article>
<article>


    <h2>8 タイプ・型 / Types </h2>


    <p>
        　この仕様内のアルゴリズムは、関連した型を持つ、それぞれの値を操作します。
        利用可能な値の型は、まさにこの項で定義されるものです。
        型は、もっと言えば、ECMAScript言語の型と仕様の型に分類されます。
    </p>

    <p>
        　ECMAScript言語の型は、ECMAScript言語を使うECMAScriptプログラマによって直接操作される値と一致します。
        ECMAScript言語の型は、Undefined、Null、Boolean、String、Number、Objectです。
    </p>

    <p>
        　仕様の型は、ECMAScript言語の構造とECMAScript言語の型のセマンティクスを説明するアルゴリズム内で利用されるメタデータ値(meta-values)と一致します。
        仕様の型は、Reference、List、Completion、Property Descriptor、Property Identifier、Lexical Environment、Environment
        Recordです。
        仕様型の値は、ECMAScript実装の中で記述する一部の実体(entity/エンティティ)と一致する必要のない人為的に作られた(artefacts/アーティファクト)仕様です。
        仕様型の値は、ECMAScript式の評価の中間結果を説明する為に利用される場合がありますが、そのような値は、オブジェクトのプロパティやECMAScript言語の変数の値として保持することはできません。
    </p>

    <p>
        　この仕様内では、表記法"Type(x)"は、この項で定義したECMAScript言語の型と仕様の型を参照する"型"である"xの型"における略記として使用されます。
    </p>


</article>
<article>


    <h2>8.1 Undefined型 / The Undefined Type </h2>


    <h3 id="x8.1">8.1 Undefined型<a href="#x8.1">#</a></h3>

    <p>
        　Undefined(未定義)型は、まさにUndefinedと呼ばれる1つの値を持ちます。
        ある1つの値に関連付けられていない一部の変数は、未定義の値を持ちます。
    </p>


</article>
<article>


    <h2>8.2 Null型 / The Null Type </h2>


    <h3 id="x8.2">8.2 Null型<a href="#x8.2">#</a></h3>

    <p>
        　Null型は、まさにnullと呼ばれる1つの値を持ちます。
    </p>


</article>
<article>


    <h2>8.3 Boolean型 / The Boolean Type </h2>


    <h3 id="x8.3">8.3 Boolean型<a href="#x8.3">#</a></h3>

    <p>
        　Boolean型は、trueとfalseと呼ばれる2つの値を持つ論理的な実体(論理エンティティ)を表します。
    </p>


</article>
<article>


    <h2>8.4 String型 / The String Type </h2>


    <h3 id="x8.4">8.4 String型<a href="#x8.4">#</a></h3>

    <p>
        　String(文字列)型は、その全てがゼロ以上の16ビット符号付き整数値から成る序数並びで終わる集合("elements"／エレメント・要素)です。
        String型は、コードユニット値(第6項参照)として扱われるStringの中でも各要素ごとにECMAScriptプログラム実行時にテキストのデータを表現する為に使用されるのが一般的です。
        各要素は、その並びの中である位置を占有するものとしてみなされます。
        これらの位置は非負の整数を伴って索引付け(インデックス)されます。
        (もしあれば)最初の要素は、位置が0、(もしあれば)次の要素の位置は1。。。等々といった感じです。
    </p>

    <p>
        　Stringの長さは、その中にある要素(例えば16ビット値の)数です。
        空のStringは、長さゼロであり、それゆえに要素は1つも含みません。
        Stringが実際のテキストデータを含む場合、各要素は、単独のUTF-16コードユニットとして認識されます。
        これは、Stringの実際の保存形式がどうであったとしてもString内の文字並びは、UTF-16を使って表現されたものであるかのように要素位置にそれらの初期コードユニットによって番号付けされます。
        (他の状態にある場合を除き)Strings上の全ての演算子は、未分化状態の16ビット符号なし整数としてそれらを扱います。
        それらは、結果となるStringが言語依存の結果を確保するか否かに関わらず、正規形であるということを保証しません。
    </p>

    <p>
        [注釈]
    </p>

    <p>
        　この設計の背景にある論理的根拠は、同じように単純かつ高速処理可能であるStringsの実装を保持するという事です。
        その意図は、外部からの実行環境によるテキストデータ(例えば、ユーザー入力やファイルから読み込んだテキスト、ネットワーク越しに受け取ったテキスト等々)は、実行中プログラムがそれと遭遇する前に"Unicode
        Normalised Form C"に変換されているということです。

    <p>
        [追記]
    </p>

    <div class="pre-div">
<pre style="font-size: 10pt;">
"Unicode Normalised Form C"とは、<a
        href="http://unicode.org/">Unicode</a>による[ Unicode Normalization Forms ]で定められた書式であり、<br/>[ <a
        href="http://unicode.org/reports/tr15/#Norm_Forms">http://unicode.org/reports/tr15/#Norm_Forms</a> ]<br/>内の<br/>[ <a
        href="http://unicode.org/reports/tr15/#Normalization_Forms_Table">http://unicode.org/reports/tr15/#Normalization_Forms_Table</a> ]<br/>にある下記4つの正規化の内の1つ。
------------------------------------------------------------------
Normalization Form D (NFD)	：正規の名詞
Normalization Form C (NFC)	：正規の構成に続く正規の名詞
Normalization Form KD (NFKD)	：互換性のある名詞
Normalization Form KC (NFKC)	：正規の構成に続く互換性のある名詞
------------------------------------------------------------------
</pre>

        <p>Table 1. Normalization Forms / 正規化の形式</p>
        <table class="bg_exp">
            <tbody>
            <tr>
                <th height="20" align="left">形式</th>
                <th height="20" align="left">説明</th>
            </tr>
            <tr>
                <td height="40" valign="TOP">Normalization Form&nbsp;D (NFD)</td>
                <td height="40" valign="TOP">Canonical Decomposition<br/>正規分解</td>
            </tr>
            <tr>
                <td height="59" valign="TOP">Normalization Form&nbsp;C (NFC)</td>
                <td height="59" valign="TOP">Canonical Decomposition,<br/>followed by Canonical Composition<br/>正規構成が続く正規分解
                </td>
            </tr>
            <tr>
                <td height="40" valign="TOP">Normalization Form&nbsp;KD (NFKD)</td>
                <td height="40" valign="TOP">Compatibility Decomposition<br/>互換分解</td>
            </tr>
            <tr>
                <td height="60" valign="TOP">Normalization Form&nbsp;KC (NFKC)</td>
                <td height="60" valign="TOP">Compatibility Decomposition,<br/>followed by Canonical Composition<br/>正規構成が続く互換分解
                </td>
            </tr>
            </tbody>
        </table>
    </div>

    <p>
        　通常、これは、Unicodeにその元の文字符号化方式から変換され(、追加のオーバーヘッドなく課され)ると同時に入ってくるテキストに現れます。
        ECMAScriptのソースコードが"Normalised Form
        C"の中にあることが推奨されていることから文字列リテラルは、(もし、ソーステキストが正規形であると保証される場合には、)いかなるUnicodeエスケープシーケンスをも含まないのと同じ長さに正規化されることが保証されます。
    </p>


    </p></article>
<article>


    <h2>8.5 Number型 / The Number Type </h2>


    <h3 id="x8.5">8.5 Number型<a href="#x8.5">#</a></h3>

    <p>
        　Number型は、単一の特殊な NaN 値としてECMAScript内で表現される<abbr
            title="Institute of Electrical and Electronics Engineers">IEEE</abbr>標準規格の値である"Not-a-Number"とは異なる
        9007199254740990 (2の53乗 - 2 )を除き、2進浮動小数点演算におけるIEEE標準規格で記述したように倍精度64ビットフォーマット IEEE 754 の値を表現する、まさに
        18437736874454810627 ( 2の64乗 - 2の53乗 + 3 )という値を持ちます。
        (注釈：当該 NaN 値は、プログラム式 NaN によって生成される値です。)
        同じ実装内では、外部コードが様々な Not-a-Number 値間で異なるものとして検出することができる場合もあるかもしれませんが、そのような動作は実装依存であり、(本来、)ECMAScriptコードにおいては、全ての
        NaN 値は、他のものと見分けがつかないものです。
    </p>

    <p>
        　他に正の無限大と負の無限大と呼ばれる2つの特殊な値があります。
        簡潔に言うと、それらの値は、それぞれ +∞ 、 -∞ という記号によって解説目的において参照される場合もあります。
        (注釈：これら2つの無限大Number値は、+Infinity(または単にInfinity)と-Infinityといったようにプログラム式によって生成されます。)
    </p>

    <p>
        　他方、18437736874454810624 ( 2の64乗 - 2の53乗 ) という値は、有限数値と呼ばれます。
        これらの半分は正の数値であり、半分は負の数値です。
        有限の正のNumber値においてそれは、同じ大きさを持つ負の値と一致します。
    </p>

    <p>
        　追記するとそれらは、正のゼロと負のゼロの両方があるということです。
    </p>

    <p>
        　簡潔に言えば、これらの値は、それぞれ +0 と -0 という記号によって解説目的において参照される場合もあります。
        (追記するとこれら2つの異なるゼロというNumber値は、 +0 (または単に 0 )と -0 といったようにプログラム式によって生成されます。)
    </p>

    <p>
        　18437736874454810622 ( 2の64乗 - 2の53乗 + 2 )という有限の非ゼロ値には2つの種類があります。
        それらの内、18428729675200069632 ( 2の64乗 - 2の54乗 ) は、s が +1 または -1 、m が 2の52乗以上で且つ 2の53乗より小さい正の整数、 e が -1074 から 971
        を含む範囲の整数である
    </p>

<pre>
s * m * 2e ( 2^e 2のe乗 )
</pre>

    <p>
        という書式を持っています。
    </p>

    <p>
        　残りの 9007199254740990 ( 2の53乗 - 2 )という値は、非正規形であり、s が +1 または -1 、m が 2の52乗より小さい正の整数、 e が -1074 である
    </p>

<pre>
s * m * 2e ( 2^e 2のe乗 )
</pre>

    <p>
        という書式を持っています。
    </p>

    <p>
        　追記すると大きさが2の53乗より大きいものはない全ての正と負の整数は、Number型で表現されます(他方、整数 0 は、 +0 と -0 という2つの表現を持ちます)。
    </p>

    <p>
        　有限の数は、それが、非ゼロで且つ、整数 m を(上記で示した2つの書式の対の1つの中で)それを表す為に使用した場合には、奇数の仮数を持ち、他方は、偶数の仮数を持ちます。
    </p>

    <p>
        　この仕様内では、" x における Number値"というフレーズ、つまり x は、次の方法で選択したNumber値を意味する(πのような不合理な数値になる場合でさえ)実際の数学的な量であるまさに非ゼロを表します。
        -0を取り除き、Number型で表さない、それに加算した2つの加算値、すなわち 2の1024乗 ( +1 * 2の53乗 * 2の971乗 )と -2の1024乗 ( -1 * 2の53乗 * 2の971乗
        )を伴うNumber型の有限の値全ての集合を考えてみましょう。
        xの値に最も近いこのセットのメンバーを選択しましょう。
        もし、セットの内、2つの値が等しければ、偶数の仮数を伴う一方が選択されます。
        この目的において2つの外部値 2の1024乗 と -2の1024乗 は偶数の仮数を持つことが考慮されます。
        最後にもし、2の1024乗 が選択され、+∞ を伴うそれを置換する場合、もし、-2の1024乗が選択され、-∞を伴うそれを置換する場合、もし、+0 が選択され、x がゼロより小さい場合にのみ
        -0を伴うそれを置換する場合には、他の選択値は変更されずに使われます。
        その結果は、x におけるNumber値です。
        (このプロシージャは、IEEE 754 の "近似値丸め"("round to nearest")モードの動作と正確に一致します。)
    </p>

    <p>
        　一部のECMAScript演算子は、-2の31乗から 2の31乗-1 を含む、または、0 から -2の32乗-1 を含む範囲内にある整数を伴う場合に限って扱います。
        これらの演算子は、一部のNumber型の値を許容しますが、最初は、2の32乗という整数値の1つをこのような値にそれぞれ変換します。
        9.5 と 9.6 にある ToInt32 と ToUint32 演算子の説明を参照しましょう。
    </p>


</article>
<article>


<h2>8.6 Object型 / The Object Type </h2>


<h3 id="x8.6">8.6 Object型<a href="#x8.6">#</a></h3>

<p>
    　Objectは、プロパティの集合です。
    各プロパティは、それぞれ名前付きデータプロパティ、名前付きアクセサプロパティ、内部プロパティ等です。
</p>
<ul>
    <li>名前付きデータプロパティは、ECMAScript言語の値とBoolean属性のセットを持つ名称と関連付けします。</li>
    <li>名前付きアクセサプロパティは、1つまたは2つのアクセサ関数を持つ名称とBoolean属性のセットと関連付けします。
        アクセサ関数は、プロパティと関連付けられるECMAScript言語の値を保存または検索する為に使われます。
    </li>
    <li>内部プロパティは、名称を持たず、ECMAScript言語の演算子経由で直接アクセスされることはありません。
        内部プロパティは、純粋に(単に)仕様記述目的の為に存在します。
    </li>
</ul>
<p>
    　名前付き(非内部)プロパティにおけるアクセスの種類には、get と put の2つがあり、それぞれ検索と関連付けに一致します。
</p>

<h3 id="x8.6.1">8.6.1 プロパティの属性 / Property Attributes<a href="#x8.6.1">#</a></h3>

<p>
    　属性(アトリビュート)は、名前付きプロパティの状態を定義し、説明する為にこの仕様内で使われます。
    名前付きデータプロパティは、Table 5で列挙した属性を持つ名称と関連付けます。
</p>

<div class="pre-div">
<pre>
Table 5 名前付きデータプロパティの属性
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
属性名			値領域				説明
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
[[Value]]		任意のECMAScript言語の型	値はプロパティを読むことによって取得されます。
[[Writable]]		Boolean				もし、falseなら、実行中の[[Put]]を使って当該プロパティの[[Value]]属性を変更する為にECMAScriptコードによって試行しても成功しないでしょう。
[[Enumerable]]		Boolean				もし、trueなら、プロパティは、for-in 文( 12.6.4 参照)によって評価されます。
							そうでない場合には、プロパティはnon-enumerable(列挙不可)であると言われます。
[[Configurable]]	Boolean				もし、falseなら、プロパティを削除しようとしたり、アクセサプロパティにする為にプロパティを変更したり、その([[Value]]ではない)属性を変更しようとしたりすると失敗するでしょう。
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
</pre>
</div>

<p>
    　名前付きアクセサプロパティは、Table 6で列挙した属性を持つ名称と関連付けます。
</p>

<div class="pre-div">
<pre>
Table 6 名前付きアクセサプロパティの属性
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
属性名			値領域				説明
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
[[Get]]			Object または Undefined		もし、その値が、Objectなら、それは関数Objectにしなければいけません。
							その関数の内部メソッド[[Call]]( 8.6.2 )は、そのプロパティのgetアクセスが実行されるごとに当該プロパティ値を返す為に空の引数リストを伴って呼び出されます。
[[Set]]			Object または Undefined		もし、その値が、Objectなら、それは関数Objectにしなければいけません。
							その関数の内部メソッド[[Call]]( 8.6.2 )は、そのプロパティのsetアクセスが実行されるごとに、その全ての引数として関連付けた値を含んだ引数リストを伴って呼び出されます。
							任意のプロパティの内部メソッド[[Set]]の効果は、要求はされないものの、当該プロパティの[[Get]]内部メソッドを順次呼び出すことによって返した値について効果を持ちます。
[[Enumerable]]		Boolean				もし、trueなら、そのプロパティは、 for-in文( 12.6.4 参照)によって評価されます。
							そうでない場合には、そのプロパティは、non-enumerable(列挙不可)であると言われます。
[[Configurable]]	Boolean				もし、falseなら、そのプロパティを削除しようとしたり、任意のデータプロパティにする為に当該プロパティを変更しようとしたり、その属性を変更しようとすると失敗するでしょう。
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
</pre>
</div>

<p>
    　もし、属性の値が、名前付きプロパティにおけるこの仕様によって明示的に書かれていない場合には、既定値は、Table 7 で定義したものが使用されます。
</p>

<pre>
Table 7 既定の属性値
----------------------------------
属性名			既定値
----------------------------------
[[Value]]		undefined
[[Get]]			undefined
[[Set]]			undefined
[[Writable]]		false
[[Enumerable]]		false
[[Configurable]]	false
----------------------------------
</pre>

<h3 id="x8.6.2">8.6.2 オブジェクト内部プロパティと内部メソッド<a href="#x8.6.2">#</a></h3>

<p>
    　この仕様は、オブジェクトの値のセマンティクスを定義する為に様々な内部プロパティを使います。
    これらの内部プロパティは、ECMAScript言語の一部ではありません。
    それらは、単に解説目的の為に、この仕様によって定義されているだけです。
    ECMAScriptの実装は、ここで書かれた方法の中で内部プロパティを生成、操作するかのようにふるまわなければいけません。
    内部プロパティの名称は、二重角ブラケット[[ ]]で括られます。
    アルゴリズムがオブジェクトの内部プロパティを利用し、当該オブジェクトが内部プロパティを示す実装をしない場合には、TypeErrorという例外が投げられ(スローされ)ます。
</p>

<p>
    　内部プロパティの要約である Table 8 は、全てのECMAScriptオブジェクトに適用されるこの仕様によって使われます。
    内部プロパティの要約である Table 9 は、一部のECMAScriptオブジェクトに適用される場合に限り、この仕様によって使われます。
    これらの表にある説明は、ネイティブなECMAScriptオブジェクトの特定の種類においてこの文書内で特に述べない限りは、ネイティブなECMAScriptオブジェクトにおけるこれらの動作を示します。
    ホストオブジェクトは、この文書内で述べた指定するホストオブジェクトの制約を伴う構成と同じである限り、任意の実装依存の振る舞いを伴うこれらの内部プロパティをサポートする場合があります。
</p>

<p>
    　次の表の"値の型領域 / Value Type Domain"という列は、内部プロパティ付きで関連付けた値の型を定義します。
    型名は、次に付加される名称によって第8項の中で定義した型を参照します。
    "any"は、任意のECMAScript言語の型になる場合がある値を意味します。
    "primitive"は、Undefined、Null、Boolean、String、Number(という型)を意味します。
    "SpecOp"は、内部プロパティが、内部メソッドであり、抽象操作仕様によって先行定義した実装であることを意味します。
    "SpecOp"は、パラメータ名を説明したリストによって続けられます。
    もし、パラメータ名が型名と同じである場合には、名称はパラメータの型として説明されます。
</p>

<p>
    　もし、"SpecOp"が、値を返す場合には、そのパラメータリストは、記号"→"によって返した値の型が続けられます。
</p>

<div class="pre-div">
<pre>
Table 8 全てのオブジェクトに共通する内部プロパティ
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
内部プロパティ			値の型領域／Value Type Domain					概要
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
[[Prototype]]			Object または、 Null						当該オブジェクトにおけるプロパティ
[[Class]]			String								String値が示す仕様はオブジェクトという分類で定義しました。
[[Extensible]]			Boolean								もし、trueなら、そのプロパティ自身がオブジェクトに追加される場合があります。
[[Get]]				SpecOp (propertyName) → any					名前付きプロパティの値を返します。
[[GetOwnProperty]]		SpecOp (propertyName) →Undefined or Property Descriptor	当該オブジェクトのプロパティ自体に名前を付けるプロパティ記述子(Property Descriptor)、もし、なければ未定義(undefined)を返します。
[[GetProperty]]			SpecOp (propertyName) →Undefined or Property Descriptor	当該オブジェクトの名前付きプロパティの完全形のプロパティ記述子(Property Descriptor)、もし、なければ未定義(undefined)を返します。
[[Put]]				SpecOp (propertyName, any, Boolean)				2番めのパラメータの値に記述済み名前付きプロパティを設定します。
												フラグは、エラー処理を制御します。
[[CanPut]]			SpecOp (propertyName) → Boolean				実行可能なプロパティ名(PropertyName)を伴う[[Put]]操作か否かを示すBoolean値を返します。
[[HasProperty]]			SpecOp (propertyName) → Boolean				与えられた名称のプロパティを既に持っているオブジェクトか否かを示すBoolean値を返します。
[[Delete]]			SpecOp (propertyName, Boolean) → Boolean			当該オブジェクトから記述済みの名前付きの自身のプロパティを削除します。
												フラグはエラー処理を制御します。
[[DefaultValue]]		SpecOp (Hint) → primitive					Hintは文字列です。当該オブジェクトにおける既定値を返します。
[[DefineOwnProperty]]		SpecOp (propertyName, PropertyDescriptor, Boolean) → Boolean	プロパティ記述子(Property Descriptor)によって説明した状態を持つ名前付きプロパティそれ自体を生成、または変更します。
												フラグはエラー処理を制御します。
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
</pre>
</div>

<p>
    　(ホストオブジェクトを含む)各オブジェクトは、Table 8に列挙された内部プロパティの全てを実装しなければいけません。
    しかしながら、[[DefaultValue]]内部メソッドは、一部のオブジェクトにおいては、単にTypeError例外を投げる(スローする)だけという場合もあります。
</p>

<p>
    　全てのオブジェクトは、[[Prototype]]と呼ばれる内部プロパティを持ちます。
    このプロパティの値は、nullだったり、オブジェクトだったりし、実装している継承において使用されます。
    ネイティブオブジェクトか否かに関わらず、その実装に依存する[[Prototype]]としてホストオブジェクトを持つことが可能です。
    各[[Prototype]]チェーンは、有限の長さにしなければいけません。
    (あるオブジェクトから始まるということは、最終的にはnull値に先行しなければいけない[[Prototype]]内部プロパティに再帰的にアクセスするという事です。)
    [[Prototype]]オブジェクトの名前付きデータプロパティは、putアクセスではなく、getアクセスの目的において(子オブジェクトのプロパティとして表示され、)継承されます。
    名前付きアクセサプロパティは、getアクセスとputアクセスの両方において継承されます。
</p>

<p>
    　各ECMAScriptオブジェクトは、オブジェクトに追加される場合がある名前付きプロパティか否かを操作するBoolean値である[[Extensible]]内部プロパティを持ちます。
    もし、[[Extensible]]内部プロパティの値が、falseである場合には、オプションの名前付きプロパティは、当該オブジェクトに追加されない場合があります。
    追記すると、もし、[[Extensible]]が、falseである場合には、当該オブジェクトの[[Class]]と[[Prototype]]内部プロパティの値が、修正されない場合があります。
    一度[[Extensible]]内部プロパティの値が、falseに設定されたらtrueに変更されることはないかもしれません。
</p>

<p>
    [注釈]
</p>

<p>
    　この仕様が定義するオブジェクトの[[Class]]や[[Prototype]]内部プロパティを修正する為のプログラムや、[[Extensible]]の値をfalseからtrueに変更する為のプログラムを許可するECMAScript言語の演算子や組み込み関数は、一切ありません。
    [[Class]]、[[Prototype]]、[[Extensible]]を修正する実装仕様拡張は、先行する段落内に定義した不変条件に反してはいけません。
</p>

<p>
    　[[Class]]内部プロパティの値は、組み込みオブジェクトの種類ごとにこの仕様によって定義されます。
    ホストオブジェクトの[[Class]]内部プロパティの値は、
</p>

<pre>
Arguments
Array
Boolean
Date
Error
Function
JSON
Math
Number
Object
RegExp
String
</pre>

<p>
    であるものを除く一部の文字列値になる場合があります。
    [[Class]]内部プロパティの値は、異なるオブジェクトの種類を識別する為に内部的に使用されます。
</p>

<p>
    　注釈としては、この仕様は、 Object.prototype.toString ( 15.2.4.2 参照)を通す場合を除いて値にアクセスする為のプログラムにとって意味あるものは何も提供しません。
</p>

<p>
    　特記のない限り、ネイティブなECMAScriptオブジェクトの一般的な内部メソッドは、8.12 で説明したように振る舞います。
    Array(配列)オブジェクトは、[[DefineOwnProperty]]内部メソッド( 15.4.5.1 参照)の実装と多少異なっており、Stringオブジェクトは、[[GetOwnProperty]]内部メソッド(
    15.5.5.2参照)の実装と多少異なっています。
    Argumentsオブジェクト(10.6)は、[[Get]]、[[GetOwnProperty]]、[[DefineOwnProperty]]、[[Delete]]の異なる実装を持ちます。
    Functionオブジェクト(15.3)は、[[Get]]の実装と異なります。
</p>

<p>
    　ホストオブジェクトは、他に特段の記述がない限り、任意の方法でこれら内部メソッドを実装する場合があります。
    例えば、一つの可能性としては、特定のホストオブジェクトにおける[[Get]]と[[Put]]は、まさにフェッチをし、常にfalseを生成する[[HasProperty]]ではなく、(その都度)プロパティ値を保存します。
    しかしながら、ホストオブジェクトの内部プロパティの操作を記述した場合には、実装によってサポートされず、操作は、試行した際にTypeErrorを投げなければいけません。
</p>

<p>
    　ホストオブジェクトの[[GetOwnProperty]]内部メソッドは、ホストオブジェクトのプロパティごとに続く不変式と一致しなければいけません。
</p>
<ul>
    <li>
        もし、プロパティが、データプロパティとして説明され、回を重ねるごとに異なる値を返す場合には、他の内部メソッド経由で現れた値を変更する為の仕組みがない場合でさえ[[Writable]]と[[Configurable]]属性の一方または両方をtrueにしなければいけません。
    </li>
    <li>もし、プロパティが、データプロパティとして説明され、その[[Writable]]と[[Configurable]]が両方ともfalseである場合には、（ 9.12 と一致する）SameValue
        (同じ値)は、[[GetOwnProperty]]を呼ぶ全ての場合に当該プロパティの[[Value]]属性の為に返されなければいけません。
    </li>
    <li>もし、[[Writable]]ではない属性が、毎回変更する場合や当該プロパティが現れない場合には、[[Configurable]]属性は、trueにしなければいけません。</li>
    <li>もし、[[Writable]]属性が、falseからtrueに変更する場合には、[[Configurable]]属性は、trueにしなければいけません。</li>
    <li>
        もし、ホストオブジェクトの[[Extensible]]内部プロパティの値が、ECMAScriptコードによってfalseになるように監視している場合には、何も存在しない(non-existent)ものとしてプロパティを説明する[[GetOwnProperty]]を呼ぶ場合、全ての順次呼び出しもまた何も存在しない(non-existent)ようにプロパティを記述しなければいけません。
    </li>
</ul>
<p>
    　ホストオブジェクトの[[DefineOwnProperty]]内部メソッドは、もし、そのホストオブジェクトの[[Extensible]]内部プロパティが、falseになるようにECMAScriptコードによって監視されている場合には、ホストオブジェクトに新しいプロパティを追加することを許可してはいけません。
</p>

<p>
    　もし、そのホストオブジェクトの[[Extensible]]内部プロパティが、falseになるようにECMAScriptコードによって監視されている場合には、その後trueにしていはいけません。
</p>

<div class="pre-div">
<pre>
Table 9 一部のオブジェクト定義用の内部プロパティ
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
内部プロパティ			値型領域						説明
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
[[PrimitiveValue]]		primitive						当該オブジェクトに紐づく内部状態情報。
											標準組み込みECMAScriptオブジェクトとしてBoolean、Date、Number、String オブジェクトだけが[[PrimitiveValue]]を実装。
[[Construct]]			SpecOp(a List of any) → Object				オブジェクトを生成。
											新しい演算子経由で実行。
											SpecOpへの引数は、新しい演算子の為に渡した引数。
											オブジェクトはコンストラクタと呼ばれる当該内部メソッドを実装。
[[Call]]			SpecOp(any, a List of any) → any or Reference		当該オブジェクトと紐づく実行コード。
											関数呼び出し式(ファンクションコール)経由で実行。
											SpecOpへの引数は、当該オブジェクトと関数呼び出し式の為に渡した引数を含むリスト。
											当該内部メソッドを実装するオブジェクトは呼び出し可能。
											ホストオブジェクトであるオブジェクトに限っては参照値を返す場合がある。
[[HasInstance]]			SpecOp(any) → Boolean					this オブジェクトによって構築されたObjectであるかのような引数か否かを示すBoolean値を返す。
											標準組み込みECMAScriptオブジェクトとしてFunctionオブジェクトのみ[[HasInstance]]を実装。
[[Scope]]			Lexical Environment					Functionオブジェクト内で環境を定義する語彙的な環境が実行される。
											標準組み込みECMAScriptオブジェクトとしてFunctionオブジェクトのみ[[Scope]]を実装。
[[FormalParameters]]		List of Strings						Functionの正規のパラメータリスト(FormalParameterList)であると識別する文字列を含む空の可能性もあるリスト。
											標準組み込みECMAScriptオブジェクトとしてFunctionオブジェクトのみ[[FormalParameterList]]を実装。
[[Code]]			ECMAScript code						関数のECMAScriptコード。
											標準組み込みECMAScriptオブジェクトとして唯一Functionオブジェクトのみ[[Code]]を実装。
[[TargetFunction]]		Object							標準組み込みFunction.prototype.bindメソッドを利用することによって生成した関数オブジェクトとしての対象関数。
											Function.prototype.bindを使用して生成したECMAScriptオブジェクトに限っては、[[TargetFunction]]内部プロパティを持つ。
[[BoundThis]]			any							標準組み込みFunction.prototype.bindメソッドを使って生成した関数オブジェクトの当該値を事前に関連付け(バインド)。
											Function.prototype.bindを使用して生成したECMAScriptオブジェクトに限っては、[[BoundThis]]内部プロパティを持つ。
[[BoundArguments]]		List of any						標準組み込みFunction.prototype.bindメソッドを使って生成した関数オブジェクトの引数の値を事前に関連付け(バインド)。
											Function.prototype.bindを使用して生成したECMAScriptオブジェクトに限っては、[[BoundArguments]]内部プロパティを持つ。
[[Match]]			SpecOp(String, index) → MatchResult			正規表現マッチについてテストし、MatchResult値( 15.10.2.1 参照)を返す。
											標準組み込みECMAScriptオブジェクトとしてRegExpオブジェクトのみ[[Match]]を実装。
[[ParameterMap]]		Object							引数オブジェクト( 10.6 参照)のプロパティと関連付けした関数の正規のパラメータ間におけるマッピングを提供。
											引数オブジェクトであるECMAScriptオブジェクトのみ[[ParameterMap]]内部プロパティを持つ。
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
</pre>
</div>


</article>
<article>


    <h2>8.7 リファレンス仕様型 / The Reference Specification Type </h2>


    <h3 id="x8.7">8.7 リファレンス仕様型(仕様書説明上の型)<a href="#x8.7">#</a></h3>

    <p>
        　リファレンス(参照)の型は、delete、typeof、代入(assignment)演算子( = , op= )のような演算子としての振る舞いを説明する為に使用されます。
        例えば、assignmentの左辺のオペランドは、リファレンスを生成することが期待されます。
        assignmentの動作は、代わりにassignment演算子の左辺のオペランドを構成する構文上の書式におけるケース解析という目的において全て説明されますが、ただ1つだけ困難なのは、関数呼び出しが、リファレンスを返す為に実行されることです。
        この可能性は、単にホストオブジェクトの為に認められています。
        リファレンスを返す当該仕様によって定義した非組み込みECMAScript関数とリファレンスを返す為のユーザー定義関数についての規定はありません。
        (長くて不恰好である構文上のケース解析を利用しない他の理由としては、当該仕様の多くの部分に影響を与えるからです。)
    </p>

    <p>
        　リファレンスは名称の関連付けにより解決されます。
        リファレンスは、 base (基準)値、リファレンス名、Boolean値である strict reference (厳格リファレンス)フラグという3つのコンポーネントから構成されます。
        基準値は、undefined、Object、Boolean、String、Numberか、または環境レコード(environment record ( 10.2.1 ) )の何れかです。
        undefined(未定義)という基準値は、関連付けを解決されることができないリファレンスを示します。
        リファレンス名は、文字列です。
    </p>

    <p>
        　次の抽象操作は、リファレンスを構成するコンポーネントにアクセスする為に当該仕様内で使用されます。
    </p>
    <ul>
        <li>GetBase(V)：リファレンス V の基準値のコンポーネントを返す</li>
        <li>GetReferencedName(V)：リファレンス V を参照した名称コンポーネントを返す</li>
        <li>IsStrictReference(V)：リファレンス V を参照したstrict参照コンポーネントを返す</li>
        <li>HasPrimitiveBase(V)：基準値がBoolean、String、またはNumberである場合、trueを返す</li>
        <li>IsPropertyReference(V)：基準値がオブジェクトまたはHasPrimitiveBase(V)がtrueの何れかの場合、trueを返し、そうでなければfalseを返す</li>
        <li>IsUnresolvableReference(V)：基準値がundefinedとfalse以外であればtrueを返す</li>
    </ul>
    <p>
        　次の抽象操作は、リファレンスにおける操作について当該仕様内で使用されます。
    </p>

    <h3 id="x8.7.1">8.7.1 GetValue (V)<a href="#x8.7.1">#</a></h3>

    <div class="pre-div">
<pre>
1. Type(V)がReferenceでない場合に V を返す
2. base は、GetBase(V)を呼んだ結果とする
3. IsUnresolvableReference(V)が真である場合、ReferenceError (参照エラー)例外を投げる(スローする)
4. IsPropertyReference(V)が真である場合、
	a.  HasPrimitiveBase(V)が、false である場合、get は、 base の内部メソッド[[Get]]とし、それ以外の場合、get は、以下に定義した特殊な[[Get]]内部メソッドとする
	b. その this 値として base を使用、引数にGetReferencedName(V)を渡すことによって内部メソッド get を呼んだ結果を返す
5.その他の場合には、 base は環境レコード(environment record)にしなければならない。
	a. 引数としてGetReferencedName(V) と IsStrictReference(V)を渡して base の具体的なメソッドである GetBindingValue ( 10.2.1 参照)を呼んだ結果を返す。
</pre>
    </div>

    <p>
        　次の[[Get]]内部メソッドは、 V がプリミティブ(原始的)な基準値を伴うプロパティ参照である場合にGetValueによって使用されます。
        その引数としてプロパティPを伴う、その this 値としての base を使用することで呼ばれます。
        次のステップが取られます。
    </p>

    <div class="pre-div">
<pre>
1. O は、ToObject(base)とする
2. desc は、プロパティ名 P を伴う O の内部メソッド[[GetProperty]]を呼んだ結果とする
3. desc が、undefined(未定義)である場合、undefinedを返す
4. IsDataDescriptor(desc) が、trueである場合、desc.[[Value]]を返す。
5. それ以外の場合、IsAccessorDescriptor(desc) は、trueにしなければならない為、getter(取得メソッド)は、desc.[[Get]] とする( 8.10 参照)
6. getter が、undefined(未定義)である場合、undefinedを返す
7. this 値として base を提供し、提供する引数が何もない getter の[[Call]]内部メソッドを呼んだ結果を返す
</pre>
    </div>

    <p>
        [注釈]
    </p>

    <p>
        　ステップ1で生成される可能性のあるオブジェクトは、上記メソッドの外からアクセスすることはできません。
        実装は、当該オブジェクトの実際の生成を回避する選択をする場合もあります。
        視覚的な効果を与えることが可能なこの内部メソッドを使う実際のプロパティアクセスのような限定的な状況というのは、アクセサ関数を呼び出す時です。
    </p>

    <h3 id="x8.7.2">8.7.2 PutValue (V, W)<a href="#x8.7.2">#</a></h3>

    <div class="pre-div">
<pre>
1. Type(V)がReferenceでない場合、ReferenceError(参照エラー)例外を投げる(スローする)
2. base は、GetBase(V)を呼んだ結果とする
3. IsUnresolvableReference(V)が真である場合、
	a. IsStrictReference(V) が true である場合
		i. ReferenceError(参照エラー)例外を投げる(スローする)
	b. プロパティ名として GetReferencedName(V) 、値として W 、Throwフラグとして false を渡すことによってグローバルオブジェクトとして[[Put]]内部メソッドを呼ぶ
4. IsPropertyReference(V)が真である場合、
	a. HasPrimitiveBase(V)が、falseである場合、put は、base の内部メソッド[[Put]]とし、それ以外の場合、put は、以下に定義した特殊な内部メソッド[[Put]]とする
	b. その this 値 として base を使用し、プロパティ名としてGetReferencedName(V)、値として W 、Throwフラグとして IsStrictReference(V)を渡すことによって内部メソッド put を呼ぶ
5. 何れでもない場合には、base は、基準が環境レコード(environment record)であるリファレンスにしなければならない為、
	a. GetReferencedName(V)、(値は) W 、引数としてIsStrictReference(V)を渡すことによって base の具体的なメソッドであるSetMutableBinding( 10.2.1 )を呼ぶ
6. Return
</pre>
    </div>

    <p>
        　次の[[Put]]内部メソッドは、V が、プリミティブ(原始的)な基準値を伴うプロパティのリファレンスである場合にPutValueによって使用されます。
        引数としてプロパティ P、値 W 、Booleanフラグ Throw を伴う、その this 値としての base を使って呼ばれます。
        次のステップが取られます。
    </p>

    <div class="pre-div">
<pre>
1. O は、ToObject(base)とする
2. 引数 P を伴う O の内部メソッド[[CanPut]]を呼んだ結果が、false である場合、
	a. Throwが、trueである場合、TypeError例外を投げる(スローする)
	b. それ以外の場合、return
3. ownDescは、引数 P を伴う O の内部メソッド[[GetOwnProperty]]を呼んだ結果とする
4. IsDataDescriptor(ownDesc)が、trueである場合、
	a. Throwが、trueである場合、TypeError例外を投げる(スローする)
	b. それ以外の場合、return
5. descは、引数 P を伴う O の内部メソッド[[GetOwnProperty]]を呼んだ結果とする。これは、それ自身、継承したアクセサプロパティ、または、継承したデータプロパティ記述子の何れかとなる場合があります。
6. IsAccessorDescriptor(desc)が、trueである場合、
	a. setter(設定メソッド)は、undefinedにすることができないdesc.[[Set]] ( 8.10 参照) とする
	b.  this 値として base と W のみを含んだ引数リストを提供する setter の内部メソッド[[Call]]を呼ぶ
7. それ以外の場合、一時的なオブジェクト O について自身のプロパティを生成する為に要求される
	a. Throwが、trueである場合、TypeError例外を投げる(スローする)
8. Return
</pre>
    </div>

    <p>
        [注釈]
    </p>

    <p>
        　ステップ1で生成される場合があるオブジェクトは、上記メソッドの外からアクセスすることはできません。
        実装は、一時的なオブジェクトとしての実際の生成を回避する選択をする可能性があります。
        視覚的な効果を与えることが可能なこの内部メソッドを使う実際のプロパティの関連付けのような限定的な状況というのは、アクセサ関数を呼び出す時か、または、任意のエラーチェックを含意した Throw の違反であるかの何れかです。
        Throwがtrueである場合には、一時的なオブジェクトについて新たなプロパティを生成するであろういかなるプロパティの関連付けについてもエラーを投げ(スローし)ます。
    </p>


</article>
<article>


    <h2>8.8 List仕様型 / The List Specification Type </h2>


    <h3 id="x8.8">8.8 List仕様型(仕様書説明上の型)<a href="#x8.8">#</a></h3>

    <p>
        　List型は、新たな式の中、関数呼び出しの中、必要とされる値の単純なリストにおける他のアルゴリズム内にある引数リストの評価( 11.2.4 参照)を説明する為に使用されます。
        List型の値は、単に値の序数並びです。
        これらの並びは色々な長さになることがあります。
    </p>


</article>
<article>


    <h2>8.9 Completion 仕様型 / The Completion Specification Type </h2>


    <h3 id="x8.9">8.9 Completion 仕様型(仕様書説明上の型)<a href="#x8.9">#</a></h3>

    <p>
        　Completion型は、制御における非ローカル転送を実行するステートメント／文(break、continue、return、throw)の動作を説明する為に使用されます。
        Completion型の値は、書式(type、value、target)から成る3種類で、typeは、normal、break、continue、return、throwであり、valueは一部のECMAScript言語の値または、空(カラ)、targetは、ECMAScript識別子または、空(カラ)です。
        もし、cv が完全な値である場合には、cv.type、cv.value、cv.targetは、その構成値を直接参照する為に使用される場合があります。
        "abrupt completion"(中途完了)の目的は、normal でないtypeを伴う一部のcompletionを参照することです。
    </p>


</article>
<article>


    <h2>8.10 プロパティ記述子仕様型とプロパティ識別子仕様型 / The Property Descriptor and Property Identifier Specification Types / Standard
        ECMA-262 5.1 Edition</h2>


    <h3 id="x8.10">8.10 Property Descriptor と Property Identifier仕様型(仕様書説明上の型)<a href="#x8.10">#</a></h3>

    <p>
        　Property Descriptor(プロパティ記述子)の型は、名前付きプロパティ属性の操作と具体化を説明する為に使用されます。
        Property Descriptor(プロパティ記述子)の型の値は、8.6.1 で記述したように各項目名が属性名である名前付き項目とそれと一致する属性値である当該値から成る複雑なレコードです。
        追記すると一部の項目は、存在したり、しなかったりする場合があります。
    </p>

    <p>
        　Property Descriptor(プロパティ記述子)の値は、存在や厳密な項目の利用に基づくデータプロパティ記述子とアクセサプロパティ記述子として更に分類される場合もあります。
        データプロパティ記述子は、[[Value]] や [[Writable]] 何れかの名称の任意の項目を含むものです。
        アクセサプロパティ記述子は、[[Get]] や [[Set]] の何れかの名称の任意の項目を含むものです。
        任意のプロパティ記述子は、[[Enumerable]] と [[Configurable]]という名称の項目を持ちます。
        任意のプロパティ記述子の値は、データプロパティ記述子、アクセサプロパティ記述子の何れにもしない場合もありますが、何れかにする場合もあります。
        一般的なプロパティ記述子は、データプロパティ記述子、アクセサプロパティ記述子の何れでもないプロパティ記述子の値です。
        全て実装したプロパティ記述子は、アクセサプロパティ記述子とデータプロパティ記述子の何れか一方と 8.6.1 の Table 5 や Table 6 の何れかで定義したプロパティ属性と一致する項目の全てを持ちます。
    </p>

    <p>
        　この仕様書内での表記上の利便性においてオブジェクトリテラル風の構文は、プロパティ記述子の値を定義する為に使用されることが可能です。
        例えば、プロパティ記述子
    </p>

<pre>
{[[Value]]: 42, [[Writable]]: false, [[Configurable]]: true}
</pre>

    <p>
        は、データプロパティ記述子を定義します。
        項目名の順序は重要です。
        明示的に列挙されない一部の項目は、欠如したものと考慮されます。
        仕様上のテキストとアルゴリズムにおいては、ドット記法は、プロパティ記述子を記述する項目を参照する為に使用される場合があります。
        例えば、もし、D がプロパティ記述子であれば、D.[[Value]]は、Dと名づけられた[[Value]]という項目における略記です。
    </p>

    <p>
        　プロパティ識別子の型は、プロパティ記述子を伴うプロパティ名との関連付けの為に使用されます。
        プロパティ識別子の型の値は、(name、descriptor)から成るペアで、nameは、文字列、descriptorは、プロパティ記述子の値です。
    </p>

    <p>
        　次の抽象操作(8.10.1～8.10.5)は、プロパティ記述子の値を操作する為に当該仕様内で使用されます。
    </p>

    <h3 id="x8.10.1">8.10.1 IsAccessorDescriptor ( Desc )<a href="#x8.10.1">#</a></h3>

    <p>
        　抽象操作IsAccessorDescriptorがプロパティ記述子Descを伴って呼ばれる場合には、次のような段階を踏みます。
    </p>

    <div class="pre-div">
<pre>
1.Descが未定義である場合、falseを返す
2.Desc.[[Get]] と Desc.[[Set]] が何れも存在しない場合には、falseを返す
3.trueを返す
</pre>
    </div>

    <h3 id="x8.10.2">8.10.2 IsDataDescriptor ( Desc )<a href="#x8.10.2">#</a></h3>

    <p>
        　抽象操作IsDataDescriptorがプロパティ記述子Descを伴って呼ばれる場合には、次のような段階を踏みます。
    </p>

    <div class="pre-div">
<pre>
1.Descが未定義である場合、falseを返す
2.Desc.[[Value]] と Desc.[[Writable]] が何れも存在しない場合には、falseを返す
3.trueを返す
</pre>
    </div>

    <h3 id="x8.10.3">8.10.3 IsGenericDescriptor ( Desc )<a href="#x8.10.3">#</a></h3>

    <p>
        　抽象操作IsGenericDescriptorがプロパティ記述子Descを伴って呼ばれる場合には、次のような段階を踏みます。
    </p>

    <div class="pre-div">
<pre>
1.Descが未定義である場合、falseを返す
2.IsAccessorDescriptor(Desc) と IsDataDescriptor(Desc) が何れもfalseである場合には、trueを返す
3.trueを返す
</pre>
    </div>

    <h3 id="x8.10.4">8.10.4 FromPropertyDescriptor ( Desc )<a href="#x8.10.4">#</a></h3>

    <p>
        　抽象操作FromPropertyDescriptorがプロパティ記述子Descを伴って呼ばれる場合には、次のような段階を踏みます。
    </p>

    <div class="pre-div">
<pre>
1.Descが未定義である場合、undefinedを返す
2.objは、その名を持つ標準組み込みコンストラクタであるObjectにおいて new Object() という式によるかのように生成した新たなオブジェクトを結果とする
3.IsDataDescriptor(Desc)がtrueである場合、
	a.引数"value"、プロパティ記述子 {[[Value]]: Desc.[[Value]], [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}、 falseを伴うobjの[[DefineOwnProperty]]内部メソッドを呼ぶ
	b.引数"writable"、プロパティ記述子 {[[Value]]: Desc.[[Writable]], [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}、 falseを伴うobjの[[DefineOwnProperty]]内部メソッドを呼ぶ
4.1～3の何れでもなければ、IsAccessorDescriptor(Desc)は、trueにしなければならず、よって
	a.引数"get"、プロパティ記述子 {[[Value]]: Desc.[[Get]], [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}、 falseを伴うobjの[[DefineOwnProperty]]内部メソッドを呼ぶ
	b.引数"set"、プロパティ記述子 {[[Value]]: Desc.[[Set]], [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}、 falseを伴うobjの[[DefineOwnProperty]]内部メソッドを呼ぶ
5.引数"enumerable"、プロパティ記述子 {[[Value]]: Desc.[[Enumerable]], [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}、 falseを伴うobjの[[DefineOwnProperty]]内部メソッドを呼ぶ
6.引数"configurable"、プロパティ記述子 {[[Value]]: Desc.[[Configurable]], [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}、 falseを伴うobjの[[DefineOwnProperty]]内部メソッドを呼ぶ
7.objを返す
</pre>
    </div>

    <h3 id="x8.10.5">8.10.5 ToPropertyDescriptor ( Obj )<a href="#x8.10.5">#</a></h3>

    <p>
        　抽象操作ToPropertyDescriptorがオブジェクトObjを伴って呼ばれる場合には、次のような段階を踏みます。
    </p>

    <div class="pre-div">
<pre>
1. Type(Obj) がObjectでなければ、TypeError例外を投げる(スローする)
2. desc は、生成する初期の項目を何も持たない新しいプロパティ記述子を結果とする
3.引数"enumerable"を持つObjの[[HasProperty]]内部メソッドを呼んだ結果がtrueである場合、
	a.enumは、引数"enumerable"を持つObjの[[Get]]内部メソッドを呼び、それを結果とする
	b.ToBoolean(enum)に desc の[[Enumerable]]項目を設定
4.引数"configurable"を持つObjの [[HasProperty]]内部メソッドを呼んだ結果がtrueである場合、
	a.confは、引数"configurable"を持つObjの[[Get]]内部メソッドを呼び、それを結果とする
	b.ToBoolean(conf)に desc の[[Configurable]]項目を設定
5.引数"value"を持つObjの[[HasProperty]]内部メソッドを呼んだ結果がtrueである場合、
	a.valueは、引数"value"を持つObjの[[Get]]内部メソッドを呼び、それを結果とする
	b.値に desc の[[Value]]項目を設定
6.引数"writable"を持つObjの[[HasProperty]]内部メソッドを呼んだ結果がtrueである場合、
	a.writableは、引数"writable"を持つObjの[[Get]]内部メソッドを呼び、それを結果とする
	b. desc の[[Writable]]項目にToBoolean(writable)を設定
7.引数"get"を持つObjの[[HasProperty]]内部メソッドを呼んだ結果がtrueである場合、
	a.getterは、引数"get"を持つObjの[[Get]]内部メソッドを呼び、それを結果とする
	b.IsCallable(getter)がfalseでgetterがundefinedではない場合、TypeError例外を投げる(スローする)
	c. desc の[[Get]]項目にgetterを設定
8.引数"set"を持つObjの[[HasProperty]]内部メソッドを呼んだ結果がtrueである場合、
	a.setterは、引数"set"を持つObjの[[Get]]内部メソッドを呼び、それを結果とする
	b.IsCallable(setter)がfalseでsetterがundefinedではない場合、TypeError例外を投げる(スローする)
	c.desc の[[Set]]項目にsetterを設定
9.desc.[[Get]] や desc.[[Set]]が、何れも存在する場合、
	a.desc.[[Value]] や desc.[[Writable]]が共に存在する場合には、TypeError例外を投げる(スローする)
10.descを返す
</pre>
    </div>


</article>
<article>


    <h2>Lexical Environment と Environment Record 仕様型 / The Lexical Environment and Environment Record Specification
        Types </h2>


    <h3 id="x8.11">8.11 Lexical Environment と Environment Record 仕様型(仕様書説明上の型)<a href="#x8.11">#</a></h3>

    <p>
        　Lexical Environment(語彙的環境)とEnvironment Record(環境レコード)仕様型は、ネストする関数とブロック内で名称解決の動作を説明する為に使用されます。
        これらの種類と操作は、第10項で定義される内容に基づきます。
    </p>


</article>
<article>


<h2>8.12 オブジェクトの内部メソッドにおけるアルゴリズム / Algorithms for Object Internal Methods </h2>


<h3 id="x8.12">8.12 オブジェクトの内部メソッドにおけるアルゴリズム<a href="#x8.12">#</a></h3>

<p>
    　次のアルゴリズム説明では、assume O はネイティブなECMAScriptオブジェクト、P はString、Desc はプロパティ記述子レコード、Throw は、Booleanフラグです。
</p>

<h3 id="x8.12.1">8.12.1 [[GetOwnProperty]] (P)<a href="#x8.12.1">#</a></h3>

<p>
    　O の[[GetOwnProperty]]内部メソッドが、プロパティ名 P として呼ばれる場合、次のような段階を踏みます。
</p>

<div class="pre-div">
<pre>
1. O が名称 P を持つプロパティそれ自身を持たない場合、undefined(未定義)を返す
2. D は、何も項目を持たないプロパティ記述子を新たに生成させる
3. X は、O 自身の名称 P というプロパティにする
4. X が、データプロパティである場合、
	a. X の[[Value]]属性の値に D.[[Value]] を設定
	b. X の[[Writable]]属性の値に D.[[Writable]] を設定
5.それ以外の場合、 X はアクセサプロパティなので
	a. X の[[Get]]属性の値に D.[[Get]] を設定
	b. X の[[Set]]属性の値に D.[[Set]] を設定
6. X の[[Enumerable]]属性の値に D.[[Enumerable]] を設定
7. X の[[Configurable]]属性の値に D.[[Configurable]] を設定
8. D を返す
</pre>
</div>

<p>
    　しかしながら、もし、 O がStringオブジェクトである場合、それは、15.5.5.2 で定義した、より精巧な[[GetOwnProperty]]内部メソッドを持ちます。
</p>

<h3 id="x8.12.2">8.12.2 [[GetProperty]] (P)<a href="#x8.12.2">#</a></h3>

<p>
    　O の[[GetProperty]]内部メソッドが、プロパティ名 P として呼ばれる場合、次のような段階を踏みます。
</p>

<div class="pre-div">
<pre>
1.prop は、プロパティ名が P である O の[[GetOwnProperty]]内部メソッドを呼び、それを結果とする
2.prop が、undefined(未定義)でない場合には、prop を返す
3.proto は、O の[[Prototype]]内部メソッドの値とする
4.proto が nullであれば、undefinedを返す
5.引数 P を持つ proto の[[GetProperty]]内部メソッドを呼んだ結果を返す
</pre>
</div>

<h3 id="x8.12.3">8.12.3 [[Get]] (P)<a href="#x8.12.3">#</a></h3>

<p>
    　O の[[Get]]内部メソッドが、プロパティ名 P として呼ばれる場合、次のような段階を踏みます。
</p>

<div class="pre-div">
<pre>
1.desc は、プロパティ名 P である O の[[GetProperty]]内部メソッドを呼び、それを結果とする
2.desc が、undefined(未定義)であれば、undefinedを返す
3.IsDataDescriptor(desc)が、trueであれば、desc.[[Value]]を返す
4.それ以外の場合には、IsAccessorDescriptor(desc)はtrueにしなければならない為、getterは、desc.[[Get]]とする
5.getterが、undefined(未定義)であれば、undefinedを返す
6. this 値及び引数なしであるものとして O を提供する getter の[[Call]]内部メソッドを呼んだ結果を返す
</pre>
</div>

<h3 id="x8.12.4">8.12.4 [[CanPut]] (P)<a href="#x8.12.4">#</a></h3>

<p>
    　O の[[CanPut]]内部メソッドが、プロパティ名 P として呼ばれる場合、次のような段階を踏みます。
</p>

<div class="pre-div">
<pre>
1.desc は、引数 P を伴う O の[[GetOwnProperty]]内部メソッドを呼び、それを結果とする
2.desc がundefined(未定義)でない場合には、
	a.IsAccessorDescriptor(desc)がtrueであれば
		 i.desc.[[Set]]が、undefinedであれば、falseを返す
		ii.そうでなければtrueを返す
	b.それ(a.)以外の場合には、descは、DataDescriptor(データ記述子)にしなければならない為、desc.[[Writable]]という値を返す
3.  proto は、O の[[Prototype]]内部メソッドとする
4.  proto がnullである場合、O の [[Extensible]]内部プロパティの値を返す
5. inherited は、プロパティ名 P であるprotoの[[Extensible]]内部メソッドを呼び、それを結果とする
6. inherited が、undefinedであれば、O の [[Extensible]]内部プロパティの値を返す
7.IsAccessorDescriptor(inherited) が、trueであれば、
	a.inherited.[[Set]]がundefinedであれば、falseを返す
	b.そうでなければtrueを返す
8.それ以外の場合、inheritedは、DataDescriptor(データ記述子)にしなければならない
	a. O の[[Extensible]]内部プロパティがfalseであればfalseを返す
	b.そうではない場合、inherited.[[Writable]]の値を返す
</pre>
</div>

<p>
    　ホストオブジェクトは、[[Put]]演算子に基づく付加的な制約を定義する場合があります。
    もし、可能であれば、ホストオブジェクトは、falseを返す[[CanPut]]の当該定義がある状況において[[Put]]演算子を許容すべきではありません。
</p>

<h3 id="x8.12.5">8.12.5 [[Put]] ( P, V, Throw )<a href="#x8.12.5">#</a></h3>

<p>
    　O の[[Put]]内部メソッドが、プロパティ名 P 、 値 V 、 BooleanフラグがThrowとして呼ばれる場合、次のような段階を踏みます。
</p>

<div class="pre-div">
<pre>
1.プロパティ名 P である O の[[CanPut]]内部メソッドを呼んだ結果がfalseである場合、
	a.Throwがtrueであれば、TypeError例外を投げる(スローする)
	b.そうでなければ、単にreturn
2.ownDescは、プロパティ名 P である O の[[GetOwnProperty]]内部メソッドを呼び、それを結果とする
3.IsDataDescriptor(ownDesc) が trueであれば、
	a.valueDescは、プロパティ記述子 {[[Value]]: V} とする
	b.引数である P 、 valueDesc 、Throw を渡すことによって O の[[DefineOwnProperty]]内部メソッドを呼ぶ
	c.Return
4.descは、引数 P を持つ O の[[GetProperty]]内部メソッドを呼び、それを結果とする。これは、それ自身または継承したアクセサプロパティ記述子や継承したデータプロパティ記述子の何れかになる場合がある。
5.IsAccessorDescriptor(desc) が trueである場合、
	a. setter は、undefinedにすることができないdesc.[[Set]]とする
	b. this 値として O を提供し、唯一の引数として V を提供する setter の[[Call]]内部メソッドを呼ぶ
6.何れでもない場合には、次のようなオブジェクト O について P と名付けられた名前付きデータプロパティを生成する
	a.newDescは、プロパティ記述子 {[[Value]]: V, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true} とする
	b.引数である P 、 newDesc 、Throw を渡すことによって O の[[DefineOwnProperty]]内部メソッドを呼ぶ
7.Return
</pre>
</div>

<h3 id="x8.12.6">8.12.6 [[HasProperty]] (P)<a href="#x8.12.6">#</a></h3>

<p>
    　O の[[Put]]内部メソッドが、プロパティ名 P として呼ばれる場合、 O の [[HasProperty]]内部メソッドは、次のような段階を踏みます。
</p>

<div class="pre-div">
<pre>
1.descは、プロパティ名 P である O の[[GetProperty]]内部メソッドを呼び、それを結果とする
2.descが、undefinedである場合、falseを返す
3.そうでなければtrueを返す
</pre>
</div>

<h3 id="x8.12.7">8.12.7 [[Delete]] (P, Throw)<a href="#x8.12.7">#</a></h3>

<p>
    　O の[[Delete]]内部メソッドが、プロパティ名 P 、 BooleanフラグがThrowとして呼ばれる場合、次のような段階を踏みます。
</p>

<div class="pre-div">
<pre>
1.descは、プロパティ名 PであるO の[[GetOwnProperty]]内部メソッドを呼び、それを結果とする
2.descが、undefinedである場合、trueを返す
3.desc.[[Configurable]] が trueである場合、
	a. O から 名前 P を持つプロパティそれ自身を削除する
	b.trueを返す
4.何れでもなくThrowが真である場合、TypeError例外を投げる(スローする)
5.falseを返す
</pre>
</div>

<h3 id="x8.12.8">8.12.8 [[DefaultValue]] (hint)<a href="#x8.12.8">#</a></h3>

<p>
    　O の[[DefaultValue]]内部メソッドが、hint という文字列を伴って呼ばれる場合には、次のような段階を踏みます。
</p>

<div class="pre-div">
<pre>
1.toStringは、引数"toString"を伴う オブジェクト O の[[Get]]内部メソッドを呼び、それを結果とする
2.IsCallable(toString) が trueである場合、
	a.str は、この値とカラの引数リストとして O を伴う toStringの[[Call]]内部メソッドを呼び、それを結果とする
	b.str がプリミティブ(原始的な)値である場合、strを返す
3.valueOfは、引数"valueOf"を持つオブジェクト O の[[Get]]内部メソッドを呼び、それを結果とする
4.IsCallable(valueOf) が true である場合、
	a.val は、この値とカラの引数リストとして O を持つvalueOfの[[Call]]内部メソッドを呼び、それを結果とする
	b.val が、プリミティブ(原始的な)値である場合、valを返す
5.TypeError例外を投げる(スローする)
</pre>
</div>

<p>
    　O の[[DefaultValue]]内部メソッドが、hint という数値を伴って呼ばれる場合には、次のような段階を踏みます。
</p>

<div class="pre-div">
<pre>
1.valueOfは、引数"valueOf"を持つオブジェクト O の[[Get]]内部メソッドを呼び、それを結果とする
2.IsCallable(valueOf) が trueである場合、
	a.val は、この値とカラの引数リストとして O を持つvalueOfの[[Call]]内部メソッドを呼び、それを結果とする
	b.val が、プリミティブ(原始的な)値である場合、valを返す
3.toStringは、引数"toString"を伴うオブジェクト O の[[Get]]内部メソッドを呼び、それを結果とする
4.IsCallable(toString) が trueである場合、
	a.str は、この値とカラの引数リストとして O を持つtoStringの[[Call]]内部メソッドを呼び、それを結果とする
	b.str が、プリミティブ(原始的な)値である場合、valを返す
5.TypeError例外を投げる(スローする)
</pre>
</div>

<p>
    　O の[[DefaultValue]]内部メソッドが、hint を持たずに呼ばれる場合、O が Dateオブジェクト( 15.9.6 参照)でない限り、hintが文字列であったかのように振る舞うケースについても hint
    が、数値であったものとして振る舞います。
    ネイティブなオブジェクトにおける[[DefaultValue]]の上記仕様は、プリミティブ(原始的な)値だけを返すことが可能です。
    もし、ホストオブジェクトが、それ自身の[[DefaultValue]]内部メソッドを実装する場合、それは、その[[DefaultValue]]内部メソッドがプリミティブ(原始的な)値だけを返すことができることを保証しなければいけません。
</p>

<h3 id="x8.12.9">8.12.9 [[DefineOwnProperty]] (P, Desc, Throw)<a href="#x8.12.9">#</a></h3>

<p>
    　次のアルゴリズムにある用語"Reject"は、
</p>

<p>
    「もし、Throwがtrueである場合、TypeError例外を投げ、そうでなければ、falseを返す」
</p>

<p>
    という意味です。
    そのアルゴリズムは、様々な仕様値におけるProperty Descriptor(プロパティ記述子) Desc という項目をテストするステップを含みます。
    このマナーの中でテストされる項目は、実際にDesc内に存在する必要はありません。
    もし、項目がない場合には、その値は、falseであるものとして考慮されます。
</p>

<p>
    　O の[[DefineOwnProperty]]内部メソッドが、プロパティ名 P 、プロパティ記述子 Desc、Booleanフラグ Throwとして呼ばれる場合、次のような段階を踏みます。
</p>

<div class="pre-div">
<pre>
1.current は、プロパティ名 Pである O の[[GetOwnProperty]]内部メソッドを呼び、それを結果とする
2.extensible は、O の[[Extensible]]内部プロパティの値とする
3.current がundefinedで且つ、extensibleがfalseである場合、Reject
4.current がundefinedで且つ、extensibleがtrueである場合、
	a.IsGenericDescriptor(Desc) や IsDataDescriptor(Desc) が trueである場合、
		i. Desc によって説明される[[Value]]、[[Writable]]、[[Enumerable]]、[[Configurable]]属性値を持つオブジェクト O の P というデータプロパティ自身を生成。もし、Descの属性項目の値が存在しない場合には、新たに生成したプロパティの属性がデフォルト(既定)値としてセットされる
	b.それ以外の場合、Descは、accessor Property Descriptor(アクセサプロパティ記述子)にしなければいけないので
		i. Desc によって説明される[[Get]], [[Set]], [[Enumerable]] and [[Configurable]]属性値を持つオブジェクト O という P というアクセサプロパティ自身を生成。もし、Descの属性項目の値が存在しない場合には、新たに生成したプロパティの属性が、そのデフォルト(既定)値としてセットされる
	c.trueを返す
5.Desc内の全ての項目がカラである場合、trueを返す
6.Descにある全ての項目が、SameValue アルゴリズム (9.12)を使って比較した場合にcurrentに現れたり、currentにある項目とDescにある各項目の値が一致した同じ値である場合には、trueを返す
7.currentの[[Configurable]]項目がfalseである場合、
	a.Descの[[Configurable]]項目がtrueである場合、Reject
	b.Descの[[Enumerable]]項目が存在し、currentの[[Enumerable]]項目とDescが相互に否定するBoolean型である場合、Reject
8.IsGenericDescriptor(Desc) が trueである場合、それ以上の妥当性検証は要求されることはない
9.それ以外の場合、IsDataDescriptor(current) と IsDataDescriptor(Desc)が異なる結果を持つ場合、
	a.currentの[[Configurable]]項目がfalseである場合、Reject
	b.IsDataDescriptor(current) が trueである場合、
		i.データプロパティからアクセサプロパティにオブジェクト O の P というプロパティを変換。変換したプロパティの[[Configurable]] と [[Enumerable]]属性に存在する値を保存し、残りのプロパティの属性には、それらの既定値を設定
	c.それ以外の場合、
		i.アクセサプロパティからデータプロパティにオブジェクト O の P というプロパティを変換。変換したプロパティの[[Configurable]] と [[Enumerable]]属性に存在する値を保存し、残りのプロパティの属性には、それらの既定値を設定
10.それ以外の場合でIsDataDescriptor(current) と IsDataDescriptor(Desc) が共に trueである場合、
	a.currentの[[Configurable]]項目がfalseである場合、
		i.currentの[[Writable]]項目がfalseで且つ、Descの[[Writable]]項目がtrueである場合、Reject
		ii.currentの[[Writable]]項目がfalseである場合、
			1.Descの[[Value]]項目がpresentで且つ、SameValue(Desc.[[Value]], current.[[Value]]) が falseである場合、Reject
	b.それ以外の場合、currentの[[Configurable]]項目がtrueになるので一部変更が可能となる
11.それ以外の場合、IsAccessorDescriptor(current) と IsAccessorDescriptor(Desc) が共に true となるので
	a.currentの[[Configurable]]項目がfalseである場合、
		i.Descの[[Set]]項目が存在し、SameValue(Desc.[[Set]]、current.[[Set]]) が falseである場合、Reject
		ii.Desc が presentである[[Get]]項目とSameValue(Desc.[[Get]]、 current.[[Get]])がfalseである場合、Reject
12.Desc が presentである各属性項目について、それに応じた項目の値にオブジェクト O の P というプロパティの名前付き属性を設定
13.trueを返す
</pre>
</div>

<p>
    　しかしながら、もし、 O がArrayオブジェクトである場合には、15.4.5.1 で定義した、より精巧な[[DefineOwnProperty]]内部メソッドを持ちます。
</p>

<p>
    [注釈]
</p>

<p>
    　ステップ(段階) 10.b は、currentの[[Configurable]]項目がtrueである場合、currentの一致する項目とは異なるものである一部のDescの項目を許容します。
    これは、[[Writable]]属性がfalseであるプロパティの[[Value]]の変更さえも可能にします。
    これは、trueである[[Configurable]]属性が、[[Writable]]が、初めにtrueに設定され、新たに[[Value]]が設定される際に[[Writable]]がfalseに設定される場合に呼んだシーケンスと同等であることを許可する為、許容されます。
</p>


</article>
<article>


<h2>9 型変換とテスト / Type Conversion and Testing </h2>

<h3 id="x9">9 型変換とテスト<a href="#x9">#</a></h3>

<p>
    　ECMAScriptランタイムシステムは必要都度、自動的に型変換を実行します。
    特定の構造を明確にするセマンティクスは、変換抽象操作の設定を定義するのに便利です。
    これら抽象操作は、言語の一部ではありません。
    それらは、言語のセマンティクスの仕様を補完する為にここで定義されます。
    変換抽象操作は、ポリモーフィック(多様／多形／多型)的な部分があります。
    つまり、仕様の型だけではなく、何らかのECMAScript言語の型の値をも許容することができるということです。
</p>

<h3 id="x9.1">9.1 ToPrimitive<a href="#x9.1">#</a></h3>

<p>
    　抽象操作ToPrimitiveは、引数と付加的な引数PreferredTypeをその入力として取ります。
    抽象操作ToPrimitiveは、その入力される引数を非Object型に変換します。
    もし、オブジェクトが1つ以上の原始的(プリミティブ)な型に変換することができる場合には、それは、その型を補完する付加的なヒント PreferredType を使用する場合があります。
    変換は、Table 10によって発生します。
</p>

<div class="pre-div">
<pre>
Table 10 -- ToPrimitive変換
---------------------------------------------------------------------------------------------------------------------------------------------------------
入力タイプ	結果
---------------------------------------------------------------------------------------------------------------------------------------------------------
Undefined	結果は入力となる引数と同等(変換なし)
Null		結果は入力となる引数と同等(変換なし)
Boolean		結果は入力となる引数と同等(変換なし)
Number		結果は入力となる引数と同等(変換なし)
String		結果は入力となる引数と同等(変換なし)
Object		Objectにおける既定値を返す
		オブジェクトの既定値は、付加的なヒントであるPreferredTypeを渡して当該オブジェクトの[[DefaultValue]]内部プロパティを呼ぶことによって取得
		[[DefaultValue]]内部プロパティの動作については、8.12.8.で全てのネイティブECMAScriptオブジェクトについてこの仕様によって定義される
---------------------------------------------------------------------------------------------------------------------------------------------------------
</pre>
</div>

<h3 id="x9.2">9.2 ToBoolean<a href="#x9.2">#</a></h3>

<p>
    　抽象操作ToBooleanは、Table 11 によって、その引数をBoolean型の値に変換します。
</p>

<div class="pre-div">
<pre>
Table 11 -- ToBoolean変換
------------------------------------------------------------------------------------------------------
引数の型	結果
------------------------------------------------------------------------------------------------------
Undefined	false
Null		false
Boolean		結果は入力となる引数と同等(変換なし)
Number		引数が+0、-0、NaN (Not a Number)の場合、false、それ以外の場合、その結果はtrue
String		引数が(その長さがゼロの)カラの文字列である場合、false、それ以外の場合、その結果はtrue
Object		true
------------------------------------------------------------------------------------------------------
</pre>
</div>

<h3 id="x9.3">9.3 ToNumber<a href="#x9.3">#</a></h3>

<p>
    　抽象操作ToNumberは、Table 12 によって、その引数をNumber型の値に変換します。
</p>

<div class="pre-div">
<pre>
Table 12 ToNumber変換
--------------------------------------------------------------------------------
引数の型	結果
--------------------------------------------------------------------------------
Undefined	NaN (Not a Number)
Null		+0
Boolean		引数がtrueの場合、結果は1
		引数がfalseの場合、その結果は+0
Number		結果は入力となる引数と同等(変換なし)
String		文法と以降の注釈参照
Object		次のステップで適用
		1. primValue は、ToPrimitive(input argument, hint Number) とする
		2. ToNumber(primValue)を返す
--------------------------------------------------------------------------------
</pre>
</div>

<h3 id="x9.3.1">9.3.1 String型に適用される ToNumber<a href="#x9.3.1">#</a></h3>

<p>
    　文字列(Strings)に適用したToNumberは、String型をその入力とする為に次の文法を適用します。
    文法が、StringNumericLiteralの拡張としてString型を解釈できない場合には、ToNumberの結果は、NaNになります。
</p>

<div class="pre-div">
<pre>
【構文】

StringNumericLiteral :::
	StrWhiteSpaceopt
	StrWhiteSpaceopt StrNumericLiteral StrWhiteSpaceopt

StrWhiteSpace :::
	StrWhiteSpaceChar StrWhiteSpaceopt

StrWhiteSpaceChar :::
	WhiteSpace
	LineTerminator

StrNumericLiteral :::
	StrDecimalLiteral
	HexIntegerLiteral

StrDecimalLiteral :::
	StrUnsignedDecimalLiteral
	+ StrUnsignedDecimalLiteral
	- StrUnsignedDecimalLiteral

StrUnsignedDecimalLiteral :::
	Infinity
	DecimalDigits . DecimalDigitsopt ExponentPartopt
	. DecimalDigits ExponentPartopt
	DecimalDigits ExponentPartopt

DecimalDigits :::
	DecimalDigit
	DecimalDigits DecimalDigit

DecimalDigit ::: 0 1 2 3 4 5 6 7 8 9 の何れか1つ

ExponentPart :::
	ExponentIndicator SignedInteger

ExponentIndicator :::
	e E
	の何れか

SignedInteger :::
	DecimalDigits
	+ DecimalDigits
	- DecimalDigits

HexIntegerLiteral :::
	0x HexDigit
	0X HexDigit
	HexIntegerLiteral HexDigit

HexDigit ::: 0 1 2 3 4 5 6 7 8 9 a b c d e f A B C D E F の何れか1つ
</pre>
</div>

<p>
    　一部異なるのは、StringNumericLiteral と NumericLiteral ( 7.8.3 参照)の構文の間で留意されるべきであるということです。
</p>

<ul>
    <li>StringNumericLiteral は、ホワイトスペースや行終端、または両方によって先行されたり、続いたり、または両方になる場合がある</li>
    <li>小数であるStringNumericLiteralは、先行する0の桁の数値を持つ(0埋めされる)場合がある</li>
    <li>小数であるStringNumericLiteralは、その符号を示す + や - によって先行される(符号が付く)場合がある</li>
    <li>カラまたはホワイトスペースだけを含むStringNumericLiteralは、+0に変換される</li>
</ul>
<p>
    　StringからNumberの値に変換することは、全体的には、数値リテラルにおけるNumber値の決定( 7.8.3
    参照)に似ており、一部詳細は異なるものの、String数値リテラルからNumber型への変換におけるプロセスは、ここで全て与えられます。
    この値は、2つのステップで決定されます。
    まず、数学的な値 (MV) は、文字列の数値リテラルから継承され、次にこの数学的な値は、次で説明したように丸められ(丸め処理が行われ)ます。
</p>

<div class="pre-div">
<pre>
・StringNumericLiteral の MV ::: [empty] は 0
・StringNumericLiteral の MV ::: StrWhiteSpace は 0
・StringNumericLiteral の MV ::: StrWhiteSpaceopt StrNumericLiteral StrWhiteSpaceopt は ホワイトスペースの有無に関わらず、StrNumericLiteral の MV
・StringNumericLiteral の MV ::: StrDecimalLiteral は StrDecimalLiteral の MV
・StringNumericLiteral の MV ::: HexIntegerLiteral は HexIntegerLiteral の MV
・StringNumericLiteral の MV ::: StrUnsignedDecimalLiteral は StrUnsignedDecimalLiteral の MV
・StringNumericLiteral の MV ::: + StrUnsignedDecimalLiteral は StrUnsignedDecimalLiteral の MV
・StringNumericLiteral の MV ::: - StrUnsignedDecimalLiteral は StrUnsignedDecimalLiteral の MV (注釈としては、StrUnsignedDecimalLiteralのMVが0である場合、このMVの負数もまた0。以下で説明する丸め(処理)規則は、この符号なしの数学的なゼロの適切な値として浮動小数点 +0 や -0 への変換を操作。)

* StringNumericLiteral / 文字列数値リテラル
</pre>
</div>
<div class="pre-div">
<pre>
・StrUnsignedDecimalLiteral の MV ::: Infinity(無限)は10の10000乗(値が大きすぎる為、おそらくそれは+∞に丸められる。)
・StrUnsignedDecimalLiteral の MV ::: DecimalDigits. は DecimalDigits の MV
・StrUnsignedDecimalLiteral の MV ::: DecimalDigits . DecimalDigits は、 n が2つめのDecimalDigitsにある文字数であり、(2つめのDecimalDigitsの MVは10のマイナスn乗倍)を加えた1つめのDecimalDigitsの MV
・StrUnsignedDecimalLiteral の MV ::: DecimalDigits. ExponentPart は、eがExponentPartのMVでDecimalDigits掛ける10e倍の MV
・StrUnsignedDecimalLiteral の MV ::: DecimalDigits. DecimalDigits ExponentPart は、2つめのDecimalDigitsにある文字数、eはExponentPartのMVであり、((2つめのDecimalDigits掛ける10マイナスn乗倍のMV)を加えた1つめのDecimalDigitsのMVで)10e倍
・StrUnsignedDecimalLiteral の MV ::: . DecimalDigits は、10のマイナスn乗倍のMVであり、n はDecimalDigitsにある文字数
・StrUnsignedDecimalLiteral の MV ::: . DecimalDigits ExponentPart は、10のe-n乗倍のMVであり、n は、DecimalDigitsにある文字数であり、eはExponentPartのMV
・StrUnsignedDecimalLiteral の MV ::: DecimalDigits は、DecimalDigitsのMV
・StrUnsignedDecimalLiteral の MV ::: DecimalDigits ExponentPart は、DecimalDigits掛ける10のe乗倍のMVであり、eは、ExponentPartのMV

* StrUnsignedDecimalLiteral / 文字列符号なし10進リテラル
</pre>
</div>
<div class="pre-div">
<pre>
・DecimalDigits の MV ::: DecimalDigitはDecimalDigitのMV
・DecimalDigits の MV ::: DecimalDigits DecimalDigit は、DecimalDigitのMVを加えたもの(DecimalDigits掛ける10のMV)

* DecimalDigits / 10進数・10進数値の並び
</pre>
</div>
<div class="pre-div">
<pre>
・ExponentPart の MV ::: ExponentIndicator SignedInteger は、SignedIntegerのMV

* ExponentPart / 指数部
</pre>
</div>
<div class="pre-div">
<pre>
・SignedInteger の MV  ::: DecimalDigits は、DecimalDigitsのMV
・SignedInteger の MV ::: + DecimalDigits は、DecimalDigitsのMV
・SignedInteger の MV ::: - DecimalDigits は、DecimalDigitsのMVの負の値

* SignedInteger / 符号付き整数
</pre>
</div>
<div class="pre-div">
<pre>
・DecimalDigit の MV ::: 0や16進数の0 ::: 0 は 0
・DecimalDigit の MV ::: 1や16進数の1 ::: 1 は 1
・DecimalDigit の MV ::: 2や16進数の2 ::: 2 は 2
・DecimalDigit の MV ::: 3や16進数の3 ::: 3 は 3
・DecimalDigit の MV ::: 4や16進数の4 ::: 4 は 4
・DecimalDigit の MV ::: 5や16進数の5 ::: 5 は 5
・DecimalDigit の MV ::: 6や16進数の6 ::: 6 は 6
・DecimalDigit の MV ::: 7や16進数の7 ::: 7 は 7
・DecimalDigit の MV ::: 8や16進数の8 ::: 8 は 8
・DecimalDigit の MV ::: 9や16進数の9 ::: 9 は 9
・DecimalDigit の MV ::: aや16進数のa ::: A は 10
・DecimalDigit の MV ::: bや16進数のb ::: B は 11
・DecimalDigit の MV ::: cや16進数のc ::: C は 12
・DecimalDigit の MV ::: dや16進数のd ::: D は 13
・DecimalDigit の MV ::: eや16進数のe ::: E は 14
・DecimalDigit の MV ::: fや16進数のf ::: F は 15

* DecimalDigit / 単一の10進数・10進数値
</pre>
</div>
<div class="pre-div">
<pre>
・HexIntegerLiteral の MV ::: 0x HexDigit は、HexDigitのMV
・HexIntegerLiteral の MV ::: 0x HexDigit は、HexDigitのMV
・HexIntegerLiteral の MV ::: HexIntegerLiteral HexDigit は、HexDigitのMVを加えたもの(HexIntegerLiteral掛ける16のMV)

* HexIntegerLiteral / 16進整数リテラル
</pre>
</div>

<p>
    　一度、String数値リテラルにおける正確なMVが決定されるとNumber型の値に丸められます。
    MVが0である場合、丸められた値が-0というケースにおけるString数値リテラルにある最初の非ホワイトスペース文字が'-'(マイナス)でない限り、丸められた値は+0です。
    それ以外の場合には、StrUnsignedDecimalLiteralと桁0を伴う20番め以降の有効な桁ごとに置換することによって、そしてその際に20番めの桁位置でリテラルを増分することによって生成した桁0を伴う20番め以降の有効な桁、または、リテラルのMVにおけるNumber値ごとに置換することによって生成したリテラルのMVにおけるNumber値の何れかになる場合があるNumber値というケースにおける必要な桁数が20桁以上であるリテラルでない限り、丸めた値は(8.5で定義された意味合いで)MVにおけるNumber値にしなければいけません。
    ExponentPartの一部でない場合で且つ、
</p>
<ul>
    <li>それが0ではない場合</li>
    <li>その左に非ゼロの桁があり、その右側にExponentPart内ではないところに非ゼロの桁がある場合</li>
</ul>
<p>
    には、桁は有効です。
</p>

<h3 id="x9.4">9.4 ToInteger<a href="#x9.4">#</a></h3>

<p>
    　抽象操作ToIntegerは、その引数を整数の値に変換します。
    この抽象操作は、次のように機能します。
</p>

<div class="pre-div">
<pre>
1.numberは入力となる引数についてToNumberを呼んだ結果とする
2.numberがNaNである場合には、+0を返す
3.numberが+0、-0、+∞、-∞である場合には、numberを返す
4.sign(number) * floor(abs(number)) の算出値を結果として返す
</pre>
</div>

<h3 id="x9.5">9.5 ToInt32: (符号付き 32 ビット整数)<a href="#x9.5">#</a></h3>

<p>
    　抽象操作ToInt32は、その引数を-2の31乗から2の31乗-1の範囲を含むそこにある2の32乗の1つである整数値に変換します。
    この抽象操作は、次のように機能します。
</p>

<div class="pre-div">
<pre>
1.numberは、入力となる引数についてToNumberを呼ぶことによって結果とする
2.numberがNaN、+0、-0、+∞、-∞である場合には、+0を返す
3.posIntは、sign(number) * floor(abs(number)) とする
4.int32bitは、posInt法として2の32乗とする、それは、正の符号を伴うNumber型である有限の整数値 k であり、且つ、数学的にposIntのものとは異なったり、数学的に2の32乗の複数の整数である k といったようなサイズにある2の32乗よりも小さいという意味
5.int32bitが2の31乗以上である場合には、int32bit-2の32乗を返し、そうでなければint32bitを返す
</pre>
</div>

<p>
    [注釈] ToInt32:の上記定義について追記
</p>
<ul>
    <li>ToInt32抽象操作は、冪等(idempotent)です。もし、それが生成する結果を適用する場合には、2つめのアプリケーションは変更した値を残します。</li>
    <li>ToInt32(ToUint32(x))は、 x という全ての値についてToInt32(x)することと等価です。</li>
    <li>ToInt32は、-0を+0にマップします。</li>
</ul>
<p>
    [注記]冪等(idempotent)：「べきとう」の「とう」は、「など」という意味合いではなく「等しい」ことを表し、数学的には、ある1つの数値が表す値とその数値に同じ数値を複数回、累乗・べき乗(同じ数同士の乗算)した時の結果が等しい場合、「そのべき乗した際の演算子は、冪等である」とされ、その性質や規則性を冪等性(idempotence)、冪等律(Idempotent
    law)などといい、プログラミングを含む情報工学では、転じて「同じ条件下で1回の実行によって得られた結果は、複数回実行したとしても毎回全く同じ結果を得られる」ことを表す。
</p>

<h3 id="x9.6">9.6 ToUint32: (符号なし 32 ビット整数)<a href="#x9.6">#</a></h3>

<p>
    　抽象操作ToUint32は、その引数を0から2の32乗-1までの範囲を含むその中にある2の32乗の整数値の1つに変換します。
    この抽象操作は、次のように機能します。
</p>

<div class="pre-div">
<pre>
1.numberは、入力となる引数についてToNumberを呼ぶことによって結果とする
2.numberがNaN、+0、-0、+∞、-∞である場合には、+0を返す
3.posIntは、sign(number) * floor(abs(number)) とする
4.int32bitは、posInt法として2の32乗とする、それは、正の符号を伴うNumber型の有限の整数値 k と数学的にはposIntとは異なり、数学的に2の32乗の複数の整数である k といったようなサイズにある2の32乗より小さいという意味
5.int32bitを返す
</pre>
</div>

<p>
    [注釈] ToUInt32:の上記定義について追記
</p>
<ul>
    <li>ステップ5については、唯一ToUInt32とToInt32とでは異なります。</li>
    <li>ToUint32抽象操作は、冪等(idempotent)です。もし、それが生成した結果を適用する場合には、2番めのアプリケーションは変換した値を残します。</li>
    <li>ToUint32(ToInt32(x)) は、x という全ての値についてToUint32(x)するのと等価です。(それは+0にマップされる+∞、-∞というこの最後のプロパティを保存する為にあります)</li>
    <li>ToUint32は-0を+0にマップします。</li>
</ul>

<h3 id="x9.7">9.7 ToUint16: (符号なし 16 ビット整数)<a href="#x9.7">#</a></h3>

<p>
    　抽象操作ToUint16は、その引数を0から2の16乗-1を含む範囲にある2の16乗の整数値に変換します。
    この抽象操作は、次のように機能します、
</p>

<div class="pre-div">
<pre>
1.numberは、入力となる引数についてToNumberを呼ぶことによって結果とする
2.numberがNaN、+0、-0、+∞、-∞である場合には、+0を返す
3.posIntは、sign(number) * floor(abs(number)) とする
4.int16bitはposInt法として2の16乗とする、それは正の符号を伴い、数学的にはposIntとは異なり、2の16乗の複数の整数値である k といったような大きさの中にある2の16乗よりも小さいNumber型の有限の整数値 k という意味。
5.int16bitを返す
</pre>
</div>

<p>
    [注釈] ToUint16の上記定義について追記
</p>
<ul>
    <li>ステップ4にある2の32乗が、2の16乗に置き換わっている点だけが唯一ToUint32とToUint16とでは異なります。</li>
    <li>ToUint16は-0を+0にマップします。</li>
</ul>

<h3 id="x9.8">9.8 ToString<a href="#x9.8">#</a></h3>

<p>
    　抽象操作ToStringは、その引数をTable 13によってString型の値に変換します。
</p>

<div class="pre-div">
<pre>
Table 13 -- ToString変換
--------------------------------------------------------------------------------
引数の型	結果
--------------------------------------------------------------------------------
Undefined	"undefined"
Null		"null"
Boolean		その引数が true である場合には、その結果は、 "true"
		その引数が false である場合には、その結果は、 "false"
Number		9.8.1 参照
String		入力となる引数を返す(変換なし)
Object		次のステップを適用
		1. primValueは、ToPrimitive(input argument, hint String) とする
		2. ToString(primValue) を返す
--------------------------------------------------------------------------------
</pre>
</div>

<h3 id="x9.8.1">9.8.1 Number型に適用するToString<a href="#x9.8.1">#</a></h3>

<p>
    　抽象操作ToStringは、次のようにStringの書式にNumber m を変換します。
</p>

<div class="pre-div">
<pre>
1.もし、 m が NaN である場合には、Stringの"NaN"を返す
2.もし、 m が +0 や -0 である場合には、Stringの"0"を返す
3.もし、 m が ゼロより小さい場合には、Stringの"-"とToString(-m)の結合であるStringを返す
4.もし、 m が 無限大である場合には、Stringの"Infinity"を返す
5.それ以外の場合には、n,k,sは、k≧1,10のk乗-1≦s＜10のk乗、s*10のn-k乗におけるNumber型の値であるm、また k は可能な限り小さいといったような整数にする
</pre>
</div>

<p>
    　注釈として k は、s を表示する為の少数の桁の数であり、それは10で割り切れず、sの最下位桁が、これらの条件によって一意に決まる必要はありません。
</p>

<div class="pre-div">
<pre>
6.もし、 k ≦ n ≦ 21 である場合には、(先行するゼロがない為、) s の小数表示部 k 桁から成るStringを返し、文字'0'として現れるn-kによって続く
7.もし、0 ＜ n ≦ 21 である場合には、s の小数表示の最も重要なn桁から成るStringを返し、小数点'.'によって続き、残りの s の小数表示部の k-n 桁まで続く
8.もし、-6 ＜ n ≦ 0 である場合には、文字'0'から成るStringを返し、小数点'.'によって続き、文字'0'として現れる-nによって続き、s の小数表示部の k 桁によって続く
9.それ以外の場合には、もし、 k = 1 である場合には、s の単独の桁から成るStringを返し、小文字 'e' によって続き、n-1 が正か負かにより1つのプラス記号 '+' やマイナス記号 '-' によって続き、先行するゼロのない整数 abs(n-1) の小数表示部によって続く
10. s の小数表示部の最も重要な桁から成るStringを返し、小数点 '.' によって続き、残る s の小数表示部 k-1 によって続き、小文字 'e' によって続き、n-1 が正か負かにより1つのプラス記号 '+' やマイナス記号 '-' によって続き、先行するゼロのない整数 abs(n-1) の小数表示部によって続く
</pre>
</div>

<p>
    [注釈1]
</p>

<p>
    　次の観測は、実装におけるガイドラインとして便利になる場合もありますが、この標準規格の正規の要件の一部ではありません。
</p>
<ul>
    <li>もし、 x が -0 ではないNumber型の何らかの値で在る場合には、ToNumber(ToString(x)) は、xと全く同じNumber値です。</li>
    <li>sの最下位桁は、ステップ5で挙げた要件によって常に一意に決まる訳ではありません。</li>
</ul>
<p>
    [注釈2]
</p>

<p>
    　上記ルールによって要求される以上により正確な変換を提供する実装においては、ステップ5の次の代替バージョンをガイドラインとして使うことが推奨されます。
    それ以外の場合には、n,k,sは、k ≧ 1、10のk-1乗 ≦ s ＜ 10のk乗、 s * 10のn-k乗 におけるNumber型の値が m であり、 k は可能な限り小さくなります。
    もし、s について複数の可能性がある場合、mにおける値の中で最も近い値である s * 10のn-k乗 におけるsの値を選択します。
    もし、s の値としてそのような可能性が2つある場合には、偶数の方を選択します。
    付記として s の小数表示部にある桁の数 k と そのs自体は、10で割り切れません。
</p>

<p>
    [注釈3]
</p>

<p>
    　ECMAScriptの実装は、David M 氏によって書かれた有用な紙面とコードが見つかる場合があります。
</p>

<div class="pre-div">
<pre>
『Gay for binary-to-decimal conversion of floating-point numbers (浮動小数点数のバイナリから小数への変換における華) / Gay, David M.』
『Correctly Rounded Binary-Decimal and Decimal-Binary Conversions (正しい丸め処理のBinary-DecimalとDecimal-Binary変換)』
『Numerical Analysis, Manuscript 90-10 (数値解析、原稿90-10) 』

AT&amp;T Bell Laboratories／AT&amp;Tベル研究所 (Murray Hill, New Jersey)
1990年11月30日
http://cm.bell-labs.com/cm/cs/doc/90/4-10.ps.gz. のようにすれば利用可能です。
http://cm.bell-labs.com/netlib/fp/dtoa.c.gz と http://cm.bell-labs.com/netlib/fp/g_fmt.c.gz のようにすれば利用可能な関連コードは様々なnetlibミラーサイトで見つけることも可能です。
</pre>
</div>

<h3 id="x9.9">9.9 ToObject<a href="#x9.9">#</a></h3>

<p>
    　抽象操作ToObjectは、その引数をTable 14によってObject型の値に変換します。
</p>

<div class="pre-div">
<pre>
Table 14 -- ToObject
-------------------------------------------------------------------------------------------------------------
引数の型	結果
-------------------------------------------------------------------------------------------------------------
Undefined	TypeError例外を投げる(スローする)
Null		TypeError例外を投げる(スローする)
Boolean		[[PrimitiveValue]]内部プロパティが引数の値に設定される新たなBooleanオブジェクトを生成。Booleanオブジェクトの概要については15.6参照。
Number		[[PrimitiveValue]]内部プロパティが引数の値に設定される新たなNumberオブジェクトを生成。Numberオブジェクトの概要については15.7参照。
String		[[PrimitiveValue]]内部プロパティが引数の値に設定される新たなStringオブジェクトを生成。Stringオブジェクトの概要については15.5参照。
Object		結果は入力となる引数(変換なし)
-------------------------------------------------------------------------------------------------------------
</pre>
</div>

<h3 id="x9.10">9.10 CheckObjectCoercible<a href="#x9.10">#</a></h3>

<p>
    　抽象操作CheckObjectCoercibleは、その引数が、ToObjectを利用してObjectに変換されることができない値である場合、エラーを投げます。
    これについてはTable 15によって定義されます。
</p>

<div class="pre-div">
<pre>
Table 15 -- CheckObjectCoercible の結果
---------------------------------------------------
引数の型	結果
---------------------------------------------------
Undefined	TypeError例外を投げる(スローする)
Null		TypeError例外を投げる(スローする)
Boolean		リターン
Number		リターン
String		リターン
Object		リターン
---------------------------------------------------
</pre>
</div>

<h3 id="x9.11">9.11 IsCallable<a href="#x9.11">#</a></h3>

<p>
    　抽象操作IsCallableは、その引数がTable 16による関数のObjectを呼ぶことになるECMAScript言語の値にしなければいけない場合に決定されます。
</p>

<div class="pre-div">
<pre>
Table 16 -- IsCallable の結果
-------------------------------------------------------------------------------------------------------------
引数の型	結果
-------------------------------------------------------------------------------------------------------------
Undefined	falseを返す
Null		falseを返す
Boolean		falseを返す
Number		falseを返す
String		falseを返す
Object		引数が[[Call]]内部メソッドを持つ場合にはtrue、そうでない場合にはfalseを返す
-------------------------------------------------------------------------------------------------------------
</pre>
</div>

<h3 id="x9.12">9.12 SameValue のアルゴリズム<a href="#x9.12">#</a></h3>

<p>
    　ECMAScript言語の値である x と y である場合の内部比較抽象操作SameValue(x, y)は、trueまたはfalseを生成します。
    このような比較は次のように実行されます。
</p>

<div class="pre-div">
<pre>
1.Type(x)がType(y)と異なる場合、falseを返す
2.Type(x)がUndefinedである場合、trueを返す
3.Type(x)がNullである場合、trueを返す
4.Type(x)がNumberである場合、
	a. x が NaN かつ y が NaNである場合、trueを返す
	b. x が +0 かつ y が -0である場合、falseを返す
	c. x が -0 かつ y が +0である場合、falseを返す
	d. x が y と同じNumber型の値である場合、trueを返す
	e.(何れでもない場合)falseを返す
5.Type(x)がString型である場合、x と y の文字並びが全く同じ(一致する位置において同じ長さで同じ文字)であればtrueを返し、それ以外は、falseを返す
6.Type(x)がBooleanである場合、x と y が共にtrueまたはfalseであればtrueを返し、それ以外は、falseを返す
7.x と y が同じオブジェクトを参照する場合、trueを返す。それ以外はfalseを返す。
</pre>
</div>


</article>
<article>


    <h2>10 実行コードと実行コンテキスト / Executable Code and Execution Contexts </h2>


    <p><a href="http://www.webzoit.net/hp/it/internet/homepage/script/ecmascript/ecma262_51/contents/10/10_1/"
          title="実行コードの型・種類">10.1
        実行コードの型・種類</a></p>

    <p><a href="http://www.webzoit.net/hp/it/internet/homepage/script/ecmascript/ecma262_51/contents/10/10_2/"
          title="語彙の環境">10.2 語彙の環境</a>
    </p>

    <p><a href="http://www.webzoit.net/hp/it/internet/homepage/script/ecmascript/ecma262_51/contents/10/10_3/"
          title="実行コンテキスト">10.3
        実行コンテキスト</a></p>

    <p><a href="http://www.webzoit.net/hp/it/internet/homepage/script/ecmascript/ecma262_51/contents/10/10_4/"
          title="生成中の実行コンテキスト">10.4
        生成中の実行コンテキスト</a></p>

    <p><a href="http://www.webzoit.net/hp/it/internet/homepage/script/ecmascript/ecma262_51/contents/10/10_5/"
          title="宣言型バインディングのインスタンス化">10.5
        宣言型バインディングのインスタンス化</a></p>

    <p><a href="http://www.webzoit.net/hp/it/internet/homepage/script/ecmascript/ecma262_51/contents/10/10_6/"
          title="引数オブジェクト">10.6
        引数オブジェクト</a></p>


</article>
<article>


    <h2>10.1 実行コードの種類 / Types of Executable Code </h2>


    <h3 id="x10.1">10.1 実行コードの型・種類<a href="#x10.1">#</a></h3>

    <p>
        　ECMAScriptの実行コードの種類には、3つあります(Global コード / Eval コード / Function コード)。
    </p>
    <ul>
        <li>Global
            コードは、ECMAScriptのProgramとして扱われるソーステキストです。固有のProgramのグローバルなコードは、FunctionBody(関数本体)の一部として解釈される一部のソーステキストを含みません。
        </li>
        <li>Eval コードは、組み込み eval 関数に提供されるソーステキストです。より正確には、組み込み eval 関数へのパラメータがString型である場合、ECMAScriptのProgramとして扱われます。特定の
            eval の呼び出しにおける evalのコードは、Programのグローバルコード部分です。
        </li>
        <li>Function
            コードは、FunctionBody(関数本体)の一部として解釈されるソーステキストです。特定のFunctionBodyの関数のコードは、ネストしたFunctionBodyの一部として解釈される一部のソーステキストを含みません。FunctionBodyの関数のコードは、コンストラクタとして組み込み
            Function
            オブジェクトを利用する場合に提供されるソーステキストであることをも意味します。より正確には、Functionコンストラクタに提供される最後のパラメータは、String型に変換され、FunctionBodyとして扱われます。Functionコンストラクタに提供されるパラメータが1つ以上ある場合には、最後の1つを除く全てのパラメータは、Strings型に変換、結合され、カンマで区切られます。結果となるString型は、最後のパラメータによって定義したFunctionBodyにおけるFormalParameterListとして解釈されます。Functionの特定のインスタンス化における関数のコードは、FunctionBodyの一部として解釈される一部のソーステキストを含みません。
        </li>
    </ul>

    <h3 id="x10.1.1">10.1.1 Strictモードのコード<a href="#x10.1.1">#</a></h3>

    <p>
        　ECMAScriptプログラムの構文上の単位は、無制限またはstrict(厳格)モードの構文とセマンティックに使用されて処理される場合があります。
        ECMAScriptコードの3つのタイプが、strict(厳格)モードを使って処理される場合には、strict global(厳格なグローバル)コード、strict eval(厳格な評価)コード、strict
        function(厳格な関数)コードとして参照されます。
    </p>

    <p>
        　コードは、次の状況においてはstrict(厳格)モードのコードとして解釈されます。
    </p>
    <ul>
        <li>Globalコードは、Use Strict Directive ( 14.1 参照)を含むDirective Prologueで始まる場合には、strict(厳格)グローバルコードです。</li>
        <li>Evalコードは、Use Strict 指定 を含む Directive Prologue で始まる場合やevalの呼び出しがstrict(厳格)モードのコード内に含まれる eval 関数への直接呼び出し(
            15.1.2.1.1 参照)である場合、strict(厳格)evalコードです。
        </li>
        <li>
            FunctionDeclaration(関数宣言)、FunctionExpression(関数の式)やアクセサPropertyAssignment(プロパティの関連付け)の一部であるFunctionコードは、そのFunctionDeclaration、FunctionExpressionやPropertyAssignmentがstrict(厳格)モードのコードに含まれる場合や関数のコードが、
            Use Strict Directive を含む Directive Prologue で始まる場合、strict(厳格)関数コードです。
        </li>
        <li>組み込みFunctionコンストラクタへの最後の引数として提供される関数のコードは、その最後の引数がString型であり、Use Strict Directiveを含むDirective
            Prologueで始まるFunctionBody(関数本体)として処理される場合、strict(厳格)関数のコードです。
        </li>
    </ul>

<pre>
[注：] Use Strict Directive と Directive Prologue

Use Strict Directive
Use Strict ディレクティブ(指定・指示・命令)

'use strict'
"use strict"

によるstrict モードの指定

Directive Prologue
指定(指示・命令)プロローグ(序章・前置)
前置指定
</pre>


</article>
<article>


<h2>10.2 語彙環境 / Lexical Environment </h2>


<h3 id="x10.2">10.2 語彙環境 / Lexical Environment<a href="#x10.2">#</a></h3>

<p>
    　語彙環境(Lexical
    Environment)とは、固有の変数におけるIdentifiers(識別子)との関連付けを定義する為に使用される仕様上の種類であり、関数は、語彙的にネストしたECMAScriptコードの構造に基づきます。
    語彙環境は、環境レコード(Environment Record)とnullである可能性もある外部の語彙的な環境への参照から成ります。
    通常、語彙環境は、FunctionDeclaration (関数宣言)、WithStatement (With 文)、TryStatement (Try
    文)のCatch句、または、そのようなコードが評価されるごとに生成される新たな語彙環境のようなECMAScriptのコードの同一の特定の構文上で関連付けされます。
</p>

<p>
    　環境レコードは、関連付けた語彙環境のスコープ内で生成される関連付けした識別子を記録します。
</p>

<p>
    　外部環境の参照は、語彙環境の値から成る論理的なネストを形成する為に使用されます。
    (内部の)語彙環境の外部参照は、内部の語彙環境を論理的に括る語彙環境を参照します。
    外部の語彙環境は、当然ながら、外部の語彙環境それ自身を持ちます。
    語彙環境は、複数の内部の語彙環境における外部の環境として提供される場合があります。
    例えば、FunctionDeclarationが2つのネストしたFunctionDeclarationsを含む場合、ネストした2つの関数ごとの語彙環境は、囲まれた関数について現在実行中の語彙環境を外部の語彙環境として持ちます。
</p>

<p>
    　語彙環境と環境レコードの値は、単に仕様上の仕組みであり、ECMAScriptの実装における人為的な一部仕様と一致する必要はありません。
    それは、ECMAScriptのプログラムにおいて、そのような値に直接アクセスしたり、直接、値を操作することを可能にします。
</p>

<h3 id="x10.2.1">10.2.1 環境レコード / Environment Record<a href="#x10.2.1">#</a></h3>

<p>
    　宣言型環境レコードとオブジェクト型環境レコードという種類が2つある環境レコードの値は、この仕様の中で使用されます。
    宣言型環境レコードは、ECMAScript言語の値と直接関連付ける識別子バインディングであるFunctionDeclarations、VariableDeclarationsとCatch句のようなECMAScript言語の構文上の要素の効果を定義する為に使用されます。
    オブジェクト型環境レコードは、一部のオブジェクトのプロパティを伴う識別子バインディングとの関連付けである Program と WithStatement のようなECMAScriptの要素の効果を定義する為に使用されます。
</p>

<p>
    　仕様目的における環境レコードの値は、宣言型環境レコードとオブジェクト型環境レコードという具体的な2つのサブクラスを伴う抽象クラスである環境レコードにおけるオブジェクト指向的な階層内に存在するかのように考えることができます。
    抽象クラスは、Table 17で定義した抽象仕様メソッドを含みます。
</p>

<p>
    　これらの抽象メソッドは、具体的なサブクラスごとの明らかに異なる具体的なアルゴリズムを持ちます。
</p>

<div class="pre-div">
<pre>
Table 17 -- 環境レコードの抽象メソッド
-------------------------------------------------------------------------------------------------------------
メソッド			目的
-------------------------------------------------------------------------------------------------------------
HasBinding(N)			環境レコードが識別子におけるバインディングを持つ場合に決定
				持てばtrue、持たなければfalse
				String型の値 N は、識別子のテキスト
CreateMutableBinding(N, D)	環境レコード内に新たに変更可能なバインディングを生成
				String型の値 N は、バインドされた名前としてのテキスト
				オプションのBoolean型引数 D が、trueである場合には、バインディングは順次削除される可能性がある
SetMutableBinding(N, V, S)	環境レコード内に既に存在する変更可能なバインディングの値を設定
				String型の値 N は、バインドされた名前としてのテキスト
				 V は、バインディングにおける値であり、一部のECMAScript言語の型の値になる場合がある
				 S は、Booleanフラグ
				 S が、true で且つバインディングが設定できない場合には、TypeError例外を投げる(スローする)
				 S は、strict(厳格)モード参照を識別する為に使用される
GetBindingValue(N,S)		環境レコードから既存のバインディングの値を返す
				String型の値 N は、バインドされた名前としてのテキスト
				 S は、strict(厳格)モード参照を識別する為に使用される
				 S が、trueで且つバインディングするものが存在しない場合や初期化されていない場合には、ReferenceError例外を投げる(スローする)
DeleteBinding(N)		環境レコードからバインディングを削除
				String型の値 N は、バインドされた名前としてのテキスト
				既存の N におけるバインディングが存在する場合には、そのバインディングを削除し、true を返す
				バインディングは存在するが削除できない場合には、false を返す
				バインディングが存在しない場合には、true を返す
ImplicitThisValue()		当該環境レコードから値をバインディングする値を関数オブジェクトを呼ぶことによって取得される当該値と同様に使用する為の値を返す
-------------------------------------------------------------------------------------------------------------
</pre>
</div>

<h3 id="x10.2.1.1">10.2.1.1 宣言型環境レコード／Declarative Environment Records<a href="#x10.2.1.1">#</a></h3>

<p>
    　各宣言型環境レコードは、変数と(や)関数宣言を含むECMAScriptプログラムにおけるスコープと関連付けられます。
    宣言型環境レコードは、そのスコープ内に含まれる宣言によって定義した識別子の集合をバインドします(関連付けます)。
</p>

<p>
    　追記すると変更可能なバインディングは、全ての環境レコードによってサポートされ、宣言型環境レコードはまた恒久的なバインディングについても提供します。
    恒久的なバインディングとは、識別子と生成されてすぐに変更されない値との間を関連付けることもその1つです。
    恒久的なバインディングの生成と初期化は、初期化された、または初期化されていない状態の何れにも存在する為、このように関連付けて利用することが可能なので、そのステップは異なります。
</p>

<p>
    　宣言型環境レコードは、環境レコード抽象仕様メソッドにおける付記にある Table 18 の中で列挙したメソッドをサポートします。
</p>

<div class="pre-div">
<pre>
Table 18 -- 宣言型環境レコードの追加のメソッド
-------------------------------------------------------------------------------------------------------------
メソッド				目的
-------------------------------------------------------------------------------------------------------------
CreateImmutableBinding(N)		新たに生成するが、初期化されず、環境レコード内で恒久的に関連付ける
					String型の値 N は、バインドされた名前としてのテキスト
InitializeImmutableBinding(N,V)		既存の値を設定するが、初期化されず、環境レコード内で恒久的に関連付ける
					String型の値 N は、バインドされた名前としてのテキスト
					 V は、バインディングにおける値であり、一部のECMAScript言語の型の値
-------------------------------------------------------------------------------------------------------------
</pre>
</div>

<p>
    　宣言型環境レコードにおける具体的な仕様メソッドの動作は、次のアルゴリズムによって定義されます。
</p>

<h3 id="x10.2.1.1.1">10.2.1.1.1 HasBinding(N)<a href="#x10.2.1.1.1">#</a></h3>

<p>
    　宣言型環境レコードにおける具体的な環境レコードメソッドHasBindingは、単に引数の識別子が、レコードによってバインドされる識別子の1つである場合に決められます。
</p>

<div class="pre-div">
<pre>
1.envRecは、メソッドが実行された場合に宣言型環境レコードとする
2.envRecが N という値の 名称によるバインディング(結びつき)を持つ場合には、true を返す
3.そのようなバインディングを持たない場合には、falseを返す
</pre>
</div>

<h3 id="x10.2.1.1.2">10.2.1.1.2 CreateMutableBinding (N, D)<a href="#x10.2.1.1.2">#</a></h3>

<p>
    　宣言型環境レコードにおける具体的な環境レコードのメソッドCreateMutableBindingは、新たに値undefinedに初期化される名称 N という変更可能なバインディングを生成します。
    バインディングは、既存の N という環境レコードがあってはいけません。
    Boolean型の引数 D が提供され、値が true である場合には、新たなバインディングは、削除の対象としてマークされます。
</p>

<div class="pre-div">
<pre>
1.envRecは実行されたメソッドにおける宣言型環境レコードとする
2.Assert:envRecは、N という 既存のバインディングを持たない
3. N において envRec 内に変更可能なバインディングを生成し、そのバインド値としてundefinedを設定
   D がtrueであり、新たに生成したバインディングであるレコードである場合には、順次DeleteBindingを呼ぶことによって削除される場合がある
</pre>
</div>

<h3 id="x10.2.1.1.3">10.2.1.1.3 SetMutableBinding (N,V,S)<a href="#x10.2.1.1.3">#</a></h3>

<p>
    　宣言型環境レコードにおける具体的な環境レコードのメソッドSetMutableBindingは、引数 V の値について引数 N という値である名前を持つ識別子としての現在のバインディングのバインド値の変更を試行します。
    N というバインディングは既に存在しなければいけません。
    バインディングが恒久的なバインディングである場合には、 S が true である場合、TypeErrorが投げられ(スローされ)ます。
</p>

<div class="pre-div">
<pre>
1.envRecは、実行される当該メソッドにおける宣言型環境レコードとする
2.Assert:envRecは N というバインディングを持たなければならない
3.envRecにある N というバインディングが変更可能なバインディングである場合には、そのバインド値を V に変更する
4.それ以外の場合、S が true である場合、TypeError例外を投げる(スローする)為、恒久的なバインディングの値への変更を試行しなければならない
</pre>
</div>

<h3 id="x10.2.1.1.4">10.2.1.1.4 GetBindingValue(N,S)<a href="#x10.2.1.1.4">#</a></h3>

<p>
    　宣言型環境レコードにおける具体的な環境レコードのメソッドGetBindingValueは、単に引数 N の値である名称を持つ当該バインド識別子の値を返します。
    当該バインディングは既に存在しなければいけません。
    S が true で且つ当該バインディングが初期化されていない場合、恒久的なバインディングは、ReferenceError例外を投げます。
</p>

<div class="pre-div">
<pre>
1.envRecは、実行されたメソッドにおける宣言型環境レコードとする
2.Assert: envRecは、N というバインディングを持つ
3.envRec内の N というバインディングが、恒久的なバインディングとして初期化されていない場合、
	a. S がfalseである場合、値undefinedを返し、それ以外はReferenceError例外を投げる(スローする)
4.それ以外は、envRec内の N への値currently bound(現在のバインド値)を返す
</pre>
</div>

<h3 id="x10.2.1.1.5">10.2.1.1.5 DeleteBinding (N)<a href="#x10.2.1.1.5">#</a></h3>

<p>
    　宣言型環境レコードにおける具体的な環境レコードのメソッドDeleteBindingは、削除の対象として明示的に指定されているバインディングだけを削除することが可能です。
</p>

<div class="pre-div">
<pre>
1.envRecは、実行されたメソッドにおける宣言型環境レコードとする
2.envRecがNという値の名称におけるバインディングを持たない場合、trueを返す
3.envRec内にあるNというバインディングは削除不可であり、falseを返す
4.envRecからNというバインディングを削除
5.trueを返す
</pre>
</div>

<h3 id="x10.2.1.1.6">10.2.1.1.6 ImplicitThisValue()<a href="#x10.2.1.1.6">#</a></h3>

<p>
    　宣言型環境レコードは常にそれらのImplicitThisValueとしてundefinedを返します。
</p>

<div class="pre-div">
<pre>
1.undefinedを返す
</pre>
</div>

<h3 id="x10.2.1.1.7">10.2.1.1.7 CreateImmutableBinding (N)<a href="#x10.2.1.1.7">#</a></h3>

<p>
    　宣言型環境レコードにおける具体的な環境レコードのメソッドCreateImmutableBindingは、値undefinedに初期化される名称 N という新しい恒久的なバインディングを生成します。
    バインディングは、Nという環境レコード内に事前に存在してはいけません。
</p>

<div class="pre-div">
<pre>
1.envRecは、実行されたメソッドにおける宣言型環境レコードとする
2.Assert:envRecは、まだNというバインディングを持たない
3.NというenvRec内に恒久的なバインディングを生成、レコードは初期化されない
</pre>
</div>

<h3 id="x10.2.1.1.8">10.2.1.1.8 InitializeImmutableBinding (N,V)<a href="#x10.2.1.1.8">#</a></h3>

<p>
    　宣言型環境レコードにおける具体的な環境レコードのメソッドInitializeImmutableBindingは、引数 N という値から引数 V
    という値までの値である名称を持つ識別子の現在のバインディングのバインド値を設定する為に使用されます。
    N における初期化されない恒久的なバインディングは既に存在していなければいけません。
</p>

<div class="pre-div">
<pre>
1.envRecは実行されたメソッドにおける宣言型環境レコードとする
2.Assert:envRecは、初期化されない N という恒久的なバインディングを持たなければならない
3. V に envRec内の N　というバインド値を設定
4. envRec内の N という恒久的なバインディングであるレコードは、初期化されている
</pre>
</div>

<h3 id="x10.2.1.2">10.2.1.2 オブジェクト型環境レコード / Object Environment Records<a href="#x10.2.1.2">#</a></h3>

<p>
    　各オブジェクト型環境レコードは、当該バインディング(結合)オブジェクトを呼ぶオブジェクトと関連付けされます。
    オブジェクト型環境レコードは、当該バインディングオブジェクトの一致するプロパティ名をそのまま識別子名として設定します。
    IdentifierNameではないプロパティ名は、バインド識別子の集合内には含まれません。
    それ自身と継承したプロパティは共に、それらの[[Enumerable]]属性の設定に関わらず集合内に含まれます。
    なぜならプロパティは、動的に追加されたり、オブジェクトから削除されたりすることが可能だからであり、オブジェクト型環境レコードによる識別子バインドの集合は、プロパティの追加または削除といった一部操作の副作用として潜在的に変更する場合があります。
    このように副作用の結果として生成される一部のバインディングは、対応する値を持つプロパティのWritable属性が、falseである場合でさえ変更可能なバインディングになることが考えられます。
    恒久的なバインディングは、オブジェクト型環境レコードにおいては存在しません。
</p>

<p>
    　オブジェクト型環境レコードは、関数呼び出しで使う為に暗黙のthis値としてそれらのバインディングオブジェクトを提供するように構成することができます。
    この機能は、バインディングを誘発するWithステートメント(12.10)の動作を指定する為に使用されます。
    その機能は、各オブジェクト型環境レコードごとに関連付けられるBoolean値provideThisによって操作されます。
    既定では、provideThisの値は、いかなるオブジェクト型環境レコードにおいてもfalseです。
</p>

<p>
    　オブジェクト型環境レコードにおける具体的な仕様上のメソッドの動作は、次のアルゴリズムによって定義されます。
</p>

<h3 id="x10.2.1.2.1">10.2.1.2.1 HasBinding(N)<a href="#x10.2.1.2.1">#</a></h3>

<p>
    　オブジェクト型環境レコードにおける具体的な環境レコードのメソッドHasBindingは、その関連付けたバインディングオブジェクトが引数 N という値である名称のプロパティを持つ場合に決まります。
</p>

<div class="pre-div">
<pre>
1.envRecは、実行されたメソッドにおけるオブジェクト型環境レコードとする
2.bindingsは、envRecにおけるバインディングオブジェクトとする
3.プロパティ名として N を渡すことによってバインディングの[[HasProperty]]内部メソッドを呼ぶことで結果を返す
</pre>
</div>

<h3 id="x10.2.1.2.2">10.2.1.2.2 CreateMutableBinding (N, D)<a href="#x10.2.1.2.2">#</a></h3>

<p>
    　オブジェクト型環境レコードにおける具体的な環境レコードのメソッドCreateMutableBindingは、String型の値である名称を持つプロパティを環境オブジェクトの関連付けられたバインディングオブジェクト内で生成し、値undefinedに初期化します。
    N と名付けたプロパティは、バインディングオブジェクト内に既に存在していてはいけません。
    Boolean型の引数 D が提供され、値trueを持つ場合、新たなプロパティの[[Configurable]]属性はtrueに設定され、それ以外の場合にはfalseに設定されます。
</p>

<div class="pre-div">
<pre>
1.envRecは、実行されたオブジェクト型環境レコードとする
2.bindingsは、envRecにおけるバインディングオブジェクトとする
3.Assert:プロパティ名 N と渡すことによってバインディングの[[HasProperty]]内部メソッドはfalse
4. D がtrueである場合には、configValueはtrueとし、それ以外の場合、configValueはfalseとする
5.バインディングの[[DefineOwnProperty]]内部メソッドを呼び、引数として N 、プロパティ記述子 {[[Value]]:undefined, [[Writable]]: true, [[Enumerable]]: true , [[Configurable]]: configValue} 、trueを渡す
</pre>
</div>

<h3 id="x10.2.1.2.3">10.2.1.2.3 SetMutableBinding (N,V,S)<a href="#x10.2.1.2.3">#</a></h3>

<p>
    　オブジェクト型環境レコードにおける具体的な環境レコードのメソッドSetMutableBindingは、引数 N という値である名称を持つ環境レコードの関連付けられたバインディングオブジェクトのプロパティの値を引数 V
    という値に設定するべく試行します。
    N と名付けたプロパティは、既に存在すべきですが、それが存在しなかったり、現在書き込み可能でない場合、エラー操作は、Boolean型引数 S という値によって決められます。
</p>

<div class="pre-div">
<pre>
1.envRec実行されたメソッドにおけるオブジェクト型環境レコードとする
2.bindingsは、envRecにおけるバインディングオブジェクトとする
3.引数N, V, Sを伴うバインディングの[[Put]]内部メソッドを呼ぶ
</pre>
</div>

<h3 id="x10.2.1.2.4">10.2.1.2.4 GetBindingValue(N,S)<a href="#x10.2.1.2.4">#</a></h3>

<p>
    　オブジェクト型環境レコードにおける具体的な環境レコードのメソッドGetBindingValueは、識別子 N を引数としたString型の値である名称を持つその関連付けられたバインディングオブジェクトのプロパティの値を返します。
    プロパティは、既に存在すべきですが、引数 S の値に依存する結果にならない場合、(以下のように評価されます。)
</p>

<div class="pre-div">
<pre>
1.envRecは、実行されたオブジェクト型環境レコードとする
2.bindingsは、envRecにおけるバインディングオブジェクトとする
3.valueは、プロパティ名として N を渡すことによってバインディングの[[HasProperty]]内部メソッドを呼んだ結果とする
4.valueがfalseである場合には、
	a. S がfalseである場合、値undefinedを返し、それ以外の場合、ReferenceError例外を投げる(スローする)
5.引数における N を渡すことによってバインディングの[[Get]]内部メソッドを呼ぶことで結果を返す
</pre>
</div>

<h3 id="x10.2.1.2.5">10.2.1.2.5 DeleteBinding (N)<a href="#x10.2.1.2.5">#</a></h3>

<p>
    　オブジェクト型環境レコードにおける具体的な環境レコードのメソッドDeleteBindingは、値trueを持つ[[Configurable]]属性を持つ環境オブジェクトのプロパティと一致するバインディングだけを削除することが可能です。
</p>

<div class="pre-div">
<pre>
1.envRecは、実行されたメソッドにおけるオブジェクト型環境レコードとする
2.bindingsは、envRecにおけるバインディングオブジェクトとする
3.N と引数としてfalseを渡すことによってバインディングの[[Delete]]内部メソッドを呼ぶことで結果を返す
</pre>
</div>

<h3 id="x10.2.1.2.6">10.2.1.2.6 ImplicitThisValue()<a href="#x10.2.1.2.6">#</a></h3>

<p>
    　オブジェクト型環境レコードは、それらのprovideThisフラグがtrueである場合以外は、それらのImplicitThisValueとしてundefinedを返します。
</p>

<div class="pre-div">
<pre>
1.envRecは、実行されたメソッドにおけるオブジェクト型環境レコードとする
2.envRecのprovideThisフラグがtrueである場合、envRecにおけるバインディングオブジェクトを返す
3.それ以外は、undefinedを返す
</pre>
</div>

<h3 id="x10.2.2">10.2.2 Lexical Environment Operations／語彙的環境の操作<a href="#x10.2.2">#</a></h3>

<p>
    　次の抽象操作は、語彙的な環境における操作についてのこの仕様内で使用されます。
</p>

<h3 id="x10.2.2.1">10.2.2.1 GetIdentifierReference (lex, name, strict)<a href="#x10.2.2.1">#</a></h3>

<p>
    　抽象操作GetIdentifierReferenceは、語彙環境であるlex、識別子としてString型のname、Booleanフラグであるstrictを伴って呼ばれます。
    lexの値は、nullとなる場合があります。
    呼ばれる際、次のステップが実行されます。
</p>

<div class="pre-div">
<pre>
1.lexがnull値である場合、
	a.基準値が未定義、参照する名称がname、strict(厳格)モードフラグがstrictであるReference型の値を返す
2.envRecは、lexの環境レコードとする
3.引数 N としての名称を渡すことによってenvRecの具体的なメソッドHasBinding(N)を呼んだ結果とする
4.existsがtrueである場合、
	a.基準値がenvRec、参照する名称がname、strict(厳格)モードフラグがstrictであるReference型の値を返す
5.それ以外の場合、
	a. outerは、lexの外部環境参照の値とする
	b. 引数としてouter、name、strictを渡すことによってGetIdentifierReferenceを呼ぶことで結果を返す
</pre>
</div>


<h3 id="x10.2.2.2">10.2.2.2 NewDeclarativeEnvironment (E)<a href="#x10.2.2.2">#</a></h3>

<p>
    　抽象操作NewDeclarativeEnvironmentが、語彙環境や引数 E としてnullを伴って呼ばれる際には、次のステップが実行されます。
</p>

<div class="pre-div">
<pre>
1.envは、新たな語彙環境とする
2.envRecは、バインディングを一切含まない新たに宣言する環境レコードとする
3.envの環境レコードはenvRecとして設定
4.envとしての外部の語彙的な環境参照に E を設定
5.envを返す
</pre>
</div>

<h3 id="x10.2.2.3">10.2.2.3 NewObjectEnvironment (O, E)<a href="#x10.2.2.3">#</a></h3>

<p>
    　抽象操作NewObjectEnvironmentがオブジェクト O と引数として語彙環境 Eを伴って呼ばれる際には、次のステップが実行されます。
</p>

<div class="pre-div">
<pre>
1.envは、新たなLexical Environmentとする
2.envRecは、バインディングオブジェクトとして O を含む新たなオブジェクト型環境レコードとする
3.envの環境レコードはenvRecとして設定
4.envの外部の語彙的な環境参照は E に設定
5.envを返す
</pre>
</div>

<h3 id="x10.2.3">10.2.3 グローバル環境 / The Global Environment<a href="#x10.2.3">#</a></h3>

<p>
    　グローバル環境は、ECMAScriptコードが実行される前に生成される一意の語彙環境です。
    グローバル環境の環境レコードは、グローバルオブジェクト(15.1)であるバインディングオブジェクトを持つオブジェクト型環境レコードです。
    グローバル環境の外部環境参照は、nullです。
    ECMAScriptコードが実行される場合、オプションとしてプロパティがグローバルオブジェクトに追加され、初期プロパティが変更される場合があります。
</p>


</article>
<article>


    <h2>10.3 実行コンテキスト / Execution Contexts </h2>


    <h3 id="x10.3">10.3 実行コンテキスト / Execution Contexts<a href="#x10.3">#</a></h3>

    <p>
        　操作がECMAScriptの実行可能コードに翻訳される際には、操作は、実行コンテキストを入力しています。
        スタックから論理的な実行コンテキストをアクティブにします。
        この論理的なスタックにおける1番上の実行コンテキストは、実行コンテキストを実行中にします。
        操作時、常に生成される新たな実行コンテキストは、実行コンテキストと関連付けられていない実行可能コードに現在実行中の実行コンテキストを関連付けた実行可能コードから翻訳されます。
    </p>

    <p>
        　新たに生成した実行コンテキストは、スタック上にプッシュされ、実行中の実行コンテキストになります。
        いかなる状態においても実行コンテキストは、その関連付けたコードの実行経過を追跡する必要があります。
        追記すると各実行コンテキストは、Table 19 に挙げた状態コンポーネントを持ちます。
    </p>

    <div class="pre-div">
<pre>
Table 19 -- 実行コンテキストの状態コンポーネント
-------------------------------------------------------------------------------------------------------------
コンポーネント		目的
-------------------------------------------------------------------------------------------------------------
LexicalEnvironment	識別子参照を解決する為に使用した識別子Lexical Environment(語彙環境)は、この実行コンテキスト内にあるコードによって作成される
VariableEnvironment	環境レコードである識別子Lexical Environmentは、この実行コンテキスト内にあるVariableStatements と FunctionDeclarationsによって生成したバインディングを保持する
ThisBinding		この実行コンテキストと関連付けたECMAScriptコード内にあるthisキーワードと関連付けた値
-------------------------------------------------------------------------------------------------------------
</pre>
    </div>

    <p>
        　実行コンテキストとしてのLexicalEnvironment と VariableEnvironmentコンポーネントは、常に語彙的な環境です。
        実行コンテキストが当該LexicalEnvironment と VariableEnvironmentコンポーネントを生成する場合には、最初に同じ値を持ちます。
        VariableEnvironmentコンポーネントの値は、LexicalEnvironmentコンポーネントの値が実行コンテキスト内にあるコードの実行中に変更する可能性がある間は、決して変更されません。
    </p>

    <p>
        多くの状況においては、唯一実行中の実行コンテキスト(実行コンテキストスタックの最上段)はこの仕様内にあるアルゴリズムによって直接操作されます。
        その為、
    </p>

    <p>
        用語
        "LexicalEnvironment"、"VariableEnvironment"、"ThisBinding"
    </p>

    <p>
        は、実行中の実行コンテキストのそれらコンポーネントへの参照について必要となる資格なしで使用されます。
    </p>

    <p>
        実行コンテキストは、単に仕様上の仕組みであり、ECMAScript実装の一部の特定の人為的なものと一致する必要はありません。
        ECMAScriptプログラムにおいては実行コンテキストにアクセスすることは不可能です。
    </p>

    <h3 id="x10.3.1">10.3.1 識別子の解決 / Identifier Resolution<a href="#x10.3.1">#</a></h3>

    <p>
        　識別子の解決とは、実行中の実行コンテキストのLexicalEnvironmentを使用して識別子としてバインディングすることを決定している過程です。
        ECMAScriptコードの実行中、構文上のプロダクションは、PrimaryExpression、識別子は次のアルゴリズムを使用して評価されます。
    </p>

    <div class="pre-div">
<pre>
1.envは、実行中の実行コンテキストのLexicalEnvironmentとする
2.評価中に構文上のプロダクションが、strict(厳格)モードのコード内に含まれる場合には、strictをtrueとし、それ以外は、strictをfalseとする
3.引数としてenv、Identifier、strictを渡してGetIdentifierReference関数を呼ぶことによって結果を返す
</pre>
    </div>

    <p>
        　評価中の識別子の結果は、常にString型のIdentifier(識別子)と等しい名称の参照するコンポーネントであるReference型の値です。
    </p>


</article>
<article>


    <h2>10.4 生成中の実行コンテキスト / Establishing an Execution Context </h2>


    <h3 id="x10.4">10.4 生成中の実行コンテキスト<a href="#x10.4">#</a></h3>

    <p>
        　Globalコードやeval関数(15.1.2.1)使用中のコードが、確立し、新たな実行コンテキストを入力します。
        関数が自身を再帰的に呼ぶ場合でさえ、ECMAScriptコードの関数(13.2.1)の呼び出しごとに確立し、新たな実行コンテキストを入力します。
        各リターンは、任意の実行コンテキストを抜けます。
        例外を投げる(スローする)と、1つ以上の実行コンテキストを抜ける場合もあります。
    </p>

    <p>
        　操作が実行コンテキストを入力する場合、当該実行コンテキストのThisBindingが設定され、そのVariableEnvironmentと初期のLexicalEnvironmentが定義され、宣言型バインディングのインスタンス化(10.5)が実行されます。
        これらアクションにおける正確な動作は、入力されるコードの種類に依存して発生します。
    </p>

    <h3 id="x10.4.1">10.4.1 入力中のGlobalコード<a href="#x10.4.1">#</a></h3>

    <p>
        　次のステップは、操作がGlobalコードにおける実行コンテキストを入力する場合に実行されます。
    </p>

    <div class="pre-div">
<pre>
1. 10.4.1.1で定義したようにGlobalコードを使用して実行コンテキストを初期化
2.Globalコードを使用して 10.5 で定義したように宣言型バインディングのインスタンス化を実行
</pre>
    </div>

    <h3 id="x10.4.1.1">10.4.1.1 初期のGlobal実行コンテキスト<a href="#x10.4.1.1">#</a></h3>

    <p>
        　次のステップは、ECMAScriptコード C におけるGlobal実行コンテキストを初期化する為に実行されます。
    </p>

    <div class="pre-div">
<pre>
1.VariableEnvironmentにGlobal環境を設定
2.LexicalEnvironmentにGlobal環境を設定
3.ThisBindingにGlobalオブジェクトを設定
</pre>
    </div>

    <h3 id="x10.4.2">10.4.2 入力中のEvalコード<a href="#x10.4.2">#</a></h3>

    <p>
        　次のステップは、操作がevalコードにおける実行コンテキストを入力する場合に実行されます。
    </p>

    <div class="pre-div">
<pre>
1.呼ぶコンテキストがなかったり、evalコードが、eval関数を直接呼ぶ(15.1.2.1.1)ことによって評価されない場合には、
	a. 10.4.1.1.で定義した C と同じevalコードを使用中のGlobal実行コンテキストであったかのように実行コンテキストを初期化
2.Else,
	a.実行コンテキストを呼び出すことによるThisBindingと同じ値をThisBindingに設定
	b.実行コンテキストを呼び出すことによるLexicalEnvironmentと同じ値をLexicalEnvironmentに設定
	c.実行コンテキストを呼び出すことによるVariableEnvironmentと同じ値をVariableEnvironmentに設定
3.evalコードがstrict(厳格)コードである場合、
	a.strictVarEnvは、引数としてLexicalEnvironmentを渡すことによってNewDeclarativeEnvironmentを呼んだ結果とする
	b.LexicalEnvironmentにstrictVarEnvを設定
	c.VariableEnvironmentにstrictVarEnvを設定
4.evalコード使用して 10.5 で定義したように宣言型バインディングのインスタンス化を実行
</pre>
    </div>

    <h3 id="x10.4.2.1">10.4.2.1 Strict(厳格)モードの制約<a href="#x10.4.2.1">#</a></h3>

    <p>
        　evalコードは、仮にコンテキストを呼んだ結果としてのコードであったり、evalコードがstrict(厳格)コードであった場合でもevalを実行したコンテキストを呼ぶことによる変数環境にある変数や関数バインディングをインスタンス化することはできません。
        代わりにそのようなバインディングは、evalコードに唯一アクセス可能である新たなVariableEnvironment内でインスタンス化されます。
    </p>

    <h3 id="x10.4.3">10.4.3 入力中の関数コード<a href="#x10.4.3">#</a></h3>

    <p>
        　次のステップは、操作が、オブジェクト F 内に含まれる関数コードにおける実行コンテキストを入力する際、callerがthisArgを提供または、callerがargumentsListを提供する場合に実行されます。
    </p>

    <div class="pre-div">
<pre>
1.関数コードがstrict(厳格)コードである場合、ThisBindingにthisArgを設定
2.thisArgがnullまたは、undefinedである場合、ThisBindingにGlobalオブジェクトを設定
3.Type(thisArg)が、Object型ではない場合、ThisBindingにToObject(thisArg)を設定
4.それ以外の場合、ThisBindingにthisArgを設定
5.localEnvは、引数として F の[[Scope]]内部プロパティの値を渡すことによってNewDeclarativeEnvironmentを呼んだ結果とする
6.LexicalEnvironmentにlocalEnvを設定
7.VariableEnvironmentにlocalEnvを設定
8.codeは、Fの[[Code]]内部プロパティの値とする
9. 10.5で説明したように関数コードcodeとargumentsListを使用して宣言型バインディングのインスタンス化を実行
</pre>
    </div>


</article>
<article>


    <h2>10.5 宣言型バインディングのインスタンス化 / Declaration Binding Instantiation </h2>


    <h3 id="x10.5">10.5 Declaration Binding Instantiation ／ 宣言型バインディングのインスタンス化<a href="#x10.5">#</a></h3>

    <p>
        　各実行コンテキストは、関連したVariableEnvironmentを持ちます。
        実行コンテキスト内で評価したECMAScriptコード内で定義した変数と関数は、そのVariableEnvironmentの環境レコード内でバインディングしたものとして追加されます。
        関数コードについては、パラメータは、その環境レコードにバインディングするものとして追加されます。
    </p>

    <p>
        　環境レコードは、実行コンテキストによって実行したECMAScriptコードの型に依存するその種類をバインドする為に使用されますが、残りの動作は、一般的なものです。
        入力中の実行コンテキストにおいては、バインディングは、次のようなcallerが提供したコードを使用してVariableEnvironment内で生成され、それが関数コードである場合には、引数リストargsは、(以下のように評価されます。)
    </p>

    <div class="pre-div">
<pre>
1.envは、実行中の実行コンテキストのVariableEnvironmentの環境レコードコンポーネントとする
2.codeがevalコードである場合、configurableBindingsをtrueとし、それ以外は、configurableBindingsをfalseとする
3.codeがstrict(厳格)モードのコードである場合には、strictをtrueとし、それ以外は、strictをfalseとする
4.codeが関数コードである場合、
	a.funcは、コードの実行を初期化した[[Call]]内部メソッドを持つ関数とする。namesは、funcの[[FormalParameters]]内部プロパティの値とする
	b.argCountは、argsにある要素の数とする
	c. n は数値0とする
	d.namesにあるString型の各argNameにおいて、リスト順に実行します。
		i. n は、 n + 1 を現在の値とする
		ii. n が、argCountより大きい場合、 v は、undefined、それ以外は、 v は args の n 番めの要素の値とする
		iii.argAlreadyDeclaredは、引数としてargNameを渡すことによって具体的なメソッドであるenvのHasBindingを呼んだものを結果とする
		iv.argAlreadyDeclaredが、falseである場合、引数としてargNameを渡すことによって具体的なメソッドであるenvのCreateMutableBindingを呼ぶ
		v.引数としてargName、v、strictを渡すことによって具体的なメソッドであるenvのSetMutableBindingを呼ぶ
5.code内の各FunctionDeclaration f において、ソーステキスト順に実行する
	a. fn は、FunctionDeclaration f 内のIdentifierとする
	b. fo は、第13項で説明したようにインスタンス化中のFunctionDeclaration f の結果とする
	c.funcAlreadyDeclaredは、引数として fn を渡すことによって具体的なメソッドであるenvのHasBindingを呼んだ結果とする
	d.funcAlreadyDeclaredがfalseである場合、引数として fn 、 configurableBindingsを渡すことによって具体的なメソッドenvのCreateMutableBindingを呼ぶ
	e.envがGlobal環境の環境レコードコンポーネントである場合、
		i. go は、Globalオブジェクトとする
		ii.existingPropは、引数 fn を伴う go の内部メソッド[[GetProperty]]を呼んだ結果とする
		iii. existingProp .[[Configurable]] がtrueである場合、
			1. 引数として fn 、プロパティ記述子{[[Value]]: undefined, [[Writable]]: true, [[Enumerable]]: true , [[Configurable]]: configurableBindings } 、true を渡すことによって go の内部メソッド[[DefineOwnProperty]]を呼ぶ
		iv. IsAccessorDescriptor(existingProp) やexistingPropが属性値 {[[Writable]]: true, [[Enumerable]]: true} を持たない場合、
			1.TypeError例外を投げる(スローする)
	f.引数として fn 、fo 、strictを渡すことによって具体的なメソッドであるenvのSetMutableBindingを呼ぶ
6.argumentsAlreadyDeclaredは、引数として"arguments"を渡すことによって具体的なメソッドであるenvのHasBindingを呼んだ結果とする
7.codeが、関数コード、且つargumentsAlreadyDeclaredがfalseである場合、
	a.argsObjは、引数としてfunc、names、args、env、strictを渡すことによって抽象操作CreateArgumentsObject (10.6) を呼んだ結果とする
	b.strictがtrueである場合、
		i.引数としてString型の"arguments"を渡すことによって具体的なメソッドであるenvのCreateImmutableBindingを呼ぶ
		ii.引数として"arguments" と argsObj を渡すことによって具体的なメソッドであるenvのInitializeImmutableBindingを呼ぶ
	c.それ以外の場合、
		i.引数としてString型の"arguments"を渡すことによって具体的なメソッドであるenvのCreateMutableBindingを呼ぶ
		ii.引数として"arguments"、argsObj、falseを渡すことによって具体的なメソッドであるenvのSetMutableBindingを呼ぶ
8. code内にある各VariableDeclaration と VariableDeclarationNoIn d は、ソーステキスト順に実行する
	a. dn は、 d 内のIdentifierとする
	b.varAlreadyDeclaredは、引数として dn を渡すことによって具体的なメソッドであるenvのHasBindingを呼んで結果とする
	c.varAlreadyDeclaredがfalseである場合、
		i.引数として dn と configurableBindings を渡すことによって具体的なメソッドであるenvのCreateMutableBindingを呼ぶ
		ii.引数として dn、undefined、strictを渡すことによって具体的なメソッドであるenvのSetMutableBindingを呼ぶ
</pre>
    </div>


</article>
<article>


    <h2>10.6 argumentsオブジェクト / Arguments Object </h2>


    <h3 id="x10.6">10.6 argumentsオブジェクト / Arguments Object / 引数オブジェクト<a href="#x10.6">#</a></h3>

    <p>
        　操作が、関数のコードにおける実行コンテキストを入力する場合、(10.5で記述したように)識別子の引数が関数のFormalParameterList内にあるIdentifierとして現れるか、または、関数コード内に含まれるVariableDeclaration
        や FunctionDeclarationのIdentifierとして現れない限り、argumentsオブジェクトが生成されます。
    </p>

    <p>
        　当該argumentsオブジェクトは、評価される為にあるコード、関数の正規名を含んだ名称 List、[[Call]]内部メソッドへの実引数 args 、関数コードにおける変数環境 env
        、関数コードがstrict(厳格)コードか否かを示すBoolean型のstrictを持つ関数オブジェクトである引数 func を伴う抽象操作CreateArgumentsObjectを呼ぶことによって生成されます。
        CreateArgumentsObjectが呼ばれる場合、次のステップが実行されます。
    </p>

    <div class="pre-div">
<pre>
1. len は、args 内の要素の数とする
2. obj は、新たなECMAScriptオブジェクトを生成したものを結果とする
3. 8.12 で記述したように obj の全ての内部メソッドを設定
4. obj の[[Class]]内部プロパティに"Arguments"を設定
5. Object は、標準組み込みObjectコンストラクタ(15.2.2)とする
6. obj の[[Prototype]]内部プロパティに標準組み込みObjectのプロトタイプオブジェクト(15.2.4)を設定
7.引数として"length"、Property Descriptor(プロパティ記述子) {[[Value]]: len, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true}、falseを渡すことによって obj 上で[[DefineOwnProperty]]内部メソッドを呼ぶ
8. map は、名前付き標準組み込みコンストラクタであるObjectである式 new Object() によるかのように新たなオブジェクトを生成することで結果とする
9. mappedNames は、カラのListとする
10. indx = len - 1 とする
11. indx = 0 である間繰り返す
	a. val は、0基準リスト(0-origined list)の位置 indx における args の要素とする
	b. 引数として ToString(indx)、プロパティ記述子 {[[Value]]: val, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}、falseを渡すことによって obj 上で[[DefineOwnProperty]]内部メソッドを呼ぶ
	c. indx が names にある要素数よりも小さい場合、
		i. name は、0基準リスト(0-origined list)の位置 indx における names の要素とする
		ii. strict が、falseで且つ name が mappedNames の要素ではない場合、
			1.リストmappedNamesの要素の1つとして name を追加
			2. g は、引数 name と env を伴う抽象操作MakeArgGetterを呼んだ結果とする
			3. p は、引数 name と env を伴う抽象操作MakeArgSetterを呼んだ結果とする
			4.引数として ToString(indx)、プロパティ記述子 {[[Set]]: p, [[Get]]: g, [[Configurable]]: true}、false を渡すことによって map の[[DefineOwnProperty]]内部メソッドを呼ぶ
	d. indx = indx - 1 とする
12. mappedNames がカラではない場合、
	a. obj の[[ParameterMap]]内部プロパティに map を設定
	b. obj の[[Get]]、[[GetOwnProperty]]、[[DefineOwnProperty]]、[[Delete]]内部メソッドに以下で提供した定義を設定
13. strict が、false である場合、
	a.引数として"callee"、プロパティ記述子 {[[Value]]: func, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true}、false を渡すことによって obj 上で[[DefineOwnProperty]]内部メソッドを呼ぶ
14.それ以外の場合、strict は、true となるので
	a. thrower は、[[ThrowTypeError]]関数Object(13.2.3)とする
	b.引数 "caller"、プロパティ記述子 {[[Get]]: thrower, [[Set]]: thrower, [[Enumerable]]: false, [[Configurable]]: false}、falseを伴う obj の[[DefineOwnProperty]]メソッドを呼ぶ
	c.引数 "callee"、プロパティ記述子 {[[Get]]: thrower, [[Set]]: thrower, [[Enumerable]]: false, [[Configurable]]: false}、falseを伴う obj の[[DefineOwnProperty]]メソッドを呼ぶ
15. obj を返す
</pre>
    </div>

    <p>
        　String型の name と環境レコード env を伴って呼ぶ抽象操作MakeArgGetterは、env にある name においてバインドする値を返す為に実行した場合、関数オブジェクトを生成します。
        それは次のステップを実行します。
    </p>

    <div class="pre-div">
<pre>
1. body は、文字列 "return "、name、";"を連結したものを結果とする
2.FormalParameterListがなく、FunctionBodyについては body 、Scopeとして env 、Strictについては trueとして使用することによって 13.2 で説明したように関数オブジェクトを生成した結果を返す
</pre>
    </div>

    <p>
        　String型の name と 環境レコード env を伴って呼ぶ抽象操作MakeArgSetterは、env にある name においてバインドする値の設定を実行した場合、関数オブジェクトを生成します。
        それは次のステップを実行します。
    </p>

    <div class="pre-div">
<pre>
1. param は、文字列  "_arg" と連結した文字列 name とする
2. body は、name の値によって置換される &lt;name&gt; と param の値によって置換される &lt;param&gt; で文字列 "&lt;name&gt; = &lt;param&gt;;" とする
3.FormalParameterListとして単独の文字列 param を含む List 、FunctionBodyについては body 、Scopeとして env 、Strictについては true を使用して 13.2 で説明したように関数オブジェクトを生成した結果を返す
</pre>
    </div>

    <p>
        　プロパティ名 P を伴う非strict(厳格)モードの関数における引数 object の[[Get]]内部メソッドは、次のステップを実行します。
    </p>

    <div class="pre-div">
<pre>
1. map は、引数 object の[[ParameterMap]]内部プロパティの値とする
2. isMapped は、引数として P を渡すことによって map の[[GetOwnProperty]]内部メソッドを呼んだ結果とする
3. isMapped の値が undefined である場合には、
	a. v は、引数として P を渡すことによって引数 objectにおける既定の[[Get]] 内部メソッド (8.12.3) を呼んだ結果とする
	b. P が、"caller" である場合、 v は、strict(厳格)モードのFunctionオブジェクトであり、TypeError例外を投げる(スローする)
	c. v を返す
4.それ以外の場合、 map は、 P における正規なパラメータマッピングを含む為、
	a.引数として P を渡すことによって map の[[Get]]内部メソッドを呼んだ結果を返す
</pre>
    </div>

    <p>
        　プロパティ名 P を伴って呼ばれる場合、正規のパラメータを伴う非strict(厳格)モードの関数におけるargumentsオブジェクトの[[GetOwnProperty]]内部メソッドは、次のステップを実行します。
    </p>

    <div class="pre-div">
<pre>
1. desc は、引数として P を渡すことによって 引数 object における既定の[[GetOwnProperty]]内部メソッド (8.12.1) を呼んだ結果とする
2. desc が、undefinedである場合、 desc を返す
3. map は、argumentsオブジェクトの[[ParameterMap]]内部プロパティの値とする
4. isMapped は、引数として P を渡すことによって map の[[GetOwnProperty]]内部メソッドを呼んだ結果とする
5. isMapped の値が、undefinedである場合、
	a. desc.[[Value]] に引数として P を渡すことによって map の[[Get]]内部メソッドを呼んだ結果を設定
6. desc を返す
</pre>
    </div>

    <p>
        　プロパティ名 P 、プロパティ記述子 Desc 、Boolean型フラグ Throw
        を伴って呼んだ正規のパラメータを伴う非strict(厳格)モードの関数におけるargumentsオブジェクトの[[DefineOwnProperty]]内部メソッドは、次のステップを実行します。
    </p>

    <div class="pre-div">
<pre>
1. map は、引数 s オブジェクトの[[ParameterMap]]内部プロパティの値とする
2. isMapped は、引数として P を渡すことによって map の[[GetOwnProperty]]内部メソッドを呼んだ結果とする
3. allowed は、引数として P、Desc、false を渡すことによってargumentsオブジェクトにおける既定の[[DefineOwnProperty]]内部メソッド (8.12.9) を呼んだ結果とする
4. allowed が、false である場合、
	a. Throw が、true である場合、TypeError例外を投げ、それ以外は、falseを返す
5. isMapped の値が、undefinedである場合、
	a. IsAccessorDescriptor(Desc) が、true であれば、
		i.引数として P 、false を渡すことによって map の[[Delete]]内部メソッドを呼ぶ
	b.それ以外の場合、
		i. Desc.[[Value]] が、存在する場合、
			1.引数としてP 、 Desc.[[Value]] 、 Throw を渡すことによって map の [[Put]]内部メソッドを呼ぶ
		ii. Desc.[[Writable]] が、存在し、且つ、その値が falseである場合、
			1.引数としてP 、falseを渡すことによって map の[[Delete]]内部メソッドを呼ぶ
6. true を返す
</pre>
    </div>

    <p>
        　プロパティ名 P 、Boolean型フラグ Throw
        を伴って呼んだ正規のパラメータを伴う非strict(厳格)モードの関数におけるargumentsオブジェクトの[[Delete]]内部メソッドは、次のステップを実行します。
    </p>

    <div class="pre-div">
<pre>
1. map は、argumentsオブジェクトの[[ParameterMap]]内部プロパティの値とする
2. isMapped は、引数として P を渡すことによって map の[[GetOwnProperty]]内部メソッドを呼んだ結果とする
3. result は、引数として P 、 Throwを渡すことによってargumentsオブジェクトにおける既定[[Delete]]内部メソッド (8.12.7) を呼んだ結果とする
4. result が、true かつ、 isMapped の値が、undefined ではない場合、
	a.引数として P 、 falseを渡すことによって map の[[Delete]]内部メソッドを呼ぶ
5. result を返す
</pre>
    </div>

    <p>
        [注釈1]
    </p>

    <p>
        　( 15.4
        で定義した)非厳格モード(non-strict)の関数の配列インデックスにおいては、数値名の値を持つargumentsオブジェクトの名前付きデータプロパティは、当該関数の実行コンテキスト内でバインディングに対応する引数を伴うそれらの値を初期に共有する関数オブジェクトと対応する正規のパラメータの数よりも小さくなります。
        これは、変更中のプロパティは、argumentsオブジェクトの値(逆も真なり)と一致するものを変更するということを意味します。
        この対応は、プロパティが削除され再定義される場合やプロパティがアクセサプロパティに変更される場合などに壊れます。
        strict(厳格)モードの関数においては、argumentsオブジェクトのプロパティの値は、単に関数に渡した引数のコピーであり、プロパティ値と正規のパラメータ値とを動的にリンクするものではありません。
    </p>

    <p>
        [注釈2]
    </p>

    <p>
        　ParameterMapオブジェクトとそのプロパティ値は、引数バインディングと対応するargumentsオブジェクトを指定する為にデバイスとして使用されます。
        ParameterMapオブジェクトとそのプロパティの値であるオブジェクトは、ECMAScriptのコードから直接アクセスすることは不可能です。
        ECMAScriptの実装は、実際に生成したり、指定したセマンティクスを実装する為にそのようなオブジェクトを使用する必要はありません。
    </p>

    <p>
        [注釈3]
    </p>

    <p>
        　strict(厳格)モードの関数におけるargumentsオブジェクトは、アクセスするとTypeError例外を投げる(スローする) "caller" と "callee" と名付た未構成のアクセサプロパティを定義します。
        "callee" プロパティは、非strict(厳格)モードの関数においてという意味でより多くの仕様を持ち、"caller"
        プロパティは、一部のECMAScriptの実装によって実装定義の拡張として提供される履歴を持ちます。
        それらの何れにも確実に存在するこれらプロパティのstrict(厳格)モード定義は、対応するECMAScriptの実装による他の方法の中で定義されます。
    </p>


</article>
<article>


    <h2>11 式 / Expressions </h2>


    <p><a href="http://www.webzoit.net/hp/it/internet/homepage/script/ecmascript/ecma262_51/contents/11/11_1/"
          title="プライマリ式">11.1 プライマリ式</a>
    </p>

    <p><a href="http://www.webzoit.net/hp/it/internet/homepage/script/ecmascript/ecma262_51/contents/11/11_2/"
          title="左辺式">11.2 左辺式</a></p>

    <p><a href="http://www.webzoit.net/hp/it/internet/homepage/script/ecmascript/ecma262_51/contents/11/11_3/"
          title="後置式">11.3 後置式</a></p>

    <p><a href="http://www.webzoit.net/hp/it/internet/homepage/script/ecmascript/ecma262_51/contents/11/11_4/"
          title="単項演算子">11.4 単項演算子</a>
    </p>

    <p><a href="http://www.webzoit.net/hp/it/internet/homepage/script/ecmascript/ecma262_51/contents/11/11_5/"
          title="乗法演算子">11.5 乗法演算子</a>
    </p>

    <p><a href="http://www.webzoit.net/hp/it/internet/homepage/script/ecmascript/ecma262_51/contents/11/11_6/"
          title="加法演算子">11.6 加法演算子</a>
    </p>

    <p><a href="http://www.webzoit.net/hp/it/internet/homepage/script/ecmascript/ecma262_51/contents/11/11_7/"
          title="ビット単位シフト演算子">11.7
        ビット単位シフト演算子</a></p>

    <p><a href="http://www.webzoit.net/hp/it/internet/homepage/script/ecmascript/ecma262_51/contents/11/11_8/"
          title="関係演算子">11.8 関係演算子</a>
    </p>

    <p><a href="http://www.webzoit.net/hp/it/internet/homepage/script/ecmascript/ecma262_51/contents/11/11_9/"
          title="等価演算子">11.9 等価演算子</a>
    </p>

    <p><a href="http://www.webzoit.net/hp/it/internet/homepage/script/ecmascript/ecma262_51/contents/11/11_10/"
          title="バイナリビット単位演算子">11.10
        バイナリビット単位演算子</a></p>

    <p><a href="http://www.webzoit.net/hp/it/internet/homepage/script/ecmascript/ecma262_51/contents/11/11_11/"
          title="バイナリ論理演算子">11.11
        バイナリ論理演算子</a></p>

    <p><a href="http://www.webzoit.net/hp/it/internet/homepage/script/ecmascript/ecma262_51/contents/11/11_12/"
          title="条件演算子 ( ? : )">11.12
        条件演算子 ( ? : )</a></p>

    <p><a href="http://www.webzoit.net/hp/it/internet/homepage/script/ecmascript/ecma262_51/contents/11/11_13/"
          title="代入演算子">11.13 代入演算子</a>
    </p>

    <p><a href="http://www.webzoit.net/hp/it/internet/homepage/script/ecmascript/ecma262_51/contents/11/11_14/"
          title="カンマ演算子 ( , )">11.14
        カンマ演算子 ( , )</a></p>


</article>
<article>


<h2>11.1 主要な式 / Primary Expressions </h2>


<h3 id="x11.1">11.1 主要な式<a href="#x11.1">#</a></h3>
<pre>
構文

PrimaryExpression :
	this
	Identifier
	Literal
	ArrayLiteral
	ObjectLiteral
	( Expression )
</pre>

<h3 id="x11.1.1">11.1.1 thisキーワード<a href="#x11.1.1">#</a></h3>

<p>
    　thisキーワードは、現在の実行コンテキストのThisBindingの値を評価します。
</p>

<h3 id="x11.1.2">11.1.2 識別子参照<a href="#x11.1.2">#</a></h3>

<p>
    　識別子は、 10.3.1 で記述したように識別子解決を実行することによって評価されます。
    識別子を評価した結果は、常にReference型の値となります。
</p>

<h3 id="x11.1.3">11.1.3 リテラル参照<a href="#x11.1.3">#</a></h3>

<p>
    　リテラルは、7.8 で説明したように評価されます。
</p>

<h3 id="x11.1.4">11.1.4 配列イニシャライザー<a href="#x11.1.4">#</a></h3>

<p>
    　配列イニシャライザーは、リテラルの書式で書かれたArrayオブジェクトの初期化を説明する式です。
    それは、角ブラケットで括られた各配列要素を表すゼロ以上の式の列挙です。
    要素は、リテラルとする必要はなく、それらは配列イニシャライザーが評価される度に評価されます。
</p>

<p>
    　配列要素は、要素リストの先頭、中間や末尾で省略される場合があります。
    要素リスト内にあるカンマは、いかなる場合にもAssignmentExpressionによって先行される(例：他のカンマの前や後にカンマがある)ことはなく、不完全な配列要素は、配列の長さと要素の添え字のインデックスの増加に影響(寄与)します。
    省略した配列要素は定義されません。
    配列の末尾にある要素が省略される場合、その要素は、その配列・リストの長さに影響しません。
</p>

<div class="pre-div">
<pre>
【構文】
ArrayLiteral :
[ Elisionopt ]
[ ElementList ]
[ ElementList , Elisionopt ]

ElementList :
Elisionopt AssignmentExpression
ElementList , Elisionopt AssignmentExpression

Elision :
,
Elision ,
</pre>
</div>


<p>
    【セマンティクス】
</p>

<p>
    　プロダクション ArrayLiteral : [ Elisionopt ] は次のように評価されます。
</p>

<div class="pre-div">
<pre>
1. array は、配列が名前付き標準組み込みコンストラクタとなる式 new Array() であるかのように新たなオブジェクトを生成したものを結果とする
2. pad は、Elisionを評価したものを結果とし、存在しない場合には、数値ゼロを使用
3.引数 "length "、pad 、false を伴う配列の[[Put]]内部メソッドを呼ぶ
4. array を返す
</pre>
</div>

<p>
    　プロダクション ArrayLiteral : [ ElementList ] は、次のように評価されます。
</p>

<div class="pre-div">
<pre>
1.ElementListを評価した結果を返す
</pre>
</div>

<p>
    　プロダクション ArrayLiteral : [ ElementList , Elisionopt ] は、次のように評価されます。
</p>

<div class="pre-div">
<pre>
1. array は、ElementListを評価した結果とする
2. pad は、Elisionを評価した結果とし、存在しなければ、数値ゼロを使用
3. len は、引数 "length " を伴う配列の[[Get]]内部メソッドを呼び結果とする
4.引数 "length " 、ToUint32(pad+len)、false を伴う配列の[[Put]]内部メソッドを呼ぶ
5. array を返す
</pre>
</div>

<p>
    　プロダクション ElementList : Elisionopt AssignmentExpression は、次のように評価されます。
</p>

<div class="pre-div">
<pre>
1. array は、名前付き標準組み込みコンストラクタである配列となる式 new Array() によるかのように新たなオブジェクトを生成したものを結果とする
2. firstIndex は、Elisionを評価したものを結果とし、存在しない場合、数値ゼロを使用
3. initResult は、AssignmentExpressionを評価した結果とする
4. initValue は、 GetValue(initResult) とする
5.引数 ToString(firstIndex)、プロパティ記述子 { [[Value]]: initValue, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}、falseを伴う配列の[[DefineOwnProperty]]内部メソッドを呼ぶ
6. array を返す
</pre>
</div>

<p>
    　プロダクション ElementList : ElementList , Elisionopt AssignmentExpression は、次のように評価されます。
</p>

<div class="pre-div">
<pre>
1. array は、ElementListを評価したものを結果とする
2. pad は、Elisionを評価したものを結果とし、存在しない場合、数値ゼロを使用
3. initResult は、AssignmentExpressionを評価した結果とする
4. initValue は、GetValue(initResult) とする
5. len は、引数 "length "を伴う配列の[[Get]]内部メソッドを呼び結果とする
6.引数 ToString(ToUint32((pad+len)) 、プロパティ記述子 { [[Value]]: initValue, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}、falseを伴う配列の[[DefineOwnProperty]]内部メソッドを呼ぶ
7. array を返す
</pre>
</div>

<p>
    　プロダクション Elision : , は、次のように評価されます。
</p>

<div class="pre-div">
<pre>
1.数値1を返す
</pre>
</div>

<p>
    　プロダクション Elision : Elision , は、次のように評価されます。
</p>

<div class="pre-div">
<pre>
1. preceding は、Elisionを評価した結果とする
2. preceding+1 を返す
</pre>
</div>

<p>
    [注釈]
</p>

<p>
    　[[DefineOwnProperty]]
    は、[[Put]]を使って新たな自身のプロパティを生成することを阻む方法において変更される標準組み込みArrayプロトタイプオブジェクトでさえ、当該配列において定義される自身のプロパティを確保する為に使用されます。
</p>

<h3 id="x11.1.5">11.1.5 オブジェクトイニシャライザー<a href="#x11.1.5">#</a></h3>

<p>
    　オブジェクトイニシャライザーは、リテラルに似た書式で書かれるオブジェクトの初期化を説明する式です。
    それは、波カッコで括られたゼロ以上のプロパティ名の組と関連値のリストです。
    その値は、リテラルにする必要はなく、オブジェクトイニシャライザーが評価されるごとに評価されます。
</p>

<div class="pre-div">
<pre>
【構文】
ObjectLiteral :
	{ }
	{ PropertyNameAndValueList }
	{ PropertyNameAndValueList , }

PropertyNameAndValueList :
	PropertyAssignment
	PropertyNameAndValueList , PropertyAssignment

PropertyAssignment :
	PropertyName : AssignmentExpression
	get PropertyName ( ) { FunctionBody }
	set PropertyName ( PropertySetParameterList ) { FunctionBody }

PropertyName :
	IdentifierName
	StringLiteral
	NumericLiteral

PropertySetParameterList :
	Identifier
</pre>
</div>

<p>
    【セマンティクス】
</p>

<p>
    　プロダクション ObjectLiteral : { } は、次のように評価されます。
</p>

<div class="pre-div">
<pre>
1.名前付き標準組み込みコンストラクタであるObjectとなる式 new Object() によるかのように生成した新たなオブジェクトを返す
</pre>
</div>

<p>
    　プロダクション ObjectLiteral : { PropertyNameAndValueList } と ObjectLiteral : { PropertyNameAndValueList ,} は、次のように評価されます。
</p>

<div class="pre-div">
<pre>
1.PropertyNameAndValueListを評価した結果を返す
</pre>
</div>

<p>
    　プロダクション PropertyNameAndValueList : PropertyAssignment は、次のように評価されます。
</p>

<div class="pre-div">
<pre>
1. obj は、名前付き標準組み込みコンストラクタであるObjectとなる式 new Object() によるかのように新たなオブジェクトを生成した結果とする
2. propId は、PropertyAssignmentを評価した結果とする
3.引数 propId.name、propId.descriptor、falseを伴う obj の[[DefineOwnProperty]]内部メソッドを呼ぶ
4. obj を返す
</pre>
</div>

<p>
    　プロダクション PropertyNameAndValueList : PropertyNameAndValueList , PropertyAssignment は、次のように評価されます。
</p>

<div class="pre-div">
<pre>
1. obj は、PropertyNameAndValueListを評価した結果とする
2. propId は、PropertyAssignmentを評価した結果とする
3. previous は、引数 propId.name を伴う obj の[[GetOwnProperty]]内部メソッドを呼び結果とする
4. previous がundefinedではない場合、次の何れかの条件がtrueである場合、SyntaxError例外を投げる(スローする)
	a.strict(厳格)コードとIsDataDescriptor(previous)に含まれるプロダクションが true 且つ、 IsDataDescriptor(propId.descriptor) が true
	b. IsDataDescriptor(previous) が true 且つ、 IsAccessorDescriptor(propId.descriptor) が true
	c. IsAccessorDescriptor(previous)  が true 且つ、IsDataDescriptor(propId.descriptor) が true
	d. IsAccessorDescriptor(previous) が true 且つ、 IsAccessorDescriptor(propId.descriptor) が true、且つ、 previous と propId.descriptor の双方何れかが[[Get]]項目を持つか、または previous と propId.descriptor の双方何れかが[[Set]]項目を持つ
5.引数 propId.name、propId.descriptor、falseを伴う obj の[[DefineOwnProperty]]内部メソッドを呼ぶ
6. obj を返す
</pre>
</div>

<p>
    　もし、上記ステップがSyntaxErrorを投げる(スローする)場合には、実装は、初期エラー(第16項)としてそのエラーを扱わなければいけません。
</p>

<p>
    プロダクション PropertyAssignment : PropertyName : AssignmentExpression は、次のように評価されます。
</p>

<div class="pre-div">
<pre>
1. propName は、PropertyNameを評価した結果とする
2. exprValue は、AssignmentExpressionを評価した結果とする
3. propValue  は、 GetValue(exprValue) とする
4. desc は、プロパティ記述子 {[[Value]]: propValue, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true} とする
5.プロパティ識別子(propName、desc)を返す
</pre>
</div>

<p>
    　プロダクション PropertyAssignment : get PropertyName ( ) { FunctionBody } は、次のように評価されます。
</p>

<div class="pre-div">
<pre>
1. propName は、PropertyNameを評価した結果とする
2. closure は、カラのパラメータリストとFunctionBodyによって指定した body を伴い、 13.2 で指定したように新たなFunctionオブジェクトを生成した結果とする
   Scope のように実行中の実行コンテキストのLexicalEnvironment内で渡す
   PropertyAssignment が、strict(厳格)コード内に含まれたり、そのFunctionBodyが、strict(厳格)コードである場合にはStrictフラグがtrueの場合に渡す
3. desc は、プロパティ記述子 {[[Get]]: closure, [[Enumerable]]: true, [[Configurable]]: true} とする
4.プロパティ識別子(propName、desc)を返す
</pre>
</div>

<p>
    　プロダクション PropertyAssignment : set PropertyName ( PropertySetParameterList ) { FunctionBody } は、次のように評価されます。
</p>

<div class="pre-div">
<pre>
1. propName は、PropertyNameを評価した結果とする
2. closure は、PropertySetParameterListによって指定したパラメータとFunctionBodyによって指定した body を伴い、 13.2 で指定したように新たなFunctionオブジェクトを生成した結果とする
   その Scope として実行中の実行コンテキストのLexicalEnvironment内で渡す
   PropertyAssignment が、strict(厳格)コード内に含まれたり、そのFunctionBodyが、strict(厳格)コードである場合にはStrictフラグがtrueの場合に渡す
3. desc は、プロパティ記述子 {[[Set]]: closure, [[Enumerable]]: true, [[Configurable]]: true} とする
4.プロパティ識別子(propName、desc)を返す
</pre>
</div>

<p>
    　識別子 "eval" や識別子 "arguments"
    が、strict(厳格)コード内に含まれたり、そのFunctionBodyがstrict(厳格)コードであるPropertyAssignmentのPropertySetParameterList内にある識別子として現れる場合、それは、SyntaxErrorです。
</p>

<p>
    　プロダクション PropertyName : IdentifierName は、次のように評価されます。
</p>

<div class="pre-div">
<pre>
1.IdentifierNameとして同じ文字の並びを含むString型の値を返す
</pre>
</div>

<p>
    　プロダクション PropertyName : StringLiteral は、次のように評価されます。
</p>

<div class="pre-div">
<pre>
1.StringLiteral の SV を返す
</pre>
</div>

<p>
    　プロダクション PropertyName : NumericLiteral は、次のように評価されます。
</p>

<div class="pre-div">
<pre>
1. nbr は、NumericLiteralの値を形成した結果とする
2. ToString(nbr) を返す
</pre>
</div>

<h3 id="x11.1.6">11.1.6 グループ化演算子<a href="#x11.1.6">#</a></h3>

<p>
    　プロダクション PrimaryExpression : ( Expression ) は、次のように評価されます。
</p>

<div class="pre-div">
<pre>
1.Expressionを評価した結果を返す
  これはReference型になる場合もある
</pre>
</div>

<p>
    [注釈]
</p>

<p>
    　このアルゴリズムは、GetValueには、Expressionを評価した結果を適用しません。
    これについての主な動機は、deleteやtypeofといったような演算子は、カッコ付きの式を適用される場合がある為です。
</p>


</article>
<article>


<h2>11.2 左辺式 / Left-Hand-Side Expressions </h2>


<h3 id="x11.2">11.2 左辺式<a href="#x11.2">#</a></h3>

<div class="pre-div">
<pre>
【構文】
MemberExpression :
	PrimaryExpression
	FunctionExpression
	MemberExpression [ Expression ]
	MemberExpression .IdentifierName
	new MemberExpression Arguments

NewExpression :
	MemberExpression
	new NewExpression

CallExpression :
	MemberExpression Arguments
	CallExpression Arguments
	CallExpression [ Expression ]
	CallExpression .

IdentifierName Arguments :
	()
	( ArgumentList )

ArgumentList :
	AssignmentExpression
	ArgumentList , AssignmentExpression

LeftHandSideExpression :
	NewExpression
	CallExpression
</pre>
</div>

<h3 id="x11.2.1">11.2.1 プロパティアクセサ<a href="#x11.2.1">#</a></h3>

<p>
    　プロパティは、何れかのドット記法を使って、
</p>

<div class="pre-div">
<pre>
MemberExpression .IdentifierName
CallExpression .IdentifierName
</pre>
</div>

<p>
    または、ブラケット記法を使って
</p>

<div class="pre-div">
<pre>
MemberExpression [ Expression ]
CallExpression [ Expression ]
</pre>
</div>

<p>
    名称でアクセスされます。
</p>

<p>
    　ドット記法は、次の構文変換によって説明されます。
</p>

<div class="pre-div">
<pre>
MemberExpression .IdentifierName
</pre>
</div>

<p>
    は、
</p>

<div class="pre-div">
<pre>
MemberExpression [ &lt;identifier-name-string&gt; ]
</pre>
</div>

<p>
    とその振る舞いが同じであり、また、似たようなものとして
</p>

<div class="pre-div">
<pre>
CallExpression .IdentifierName
</pre>
</div>

<p>
    は、
</p>

<div class="pre-div">
<pre>
CallExpression [ &lt;identifier-name-string&gt; ]
</pre>
</div>

<p>
    とその振る舞いが同じで
</p>

<div class="pre-div">
<pre>
&lt;identifier-name-string&gt;
</pre>
</div>

<p>
    は、IdentifierNameとしてUnicodeエスケープシーケンス処理の後に来る同じ文字の並びを含む文字列リテラルです。
</p>

<p>
    　プロダクション
</p>

<div class="pre-div">
<pre>
MemberExpression : MemberExpression [ Expression ]
</pre>
</div>

<p>
    は、次のように評価されます。
</p>

<div class="pre-div">
<pre>
1. baseReference は、MemberExpressionを評価した結果とする
2. baseValue は、GetValue(baseReference) とする
3. propertyNameReference は、Expressionを評価した結果とする
4. propertyNameValue は、 GetValue(propertyNameReference) とする
5. CheckObjectCoercible(baseValue) を呼ぶ
6. propertyNameString は、 ToString(propertyNameValue) とする
7.評価中の構文上のプロダクションがstrict(厳格)モードのコード内に含まれる場合、 strict は、true、それ以外は、 strict は、false
8.基準値がbaseValue、参照名がpropertyNameString、strict(厳格)モードフラグがstrictであるReference型の値を返す
</pre>
</div>

<p>
    　プロダクション
</p>

<div class="pre-div">
<pre>
CallExpression : CallExpression [ Expression ]
</pre>
</div>

<p>
    は、ステップ1で評価されるCallExpressionを含む場合を除き、全く同じ方法で評価されます。
</p>

<h3 id="x11.2.2">11.2.2 new 演算子<a href="#x11.2.2">#</a></h3>

<p>
    　プロダクション
</p>

<div class="pre-div">
<pre>
NewExpression : new NewExpression
</pre>
</div>

<p>
    は、次のように評価されます。
</p>

<div class="pre-div">
<pre>
1. ref は、NewExpressionを評価した結果とする
2. constructor は、 GetValue(ref) とする
3. Type(constructor) が、Objectでない場合には、TypeError例外を投げる(スローする)
4. constructor が[[Construct]]内部メソッドを実装しない場合には、TypeError例外を投げる(スローする)
5. 引数を何も渡さず(引数のリストがカラのまま)constructor における[[Construct]]内部メソッドを呼んだ結果を返す
</pre>
</div>

<p>
    　プロダクション
</p>

<div class="pre-div">
<pre>
MemberExpression : new MemberExpression Arguments
</pre>
</div>

<p>
    は、次のように評価されます。
</p>

<div class="pre-div">
<pre>
1. ref は、MemberExpressionを評価した結果とする
2. constructor は、 GetValue(ref) とする
3. argList は、引数値の内部リスト(11.2.4)を生成中にArgumentsを評価した結果とする
4. Type(constructor) が、Objectではない場合、TypeError例外を投げる(スローする)
5. constructor が、[[Construct]]内部メソッドを実行しない場合、TypeError例外を投げる(スローする)
6. 引数の値としてリスト argList を渡し、constructor における[[Construct]]内部メソッドを呼んだ結果を返す
</pre>
</div>

<h3 id="x11.2.3">11.2.3 関数呼び出し／ファンクションコール<a href="#x11.2.3">#</a></h3>

<p>
    　プロダクション
</p>

<div class="pre-div">
<pre>
CallExpression : MemberExpression Arguments
</pre>
</div>

<p>
    は、次のように評価されます。
</p>

<div class="pre-div">
<pre>
1. ref は、MemberExpressionを評価した結果とする
2. func は、GetValue(ref) とする
3. argList は、Argumentsを評価した結果とし、引数の値の内部リストを生成 ( 11.2.4 参照 )
4. Type(func) がObjectではない場合、TypeError例外を投げる(スローする)
5. IsCallable(func) が、falseである場合、TypeError例外を投げる(スローする)
6. Type(ref) が、Referenceである場合、
	a. IsPropertyReference(ref) が trueである場合、
		i. thisValue は、 GetBase(ref) とする
	b. それ以外の場合で ref の基準が、環境レコードである場合、
		i. thisValue は、 GetBase(ref) の具体的なメソッド ImplicitThisValue を呼んだ結果とする
7.それ以外の場合で Type(ref) がReferenceではない場合、
	a. thisValue は、undefinedとする
8.引数の値であるリスト argList 、this 値としてthisValue を渡し、 func における[[Call]]内部メソッドを呼んだ結果を返す
</pre>
</div>

<p>
    　プロダクション
</p>

<div class="pre-div">
<pre>
CallExpression : CallExpression Arguments
</pre>
</div>

<p>
    は、ステップ1で評価されるCallExpressionを含む場合を除き、全く同じ方法で評価されます。
</p>

<p>
    [注釈]
</p>

<p>
    　返した結果は、 func が、ネイティブなECMAScriptオブジェクである場合、Reference型となることは決してありません。
    ホストオブジェクトを呼ぶ場合は常に実装依存であるReference型の値を返すことができます。
    Reference型の値が返される場合、非strict(厳格)なProperty Reference(プロパティ参照)にしなければいけません。
</p>

<h3 id="x11.2.4">11.2.4 引数リスト<a href="#x11.2.4">#</a></h3>

<p>
    　引数リストの評価は、値のリストを生成します( 8.8 参照)。
</p>

<p>
    　プロダクション
</p>

<div class="pre-div">
<pre>
Arguments : ( )
</pre>
</div>

<p>
    は、次のように評価されます。
</p>

<div class="pre-div">
<pre>
1.カラのListを返す
</pre>
</div>

<p>
    　プロダクション
</p>

<div class="pre-div">
<pre>
Arguments : ( ArgumentList )
</pre>
</div>

<p>
    は、次のように評価されます。
</p>

<div class="pre-div">
<pre>
1.ArgumentListを評価した結果を返す
</pre>
</div>

<p>
    　プロダクション
</p>

<div class="pre-div">
<pre>
ArgumentList : AssignmentExpression
</pre>
</div>

<p>
    は、次のように評価されます。
</p>

<div class="pre-div">
<pre>
1. ref は、AssignmentExpressionを評価した結果とする
2. arg は、 GetValue(ref) とする
3.唯一のアイテムが、 arg であるListを返す
</pre>
</div>

<p>
    　プロダクション
</p>

<div class="pre-div">
<pre>
ArgumentList : ArgumentList , AssignmentExpression
</pre>
</div>

<p>
    は、次のように評価されます。
</p>

<div class="pre-div">
<pre>
1. precedingArgs は、ArgumentListを評価した結果とする
2. ref は、AssignmentExpressionを評価した結果とする
3. arg は、 GetValue(ref) とする
4. precedingArgs の長さより長く、新たなリストの最後のアイテムである arg によって末尾に続くことにより、precedingArgs のアイテムであるアイテムを持つ List を返す
</pre>
</div>

<h3 id="x11.2.5">11.2.5 関数式<a href="#x11.2.5">#</a></h3>

<p>
    　プロダクション
</p>

<div class="pre-div">
<pre>
MemberExpression : FunctionExpression
</pre>
</div>

<p>
    は、次のように評価されます。
</p>

<div class="pre-div">
<pre>
1. FunctionExpression を評価した結果を返す
</pre>
</div>


</article>
<article>


    <h2>11.3 後置式 / Postfix Expressions </h2>


    <h3 id="x11.3">11.3 後置式<a href="#x11.3">#</a></h3>

    <div class="pre-div">
<pre>
【構文】
PostfixExpression :
	LeftHandSideExpression
	LeftHandSideExpression [no LineTerminator here] ++
	LeftHandSideExpression [no LineTerminator here] --
</pre>
    </div>

    <h3 id="x11.3.1">11.3.1 後置増分演算子<a href="#x11.3.1">#</a></h3>

    <p>
        　プロダクション
    </p>

    <div class="pre-div">
<pre>
PostfixExpression : LeftHandSideExpression [no LineTerminator here] ++
</pre>
    </div>

    <p>
        は、次のように評価されます。
    </p>

    <div class="pre-div">
<pre>
1. lhs は、LeftHandSideExpressionを評価した結果とする
2.続く条件が全て true である場合、SyntaxError例外を投げる(スローする)
・Referenceである Type(lhs) が、true
・IsStrictReference(lhs) が、true
・Type(GetBase(lhs)) が、環境レコード
・GetReferencedName(lhs)が、 "eval" または "arguments" の何れか
3. oldValue は、 ToNumber(GetValue(lhs)) とする
4. newValue は、 + 演算子( 11.6.3 参照)における同様のルールを使っている間、oldValueに値 1 を追加した結果とする
5. PutValue(lhs, newValue)を呼ぶ
6. oldValue を返す
</pre>
    </div>

    <h3 id="x11.3.2">11.3.2 後置減分演算子<a href="#x11.3.2">#</a></h3>

    <p>
        　プロダクション
    </p>

    <div class="pre-div">
<pre>
PostfixExpression : LeftHandSideExpression [no LineTerminator here] --
</pre>
    </div>

    <p>
        は、次のように評価されます。
    </p>

    <div class="pre-div">
<pre>
1. lhs は、LeftHandSideExpressionを評価した結果とする
2.続く条件が全て trueである場合、SyntaxError例外を投げる(スローする)
・ReferenceであるType(lhs)が、 true
・IsStrictReference(lhs)が、 true
・Type(GetBase(lhs))が、環境レコード
・GetReferencedName(lhs) が "eval" または "arguments" の何れか
3. oldValue は、 ToNumber(GetValue(lhs)) とする
4. newValue は、当該演算子における同様のルール(11.6.3)を使用中は、oldValue から 1 を引いた結果とする
5.PutValue(lhs, newValue)を呼ぶ
6. oldValue を返す
</pre>
    </div>


</article>
<article>


<h2>11.4 単項演算子 / Unary Operators </h2>


<h3 id="x11.4">11.4 単項演算子<a href="#x11.4">#</a></h3>

<div class="pre-div">
<pre>
【構文】
UnaryExpression :
	PostfixExpression
	delete UnaryExpression
	void UnaryExpression
	typeof UnaryExpression
	++ UnaryExpression
	-- UnaryExpression
	+ UnaryExpression
	- UnaryExpression
	~ UnaryExpression
	! UnaryExpression
</pre>
</div>

<h3 id="x11.4.1">11.4.1 delete 演算子<a href="#x11.4.1">#</a></h3>

<p>
    　プロダクション
</p>

<div class="pre-div">
<pre>
UnaryExpression : delete UnaryExpression
</pre>
</div>

<p>
    は、次のように評価されます。
</p>

<div class="pre-div">
<pre>
1. ref は、UnaryExpressionを評価した結果とする
2. Type(ref) がReferenceではない場合、trueを返す
3. IsUnresolvableReference(ref) が、trueである場合、
	a. IsStrictReference(ref)が、trueである場合、SyntaxError例外を投げる(スローする)
	b.それ以外の場合、trueを返す
4. IsPropertyReference(ref) が、trueである場合、
	a.引数として GetReferencedName(ref) と IsStrictReference(ref) を渡し、 ToObject(GetBase(ref)) における[[Delete]]内部メソッドを呼んだ結果を返す
5.それ以外の場合、 ref は、環境レコードバインディングへの参照である為、
	a. IsStrictReference(ref) が、trueである場合、SyntaxError例外を投げる(スローする)
	b. bindingsは、 GetBase(ref) とする
	c.引数として GetReferencedName(ref) を渡し、バインディングの具体的なメソッドDeleteBindingを呼んだ結果を返す
</pre>
</div>

<p>
    [注釈]
</p>

<p>
    　delete演算子が、strict(厳格)モードのコード内で現れる場合、そのUnaryExpression(単項式)が、変数、関数の引数、関数名等への直接参照である場合、SyntaxError例外が投げられ(スローされ)ます。
    追記するとdelete演算子が、strict(厳格)モードのコード内で現れる場合で且つ、削除されるプロパティが属性 { [[Configurable]]: false }
    を持つ場合、TypeError例外が投げられ(スローされ)ます。
</p>

<h3 id="x11.4.2">11.4.2 void 演算子<a href="#x11.4.2">#</a></h3>

<p>
    　プロダクション
</p>

<div class="pre-div">
<pre>
UnaryExpression : void UnaryExpression
</pre>
</div>

<p>
    は、次のように評価されます。
</p>

<div class="pre-div">
<pre>
1. expr は、UnaryExpressionを評価した結果とする
2. GetValue(expr) を呼ぶ
3. undefined を返す
</pre>
</div>

<p>
    [注釈]
</p>

<p>
    　GetValueは、観測可能な副作用を持つ場合がある為、その値は使用されませんが、呼ばれなければいけません。
</p>

<h3 id="x11.4.3">11.4.3 typeof 演算子<a href="#x11.4.3">#</a></h3>

<p>
    　プロダクション
</p>

<div class="pre-div">
<pre>
UnaryExpression : typeof UnaryExpression
</pre>
</div>

<p>
    は、次のように評価されます。
</p>

<div class="pre-div">
<pre>
1. val は、UnaryExpressionを評価した結果とする
2. Type(val) がReferenceである場合、
	a. IsUnresolvableReference(val) が、trueであれば、"undefined"を返す
	b. val は、 GetValue(val) とする
3.Table 20による Type(val) によって決まるString型を返す
</pre>
</div>

<div class="pre-div">
<pre>
Table 20 -- typeof 演算子の結果
------------------------------------------------------------------------------------------------------------------------------------
val の型							結果
------------------------------------------------------------------------------------------------------------------------------------
Undefined							"boolean"
Null								"object"
Number								"number"
Boolean								"boolean"
String								"string"
Object (ネイティブ且つ[[Call]]を実装しない)			"object"
Object (ネイティブかホストで且つ[[Call]]を実装しない)		"function"
Object (ホストで且つ[[Call]]を実装しない)			"undefined"、"boolean"、"number"、"string"となる場合を除き、実装定義
------------------------------------------------------------------------------------------------------------------------------------
</pre>
</div>

<h3 id="x11.4.4">11.4.4 前置増分演算子<a href="#x11.4.4">#</a></h3>

<p>
    　プロダクション
</p>

<div class="pre-div">
<pre>
UnaryExpression : ++ UnaryExpression
</pre>
</div>

<p>
    は、次のように評価されます。
</p>

<div class="pre-div">
<pre>
1. expr は、UnaryExpressionを評価した結果とする
2.次の条件が全て true である場合、SyntaxError例外を投げる(スローする)
・ReferenceであるType(expr) が、true
・IsStrictReference(expr) が、true
・Type(GetBase(expr)) が、Environment Record(環境レコード)
・GetReferencedName(expr) が、 "eval" または "arguments" の何れか
3. oldValue は、 ToNumber(GetValue(expr)) とする
4. newValue は、 + 演算子( 11.6.3 参照)であるものとして同様のルールを使って oldValue に1を加えたものを結果とする
5. PutValue(expr, newValue) を呼ぶ
6. newValue を返す
</pre>
</div>

<h3 id="x11.4.5">11.4.5 前置減分演算子<a href="#x11.4.5">#</a></h3>

<p>
    　プロダクション
</p>

<div class="pre-div">
<pre>
UnaryExpression : -- UnaryExpression
</pre>
</div>

<p>
    は、次のように評価されます。
</p>

<div class="pre-div">
<pre>
1. expr は、UnaryExpressionを評価した結果とする
2.次の条件が全て true である場合、SyntaxError例外を投げる(スローする)
・ReferenceであるType(expr) が、true
・IsStrictReference(expr) が、true
・Type(GetBase(expr)) が、環境レコード
・GetReferencedName(expr) が、 "eval" または "arguments" の何れか
3. oldValue は、 ToNumber(GetValue(expr)) とする
4. newValue は、その - 演算子( 11.6.3 参照)と同様のルールを使って oldValue から値 1 を引いた結果とする
5. PutValue(expr, newValue) を呼ぶ
6. newValue を返す
</pre>
</div>

<h3 id="x11.4.6">11.4.6 単項 + 演算子<a href="#x11.4.6">#</a></h3>

<p>
    　単項 + (加算)演算子は、当該オペランドをNumber型に変換します。
</p>

<p>
    　プロダクション
</p>

<div class="pre-div">
<pre>
UnaryExpression : + UnaryExpression
</pre>
</div>

<p>
    は、次のように評価されます。
</p>

<div class="pre-div">
<pre>
1. expr は、UnaryExpressionを評価した結果とする
2. ToNumber(GetValue(expr)) を返す
</pre>
</div>

<h3 id="x11.4.7">11.4.7 単項 - 演算子<a href="#x11.4.7">#</a></h3>

<p>
    　単項 - (減算)演算子は、当該オペランドをNumber型に変換し、それを否定します。
    注記として+0の否定は-0を生成し、-0の否定は+0を生成します。
</p>

<p>
    　プロダクション
</p>

<div class="pre-div">
<pre>
UnaryExpression : - UnaryExpression
</pre>
</div>

<p>
    は、次のように評価されます。
</p>

<div class="pre-div">
<pre>
1. expr は、UnaryExpressionを評価した結果とする
2. oldValue は、 ToNumber(GetValue(expr)) とする
3. oldValue が、NaNである場合、NaNを返す
4. oldValue を否定したものを結果として返す、つまり、同じ大きさであるNumber型の値を生成するが、符号は反対となるという意味
</pre>
</div>

<h3 id="x11.4.8">11.4.8 ビット単位の NOT 演算子 ( ~ )<a href="#x11.4.8">#</a></h3>

<p>
    　プロダクション
</p>

<div class="pre-div">
<pre>
UnaryExpression : ~ UnaryExpression
</pre>
</div>

<p>
    は、次のように評価されます。
</p>

<div class="pre-div">
<pre>
1. expr は、UnaryExpressionを評価した結果とする
2. oldValue は、 ToInt32(GetValue(expr)) とする
3. oldValueにビット単位の補数を適用した結果を返す、その結果は、符号付き 32ビット整数
</pre>
</div>

<h3 id="x11.4.9">11.4.9 論理 NOT 演算子 ( ! )<a href="#x11.4.9">#</a></h3>

<p>
    　プロダクション
</p>

<div class="pre-div">
<pre>
UnaryExpression : ! UnaryExpression
</pre>
</div>

<p>
    は、次のように評価されます。
</p>

<div class="pre-div">
<pre>
1. expr は、UnaryExpressionを評価した結果とする
2. oldValue は、 ToBoolean(GetValue(expr))とする
3. oldValue が、trueである場合、falseを返す
4. true を返す
</pre>
</div>


</article>
<article>


    <h2>11.5 乗法演算子 / Multiplicative Operators </h2>


    <h3 id="x11.5">11.5 乗法演算子<a href="#x11.5">#</a></h3>

    <div class="pre-div">
<pre>
【構文】
MultiplicativeExpression :
	UnaryExpression
	MultiplicativeExpression * UnaryExpression
	MultiplicativeExpression / UnaryExpression
	MultiplicativeExpression % UnaryExpression
</pre>
    </div>

    <div class="pre-div">
<pre>
【セマンティクス】

プロダクション @が上記定義内の演算子の1つに当てはまる MultiplicativeExpression : MultiplicativeExpression @ UnaryExpression は、次のように評価されます。

1. left は、MultiplicativeExpressionを評価した結果とする
2. leftValue は、 GetValue(left) とする
3. right は、UnaryExpressionを評価した結果とする
4. rightValue は、 GetValue(right) とする
5. leftNum は、 ToNumber(leftValue) とする
6. rightNum は、 ToNumber(rightValue) とする
7. leftNum と rightNum に指定した演算子(*, /, or %)を適用した結果を返す、11.5.1, 11.5.2, 11.5.3、それぞれの下にある注記参照。
</pre>
    </div>

    <h3 id="x11.5.1">11.5.1 * 演算子を適用<a href="#x11.5.1">#</a></h3>

    <p>
        　 * (乗算)演算子は、乗算を実行し、当該オペランドのプロダクションを生成します。
        乗算は、可換性(順序を入れ替えても結果が変わらない・順序の入れ替えが可能である性質)があります。
        乗算は、有限精度である為、常にECMAScript内で関連付けられるというわけではありません。
        浮動小数点の乗算の結果は、『IEEE 754 binary double-precision arithmetic / バイナリ(二進)倍精度演算』の規則によって規定されています。
    </p>
    <ul>
        <li>何れかのオペランドが、NaNである場合、その結果は、 NaNです。</li>
        <li>結果の符合は、双方のオペランドが、同じ符号を持つ場合、正、異なる符号を持つオペランドである場合、負です。</li>
        <li>ゼロによる無限大の乗算の結果は、NaNの中にあります(NaNです)</li>
        <li>無限大による無限大の乗算の結果は、無限大であり、その符号は、既に上記で述べた規則によって決定されます。</li>
        <li>非ゼロの値である無限大による無限大の乗算の結果は、符号付き無限大であり、その符号は、既に上記で述べた規則によって決定されます。</li>
        <li>無限大やNaNの何れかが関係する残りのケースについては、プロダクションが算出され、『IEEE 754 round-to-nearest mode /
            近似値への丸め(処理)モード』を使用して表示値に最も近い値に丸められ、大きさが、表示するには大きすぎる場合、その結果は、適切な符号から成る無限大、大きさが表示するには小さすぎる場合、その結果は、適切な符号から成る1つのゼロです。ECMAScript言語は、
            IEEE 754 によって定義したように漸次(的)アンダーフローのサポートを要求します。
        </li>
    </ul>

    <div class="pre-div">
<pre>
[付記]
*漸次(的) / gradualとは、「次第に」、「徐々に」、「だんだん」という意味。
*アンダーフローとは、四則演算や数学関数による演算結果が正規化された浮動小数点データ型数値における絶対値の最小範囲を下回る際に発生(、ちなみにオーバーフローは浮動小数点演算の丸め処理の結果、絶対値が表示上の最大有限数を超える際に発生)。
*漸次(的)アンダーフローとは、最小範囲を下回る際に正規化する際、わずかながら正規化しきれない範囲があり、その範囲においては微妙に精度が失われることがあることを指す。
</pre>
    </div>

    <h3 id="x11.5.2">11.5.2 / 演算子を適用<a href="#x11.5.2">#</a></h3>

    <p>
        　 / (除算)演算子は、除算を実行し、プロダクションは、当該オペランドの商を生成します。
        左オペランドは被除数、右オペランドは除数です。
        ECMAScriptは、整数除算を実行しません。
        オペランドと全ての除算操作の結果は、倍精度浮動小数点数です。
        除算の結果は、『IEEE 754 arithmetic / 演算』の仕様によって決められます。
    </p>
    <ul>
        <li>何れかのオペランドが、NaNである場合、その結果はNaNです。</li>
        <li>結果の符合は、両方のオペランドが同じ符号であれば正、異なる符号であれば負です。</li>
        <li>無限大による無限大の除算の結果はNaNの中にあります(NaNです)。</li>
        <li>ゼロによる無限大の除算の結果は、無限大の中にあり(無限大であり)、その符号は、既に上記で述べた規則によって決定されます。</li>
        <li>非ゼロの無限大の値による無限大の除算の結果は、符号付き無限大の中にあり(符号付き無限大であり)、その符号は、既に上記で述べた規則によって決定されます。</li>
        <li>無限大による有限の除算の結果は、ゼロの中にあり(ゼロであり)、その符号は、既に上記で述べた規則によって決定されます。</li>
        <li>ゼロによるゼロの除算の結果は、NaNの中にあり(NaNであり)、他の一部の無限大の値によるゼロの除算はゼロの中にあり(ゼロであり)、その符号は、既に上記で述べた規則によって決定されます。</li>
        <li>ゼロによる非ゼロの無限大の値の除算の結果は、符号付き無限大の中にあり(符号付き無限大であり)、その符号は、既に上記で述べた規則によって決定されます。</li>
        <li>無限大、ゼロ、NaNの何れかが含まれる残りのケースについては、 その商が算出され、『IEEE 754 round-to-nearest mode /
            近似値への丸め(処理)モード』を使用して表示値に最も近い値に丸められ、大きさが、表示するには大きすぎる場合、その操作はオーバーフローであり、その結果は、適切な符号から成る無限大、大きさが表示するには小さすぎる場合、その操作はアンダーフローであり、その結果は、適切な符号から成る1つのゼロです、ECMAScript言語は、
            IEEE 754 によって定義したように漸次(的)アンダーフローのサポートを要求します。
        </li>
    </ul>

    <h3 id="x11.5.3">11.5.3 % 演算子を適用<a href="#x11.5.3">#</a></h3>

    <p>
        　 % (剰余)演算子の暗黙的な除算から当該オペランドの残りをもたらし(剰余を生成し)、左オペランドは被除数、右オペランドは除数です。
    </p>

    <p>
        [注釈]
    </p>

    <p>
        　C/C++では、剰余演算子は、積分オペランドだけを許容しますが、ECMAScriptでは、浮動小数点オペランドも併せて許容します。
    </p>

    <p>
        　 % 演算子によって算出したものとする浮動小数点剰余演算子の結果は、 IEEE 754 で定義した"remainder"演算子と同一ではありません。
        丸め除算から剰余を算出する IEEE 754 の"remainder"演算子は、切り捨て除算ではなく、その為、その動作は、通常、整数剰余演算と同質ではありません。
        代わりにECMAScript言語は、Java の整数剰余演算子と類似した方法で動作する為の浮動小数点操作における % を定義します、尚、これはCライブラリ関数 fmod と比較される場合があります。
        ECMAScriptの浮動小数点剰余演算子の結果は、『IEEE arithmetic / 演算』によって決定されます。
    </p>
    <ul>
        <li>何れかのオペランドが、NaNである場合、その結果はNaNです。</li>
        <li>結果の符号は、除算の符号と同等です。</li>
        <li>被除数が無限大であったり、除数がゼロであったり、それら両方である場合、結果は、 NaNです。</li>
        <li>被除数が無限大かつ除数が無限大である場合、その結果は被除数と同等です。</li>
        <li>被除数がゼロで且つ除数が非ゼロで無限大である場合、その結果は、被除数と同等です。</li>
        <li>無限大、ゼロ、NaNの何れかが関係する残りのケースについては、除数 n と除数 d から成る浮動小数点剰余 r は、 n/d が負である場合に負、 n/d が正である場合に正であり、算出された n と d. r
            の数学的な商を真とする大きさを超えることなく可能な限り同じ大きさであり、『IEEE 754 round-to-nearest mode /
            近似値への丸め(処理)モード』を使用した表示値に最も近くなる丸め(処理)である整数 q という場合において数学的関係 r = n - (d x q) によって定義されます。
        </li>
    </ul>


</article>
<article>


    <h2>11.6 加法演算子 / Additive Operators </h2>


    <h3 id="x11.6">11.6 加法演算子<a href="#x11.6">#</a></h3>

    <div class="pre-div">
<pre>
【構文】
AdditiveExpression :
MultiplicativeExpression
AdditiveExpression + MultiplicativeExpression
AdditiveExpression - MultiplicativeExpression
</pre>
    </div>

    <h3 id="x11.6.1">11.6.1 加算演算子 ( + )<a href="#x11.6.1">#</a></h3>

    <p>
        　加算演算子は、文字列連結または数値加算の何れかを実行します。
    </p>

    <p>
        　プロダクション
    </p>

    <div class="pre-div">
<pre>
AdditiveExpression : AdditiveExpression + MultiplicativeExpression
</pre>
    </div>

    <p>
        は、次のように評価されます。
    </p>

    <div class="pre-div">
<pre>
1. lref は、 AdditiveExpressionを評価した結果とする
2. lval は、 GetValue(lref) とする
3. rref は、 MultiplicativeExpressionを評価した結果とする
4. rval は、 GetValue(rref) とする
5. lprim は、 ToPrimitive(lval) とする
6. rprim は、 ToPrimitive(rval) とする
7. Type(lprim) が、String、または、 Type(rprim) が、Stringである場合、
	a. ToString(rprim) によって続く ToString( lprim)を連結した結果であるStringを返す
8. ToNumber(lprim) と ToNumber(rprim) に加算演算子を適用した結果を返す、11.6.3 下段注釈参照
</pre>
    </div>

    <p>
        [注釈 1]
    </p>

    <p>
        　ステップ 5 と 6 で ToPrimitive を呼ぶ中で提供されるヒントは、何もありません。
        Dateオブジェクトを除く全てのネイティブなECMAScriptオブジェクトは、ヒント番号が与えられるかのようにヒントの欠如を扱います。
        Dateオブジェクトは、ヒントとなる文字列が与えられるかのようにヒントの欠如を扱います。
        ホストオブジェクトは、何らかの他の方法でヒントの欠如を扱う場合があります。
    </p>

    <p>
        [注釈 2]
    </p>

    <p>
        　ステップ 7 と論理AND演算子の代わりに論理OR演算子を使用することによる関係演算子( 11.8.5 )における比較アルゴリズムから成るステップ 3 とでは異なります。
    </p>

    <h3 id="x11.6.2">11.6.2 減算演算子 ( - )<a href="#x11.6.2">#</a></h3>

    <p>
        　プロダクション
    </p>

    <div class="pre-div">
<pre>
AdditiveExpression : AdditiveExpression - MultiplicativeExpression
</pre>
    </div>

    <p>
        は、次のように評価されます。
    </p>

    <div class="pre-div">
<pre>
1. lref は、 AdditiveExpressionを評価した結果とする
2. lval は、 GetValue(lref) とする
3. rref は、 MultiplicativeExpressionを評価した結果とする
4. rval は、 GetValue(rref) とする
5. lnum は、 ToNumber(lval) とする
6. rnum は、 ToNumber(rval) とする
7. lnum と rnum に減算演算子を適用したものを結果として返す、11.6.3 下段注釈参照
</pre>
    </div>

    <h3 id="x11.6.3">11.6.3 数字に加算演算子を適用<a href="#x11.6.3">#</a></h3>

    <div class="pre-div">
<pre>
 + 演算子は、オペランドの合計を生成する2つの数値型のオペランドに適用する場合、加算を実行します。
 - 演算子は、2つの数値オペランドの差を生成する減算を実行します。
</pre>
    </div>

    <p>
        　加算は、可換性のある演算子ですが、常にそのように想定するというわけではありません。
    </p>

    <p>
        　加算の結果は、『IEEE 754 binary double-precision arithmetic / バイナリ(二進)倍精度演算』の規則を使用して決められます。
    </p>
    <ul>
        <li>何れかのオペランドが、NaNである場合、その結果は、NaNです。</li>
        <li>反対の符号を持つ2つの無限大の合計は、NaNです。</li>
        <li>同じ符号を持つ2つの無限大の合計は、その符号を持つ無限大です。</li>
        <li>無限大と無限大の合計値は、無限大のオペランドと同等です。</li>
        <li>2つの負のゼロの合計は、-0です。2つの正のゼロの合計や反対の符号を持つ2つのゼロの合計は、+0です。</li>
        <li>ゼロと非ゼロの無限大の合計は、非ゼロのオペランドと同等です。</li>
        <li>同じ大きさで反対の符号を持つ2つの非ゼロの無限大の値は、+0です。</li>
        <li>無限大、ゼロ、NaNが関係する残りのケース、そしてまたオペランドが同じ符号を持っていたり、異なる大きさを持つ場合、その合計が算出され、『IEEE 754 round-to-nearest mode /
            近似値への丸め(処理)モード』を使って表示値に最も近い値に丸め(処理を行い)ます。もし、その大きさが表示値に対して大きすぎる場合には、その操作はオーバーフローであり、その結果は、適切な符号を持つ無限大です。ECMAScript言語は、
            IEEE 754 によって定義したように漸次(的)アンダーフローのサポートを要求します。
        </li>
    </ul>
    <p>
        　 - 演算子は、数値型の2つのオペランドに適用する場合に減算を実行し、そのオペランドの差を生成します。左オペランドは、被減数、右オペランドは、減数です。
        与えられた数値オペランド a と b において、それは a - b というケースは常に、 a + (-b) と同じ結果を生成します。
    </p>


</article>
<article>


    <h2>11.7 ビット単位シフト演算子 / Bitwise Shift Operators </h2>


    <h3 id="x11.7">11.7 ビット単位シフト演算子<a href="#x11.7">#</a></h3>

    <div class="pre-div">
<pre>
【構文】
ShiftExpression :
	AdditiveExpression ShiftExpression &lt;&lt; AdditiveExpression
	ShiftExpression &gt;&gt; AdditiveExpression
	ShiftExpression &gt;&gt;&gt; AdditiveExpression
</pre>
    </div>

    <h3 id="x11.7.1">11.7.1 左シフト演算子 ( &lt;&lt; )<a href="#x11.7.1">#</a></h3>

    <p>
        　右オペランドで指定された量だけ左オペランドについてバイト左シフト演算を実行。
    </p>

    <p>
        　プロダクション
    </p>

    <div class="pre-div">
<pre>
ShiftExpression : ShiftExpression &lt;&lt; AdditiveExpression
</pre>
    </div>

    <p>
        は、次のように評価されます。
    </p>

    <div class="pre-div">
<pre>
1. lref は、 ShiftExpressionを評価した結果とする
2. lval は、 GetValue(lref) とする
3. rref は、 AdditiveExpressionを評価した結果とする
4. rval は、 GetValue(rref) とする
5. lnum は、 ToInt32(lval) とする
6. rnum は、 ToUint32(rval) とする
7. shiftCount は、 rnum の全て、最下位5ビットをマスク設定した結果とする
   つまり計算 rnum &amp; 0x1F という意味
8. shiftCount ビット分 lnum を左シフトした結果を返す
   その結果は符号付き32ビット整数
</pre>
    </div>

    <h3 id="x11.7.2">11.7.2 符号付き右シフト演算子 / The Signed Right Shift Operator ( &gt;&gt; )<a href="#x11.7.2">#</a></h3>

    <p>
        　右オペランドで指定した量によって左オペランドについて符号付き(sign-filling)ビット単位右シフト演算を実行。
    </p>

    <p>
        　プロダクション
    </p>

    <div class="pre-div">
<pre>
ShiftExpression : ShiftExpression &gt;&gt; AdditiveExpression
</pre>
    </div>

    <p>
        は、次のように評価されます。
    </p>

    <div class="pre-div">
<pre>
1. lref は、 ShiftExpressionを評価した結果とする
2. lval は、 GetValue(lref) とする
3. rref は、 AdditiveExpressionを評価した結果とする
4. rval は、 GetValue(rref) とする
5. lnum は、 ToInt32(lval) とする
6. rnum は、 ToUint32(rval) とする
7. shiftCount は、 rnum の全て、最下位5ビットをマスク設定した結果とする
  つまり計算 rnum &amp; 0x1F という意味
8. shiftCount ビットで lnum の符号拡張右シフトを実行した結果を返す
  最も重要なビットが伝達される
  その結果は、符号付き32ビット整数
</pre>
    </div>

    <h3 id="x11.7.3">11.7.3 符号なし右シフト演算子 ( &gt;&gt;&gt; )<a href="#x11.7.3">#</a></h3>

    <p>
        　右オペランドで指定された量で左オペランドについてゼロ埋めビット単位右シフト演算を実行。
    </p>

    <p>
        　プロダクション
    </p>

    <div class="pre-div">
<pre>
ShiftExpression : ShiftExpression &gt;&gt;&gt; AdditiveExpression
</pre>
    </div>

    <p>
        は、次のように評価されます。
    </p>

    <div class="pre-div">
<pre>
1. lref は、 ShiftExpressionを評価した結果とする
2. lval は、 GetValue(lref) とする
3. rref は、 AdditiveExpressionを評価した結果とする
4. rval は、 GetValue(rref) とする
5. lnum は、 ToUint32(lval) とする
6. rnum は、 ToUint32(rval) とする
7. shiftCount は、 rnum の全て、最下位5ビットをマスク設定した結果とする
  つまり計算 rnum &amp; 0x1F という意味
8. shiftCount ビットで lnum のゼロ埋め右シフトを実行した結果を返す
  空いたビットはゼロで埋められる
  その結果は、符号なし32ビット整数
</pre>
    </div>


</article>
<article>


<h2>11.8 関係演算子 / Relational Operators </h2>


<h3 id="x11.8">11.8 関係演算子<a href="#x11.8">#</a></h3>

<div class="pre-div">
<pre>
【構文】
RelationalExpression :
	ShiftExpression
	RelationalExpression &lt; ShiftExpression
	RelationalExpression &gt; ShiftExpression
	RelationalExpression &lt;= ShiftExpression
	RelationalExpression &gt;= ShiftExpression
	RelationalExpression instanceof ShiftExpression
	RelationalExpression in ShiftExpression

RelationalExpressionNoIn :
	ShiftExpression
	RelationalExpressionNoIn &lt; ShiftExpression
	RelationalExpressionNoIn &gt; ShiftExpression
	RelationalExpressionNoIn &lt;= ShiftExpression
	RelationalExpressionNoIn &gt;= ShiftExpression
	RelationalExpressionNoIn instanceof ShiftExpression
</pre>
</div>

<p>
    [注釈]
</p>

<p>
    　"NoIn"変数は、ステートメント(文)内にある演算子内に持つ関係式の中にある演算子内で紛らわしさを回避する為に必要とされます。
</p>

<p>
    [注記：]"NoIn"だけに注釈原文↓自体に in を多用して、こういう風に紛らわしくならないようにという意味がある模様<br/>
    The "NoIn" variants are needed to avoid confusing the in operator in a relational expression with the in operator in
    a for statement.
</p>

<p>
    【セマンティクス】
</p>

<p>
    　関係演算子を評価した結果は、常にBoolean型であり、2つのオペランド間で保持する演算子によって名づけられた関係かどうかに影響します。
    RelationalExpressionNoIn
    プロダクションは、RelationalExpressionを含む代わりに評価されるRelationalExpressionNoInを含む場合を除き、RelationalExpressionプロダクションと同じ方法で評価されます。
</p>

<h3 id="x11.8.1">11.8.1 Less-than(より小さい・小なり) 演算子 ( &lt; )<a href="#x11.8.1">#</a></h3>

<p>
    　プロダクション
</p>

<div class="pre-div">
<pre>
RelationalExpression : RelationalExpression &lt; ShiftExpression
</pre>
</div>

<p>
    は、次のように評価されます。
</p>

<div class="pre-div">
<pre>
1. lref は、 RelationalExpressionを評価した結果とする
2. lval は、 GetValue(lref) とする
3. rref は、 ShiftExpressionを評価した結果とする
4. rval は、 GetValue(rref) とする
5. r は、抽象関係比較  lval &lt; rval ( 11.8.5 参照)を実行した結果とする
6. r が、undefinedである場合、falseを返す、それ以外は、r を返す
</pre>
</div>

<h3 id="x11.8.2">11.8.2 Greater-than(より大きい・大なり) 演算子 ( &gt; )<a href="#x11.8.2">#</a></h3>

<p>
    　プロダクション
</p>

<div class="pre-div">
<pre>
RelationalExpression : RelationalExpression &gt; ShiftExpression
</pre>
</div>

<p>
    は、次のように評価されます。
</p>

<div class="pre-div">
<pre>
1. lref は、 RelationalExpressionを評価した結果とする
2. lval は、 GetValue(lref) とする
3. rref は、 ShiftExpressionを評価した結果とする
4. rval は、 GetValue(rref) とする
5. r は、falseと同等の LeftFirst を伴う抽象関係比較 rval &lt; lval ( 11.8.5 参照)を実行した結果とする
6. r が、undefinedである場合、falseを返す、それ以外は、r を返す
</pre>
</div>

<h3 id="x11.8.3">11.8.3 Less-than-or-equal(以下) 演算子 ( &lt;= )<a href="#x11.8.3">#</a></h3>

<p>
    　プロダクション
</p>

<div class="pre-div">
<pre>
RelationalExpression : RelationalExpression &lt;= ShiftExpression
</pre>
</div>

<p>
    は、次のように評価されます。
</p>

<div class="pre-div">
<pre>
1. lref は、 RelationalExpressionを評価した結果とする
2. lval は、 GetValue(lref) とする
3. rref は、 ShiftExpressionを評価した結果とする
4. rval は、 GetValue(rref) とする
5. r は、falseと同等の LeftFirst を伴う抽象関係比較 rval &lt; lval ( 11.8.5 参照)を実行した結果とする
6. r が、trueまたはundefinedである場合、falseを返す、それ以外は、r を返す
</pre>
</div>

<h3 id="x11.8.4">11.8.4 Greater-than-or-equal(以上) 演算子 ( &gt;= )<a href="#x11.8.4">#</a></h3>

<p>
    　プロダクション
</p>

<div class="pre-div">
<pre>
RelationalExpression : RelationalExpression &gt;= ShiftExpression
</pre>
</div>

<p>
    は、次のように評価されます。
</p>

<div class="pre-div">
<pre>
1. lref は、 RelationalExpressionを評価した結果とする
2. lval は、 GetValue(lref) とする
3. rref は、 ShiftExpressionを評価した結果とする
4. rval は、 GetValue(rref) とする
5. r は、抽象関係比較 lval &lt; rval ( 11.8.5 参照)を実行した結果とする
6. r が、trueまたはundefinedである場合、falseを返す、それ以外は、true を返す
</pre>
</div>

<h3 id="x11.8.5">11.8.5 抽象関係比較のアルゴリズム<a href="#x11.8.5">#</a></h3>

<p>
    　値 x と y から成る比較 x &lt; y は、(少なくとも1つのオペランドがNaNを示す場合に)true、false、undefinedを生成します。
    x と y について追記するとアルゴリズムは、パラメータとして LeftFirst という名のBooleanフラグを取ります。
    当該フラグは、 x と y 上で実行される視覚的な副作用を潜在的に伴う操作において順番をコントロールする為に使用されます。
    ECMAScriptは、式を左から右へ評価する仕様なのでそれが必要となります。
    LeftFirst の既定値は、trueであり、 y パラメータの一致する式の左に現れる式と一致する x パラメータを示します。
    LeftFirst が、falseである場合、逆が、そのケースであり、操作は、x の前の y 上で実行されなければいけません。そのような比較は次のように実行されます。
</p>

<div class="pre-div">
<pre>
1. LeftFirst フラグが、trueである場合、
	a. px は、 ToPrimitive(x, hint Number) を呼んだ結果とする
	b. py は、 ToPrimitive(y, hint Number) を呼んだ結果とする
2.それ以外の場合、評価の順は、左から右への評価に優先して逆にさせる必要がある
	a. py は、 ToPrimitive(y, hint Number) を呼んだ結果とする
	b. px は、 ToPrimitive(x, hint Number) を呼んだ結果とする
3. Type(px) がStringで且つ Type(py) がStringというケースではない場合、
	a. nx は、 ToNumber(px) を呼んだ結果とする
	  理由はプリミティブ(原始的)な値である px と py の評価順は、重要ではない為
	b. ny は、 ToNumber(py) を呼んだ結果とする
	c. nx が、NaNである場合、undefinedを返す
	d. ny が、NaNである場合、undefinedを返す
	e. nx と ny が、同一のNumber値である場合、falseを返す
	f. nx が、 +0 且つ ny が、 -0である場合、falseを返す
	g. nx が、 -0 且つ ny が、 +0である場合、falseを返す
	h. nx が、+∞である場合、falseを返す
	i. ny が、+∞である場合、trueを返す
	j. nx が、-∞である場合、falseを返す
	k. ny が、-∞である場合、trueを返す
	l. nx　という数学的な値が、ny という数学的な値よりも小さい場合、(注記としてそれら数学的な値が共に無限大且つ共にゼロでない場合)、trueを返し、それ以外はfalseを返す
4.それ以外の場合、 px と py は、共に文字列であり、
	a. py が、 px の接頭辞である場合、falseを返す
	  ( q が、 p と他のString値 r を連結した結果となることが可能な場合、String値 p は、String値 q の接頭辞である。注釈として一部のStringは、 r がカラのString値に成り得る為、それ自身の接頭辞である。)
	b. px が、 py の接頭辞である場合、trueを返す
	c. k は、 py 内の位置 k にある文字とは異なる px 内の位置 k にある文字のように最小の非負の整数とする
	  (何れかのStringが他方の接頭辞である為、このように1つの k にしなければならない)
	d. m は、 px 内の位置 k にある文字におけるコードユニット値である整数とする
	e. n は、 py 内の位置 k にある文字におけるコードユニット値である整数とする
	f. m &lt; n である場合、trueを返し、そうではない場合、falseを返す
</pre>
</div>

<p>
    [注釈 1]
</p>

<p>
    　ステップ 3 は、その使用や代替等々といった意味では、加算演算子 + ( 11.6.1 )におけるアルゴリズム内のステップ 7 とは異なります。
</p>

<p>
    [注釈 2]
</p>

<p>
    　複数のStringの比較には、コードユニット値の並びにおける単純な辞書順を使用します。
    Unicode仕様上で定義した、より複雑な文字や文字列の同一性、照合順といったセマンティックス的な指向の定義を使用する為に試すことは何もありません。
    それゆえにUnicode標準規格による正規の等価性のあるString値は、等しくないものとしてテストすることが可能です。
    このアルゴリズムの効果において、正規形の中に両方のString値が既にあることを前提としています。
    また、補完文字を含む文字列についての追記として UTF-16 コードユニット値の並びにおける辞書順は、コードポイント値の並びにおける辞書順とは異なります。
</p>

<h3 id="x11.8.6">11.8.6 instanceof 演算子<a href="#x11.8.6">#</a></h3>

<p>
    　プロダクション
</p>

<div class="pre-div">
<pre>
RelationalExpression: RelationalExpression instanceof ShiftExpression
</pre>
</div>

<p>
    は、次のように評価されます。
</p>

<div class="pre-div">
<pre>
1. lref は、RelationalExpressionを評価した結果とする
2. lval は、 GetValue(lref) とする
3. rref は、ShiftExpressionを評価した結果とする
4. rval は、 GetValue(rref) とする
5. Type(rval) が、Objectではない場合、TypeError例外を投げる(スローする)
6. rval が、 [[HasInstance]] 内部メソッドを持たない場合、TypeError例外を投げる(スローする)
7.引数 lval を伴う rval の[[HasInstance]]内部メソッドを呼んだ結果を返す
</pre>
</div>

<h3 id="x11.8.7">11.8.7 in 演算子<a href="#x11.8.7">#</a></h3>

<p>
    　プロダクション
</p>

<div class="pre-div">
<pre>
RelationalExpression : RelationalExpression in ShiftExpression
</pre>
</div>

<p>
    は、次のように評価されます。
</p>

<div class="pre-div">
<pre>
1. lref は、RelationalExpressionを評価した結果とする
2. lval は、 GetValue(lref) とする
3. rref は、ShiftExpressionを評価した結果とする
4. rval は、 GetValue(rref) とする
5. Type(rval) が、Objectではない場合、TypeError例外を投げる(スローする)
6.引数 ToString(lval) を伴う rval の[[HasProperty]]内部メソッドを呼んだ結果を返す
</pre>
</div>


</article>
<article>


<h2>11.9 等価演算子 / Equality Operators </h2>


<h3 id="x11.9">11.9 等価演算子<a href="#x11.9">#</a></h3>

<div class="pre-div">
<pre>
【構文】
EqualityExpression :
	RelationalExpression
	EqualityExpression == RelationalExpression
	EqualityExpression != RelationalExpression
	EqualityExpression === RelationalExpression
	EqualityExpression !== RelationalExpression

EqualityExpressionNoIn :
	RelationalExpressionNoIn
	EqualityExpressionNoIn == RelationalExpressionNoIn
	EqualityExpressionNoIn != RelationalExpressionNoIn
	EqualityExpressionNoIn === RelationalExpressionNoIn
	EqualityExpressionNoIn !== RelationalExpressionNoIn
</pre>
</div>

<p>
    【セマンティックス】
</p>

<p>
    　等価演算子を評価した結果は、常に2つのオペランド間で保持する演算子によって名づけられた関係かどうかに影響するBoolean型です。
    EqualityExpressionNoIn プロダクションは、EqualityExpression と RelationalExpressionのそれぞれを含む代わりにEqualityExpressionNoIn と
    RelationalExpressionNoInを含んで評価される場合を除き、EqualityExpressionプロダクションと同じ方法で評価されます。
</p>

<h3 id="x11.9.1">11.9.1 等価演算子 ( == )<a href="#x11.9.1">#</a></h3>

<p>
    　プロダクション
</p>

<div class="pre-div">
<pre>
EqualityExpression : EqualityExpression == RelationalExpression
</pre>
</div>

<p>
    は、次のように評価されます。
</p>

<div class="pre-div">
<pre>
1. lref は、 EqualityExpressionを評価した結果とする
2. lval は、 GetValue(lref) とする
3. rref は、 RelationalExpressionを評価した結果とする
4. rval は、 GetValue(rref) とする
5.抽象等価比較  rval == lval ( 11.9.3 参照)を実行した結果を返す
</pre>
</div>

<h3 id="x11.9.2">11.9.2 不等号演算子 ( != )<a href="#x11.9.2">#</a></h3>

<p>
    　プロダクション
</p>

<div class="pre-div">
<pre>
EqualityExpression : EqualityExpression != RelationalExpression
</pre>
</div>

<p>
    は、次のように評価されます。
</p>

<div class="pre-div">
<pre>
1. lref は、EqualityExpressionを評価した結果とする
2. lval は、 GetValue(lref) とする
3. rref は、RelationalExpressionを評価した結果とする
4. rval は、 GetValue(rref) とする
5. r は、抽象等価比較  rval == lval ( 11.9.3 参照)を実行した結果とする
6. r が、trueである場合、falseを返し、それ以外の場合、trueを返す
</pre>
</div>

<h3 id="x11.9.3">11.9.3 抽象等価比較のアルゴリズム<a href="#x11.9.3">#</a></h3>

<p>
    　値 x と y における比較 x == y は、true または falseを生成します。
    このような比較は、次のように実行されます。
</p>

<div class="pre-div">
<pre>
1. Type(x) が、 Type(y)と同じである場合、
	a. Type(x) が、Undefinedである場合、trueを返す
	b. Type(x) が、Nullである場合、trueを返す
	c. Type(x) が、Numberである場合、
		i. x が、 NaNである場合、falseを返す
		ii. y が、 NaNである場合、falseを返す
		iii. x が、 yと同じNumber値である場合、trueを返す
		iv.  x が、 +0で且つ y が、-0である場合、trueを返す
		v. x が、 -0で且つ y が、+0である場合、trueを返す
		vi. falseを返す
	d. Type(x) が、Stringである場合、 x と y の文字の並びが全く同じ(一致する位置にある文字が同じ長さの同じ文字)である場合、true を返し、それ以外は、falseを返す
	e. Type(x) が、Booleanである場合、 x と y が共に true または、共に falseである場合、 true を返し、それ以外の場合、false を返す
	f. x と y が同じオブジェクトを参照する場合、true を返し、それ以外の場合、false を返す
2. x が、null且つ、 y がundefinedである場合、trueを返す
3. x が、undefined且つ、y がnullである場合、trueを返す
4. Type(x) が、Number且つ、 Type(y) が、Stringである場合、比較 x == ToNumber(y) の結果を返す
5. Type(x) が、String且つ、 Type(y) が、Numberである場合、比較 ToNumber(x) == y  の結果を返す
6. Type(x) が、Booleanである場合、比較 ToNumber(x) == y の結果を返す
7. Type(y) が、Booleanである場合、比較 x == ToNumber(y) の結果を返す
8. Type(x) が、Stringまたは、Numberであり、且つ Type(y) が、Objectである場合、比較 x == ToPrimitive(y) の結果を返す
9. Type(x) が、Object且つ Type(y) が、Stringまたは、Numberである場合、比較 ToPrimitive(x) == y の結果を返す
10. falseを返す
</pre>
</div>

<div class="pre-div">
<pre>
[注記 1]
等価についての上記定義について
String 比較は、 "" + a == "" + b によって有効にすることが可能です。
Numeric 比較は、 +a == +b によって有効にすることが可能です。
Boolean 比較は、 !a == !b によって有効にすることが可能です。

[注記 2]
等価演算子は、次の不変量を維持しています。
A != B は、 !(A == B) と等価です。
A == B は、 A と Bの評価順を除き B == A と等価です。

[注記 3]
等価演算子は、常に他動詞というわけではありません。
例えば、2つの異なるString型オブジェクトが、それぞれ同一のString値を表している場合、それぞれのString型オブジェクトは、 == 演算子によってString値と等価であると考えられそうな気がしますが、この場合、2つのString型オブジェクトは、それぞれ他方と等価にはなりません。
例えば、
・ new String("a") == "a" と "a" == new String("a") は、共に trueです。
・ new String("a") == new String("a") は、 falseです。

[注記 4]
複数のStringの比較は、単にコードユニット値の並びについて等価テストを使用します。
Unicode仕様上で定義した、より複雑な文字や文字列の同一性、照合順といったセマンティックス上の指向定義を使用する為に試すことは何もありません。
その為、Unicode標準規格による正規の等価性のあるString値は、等しくないものとしてテストすることが可能です。
このアルゴリズムの効果においては、正規形の中に両方のString値が既にあることを前提としています。
</pre>
</div>

<h3 id="x11.9.4">11.9.4 厳密な等価演算子 ( === )<a href="#x11.9.4">#</a></h3>

<p>
    　プロダクション
</p>

<div class="pre-div">
<pre>
EqualityExpression : EqualityExpression === RelationalExpression
</pre>
</div>

<p>
    は、次のように評価されます。
</p>

<div class="pre-div">
<pre>
1. lref は、EqualityExpressionを評価した結果とする
2. lval は、 GetValue(lref) とする
3. rref は、RelationalExpressionを評価した結果とする
4. rval は、 GetValue(rref) とする
5.厳密等価比較  rval === lval ( 11.9.6 参照)を実行した結果を返す
</pre>
</div>

<h3 id="x11.9.5">11.9.5 厳密な不等号演算子 ( !== )<a href="#x11.9.5">#</a></h3>

<p>
    　プロダクション
</p>

<div class="pre-div">
<pre>
EqualityExpression : EqualityExpression !== RelationalExpression
</pre>
</div>

<p>
    は、次のように評価されます。
</p>

<div class="pre-div">
<pre>
1. lref は、EqualityExpressionを評価した結果とする
2. lval は、 GetValue(lref) とする
3. rref は、RelationalExpressionを評価した結果とする
4. rval は、 GetValue(rref) とする
5. r は、厳密等価比較  rval === lval ( 11.9.6 参照)を実行した結果とする
6. r が、trueである場合、falseを返し、それ以外の場合、trueを返す
</pre>
</div>

<h3 id="x11.9.6">11.9.6 厳密等価比較のアルゴリズム<a href="#x11.9.6">#</a></h3>

<p>
    　値 x と y における比較 x === y は、 true または falseを生成します。
</p>

<p>
    　このような比較は次のように実行されます。
</p>

<div class="pre-div">
<pre>
1. Type(x) が、Type(y)と異なる場合、falseを返す
2. Type(x) が、Undefinedである場合、trueを返す
3. Type(x) が、Nullである場合、trueを返す
4. Type(x) が、Numberである場合、
	a. x が、 NaNである場合、 falseを返す
	b. y が、 NaNである場合、 falseを返す
	c. x が、 y と同一のNumber値である場合、 trueを返す
	d. x が、+0且つ、 y が、-0である場合、 trueを返す
	e. x が、-0且つ、 y が、+0である場合、 trueを返す
	f. falseを返す
5. Type(x) が、Stringである場合、 x と yが、全く同一の文字の並び(一致する位置にある文字が同じ長さの同じ文字)である場合、 trueを返し、それ以外の場合、falseを返す
6. Type(x) が、Booleanである場合、 x と yが、共に true または、共に falseである場合、 trueを返し、それ以外の場合、falseを返す
7. x と yが、同一のオブジェクトを参照する場合、 true を返し、それ以外の場合、falseを返す
</pre>
</div>

<p>
    [注釈]
</p>

<p>
    　このアルゴリズムは、その符号付きゼロとNaNの扱いの中にあるSameValueアルゴリズム(9.12)とは異なります。
</p>


</article>
<article>


    <h2>11.10 バイナリビット単位演算子 / Binary Bitwise Operators </h2>


    <h3 id="x11.10">11.10 バイナリビット単位演算子<a href="#x11.10">#</a></h3>

    <div class="pre-div">
<pre>
【構文】
BitwiseANDExpression :
	EqualityExpression
	BitwiseANDExpression &amp; EqualityExpression

BitwiseANDExpressionNoIn :
	EqualityExpressionNoIn
	BitwiseANDExpressionNoIn &amp; EqualityExpressionNoIn

BitwiseXORExpression :
	BitwiseANDExpression
	BitwiseXORExpression ^ BitwiseANDExpression

BitwiseXORExpressionNoIn :
	BitwiseANDExpressionNoIn
	BitwiseXORExpressionNoIn ^ BitwiseANDExpressionNoIn

BitwiseORExpression :
	BitwiseXORExpression
	BitwiseORExpression | BitwiseXORExpression

BitwiseORExpressionNoIn :
	BitwiseXORExpressionNoIn
	BitwiseORExpressionNoIn | BitwiseXORExpressionNoIn
</pre>
    </div>

    <p>
        【セマンティックス】
    </p>

    <p>
        　@ が上記プロダクション内にあるビット単位演算子の1つである場合、プロダクション A : A @ B は、次のように評価されます。
    </p>

    <div class="pre-div">
<pre>
1. lref は、 A を評価した結果とする
2. lval は、 GetValue(lref) とする
3. rref は、 B を評価した結果とする
4. rval は、 GetValue(rref) とする
5. lnum は、 ToInt32(lval) とする
6. rnum は、 ToInt32(rval) とする
7.ビット単位演算子@を lnum と rnum に適用した結果を返す、その結果は、1つの符号付き32ビット整数
</pre>
    </div>


</article>
<article>


    <h2>11.11 バイナリ論理演算子 / Binary Logical Operators </h2>


    <h3 id="x11.11">11.11 バイナリ論理演算子<a href="#x11.11">#</a></h3>

    <div class="pre-div">
<pre>
【構文】
LogicalANDExpression :
	BitwiseORExpression
	LogicalANDExpression &amp;&amp; BitwiseORExpression

LogicalANDExpressionNoIn :
	BitwiseORExpressionNoIn
	LogicalANDExpressionNoIn &amp;&amp; BitwiseORExpressionNoIn

LogicalORExpression :
	LogicalANDExpression
	LogicalORExpression || LogicalANDExpression

LogicalORExpressionNoIn :
	LogicalANDExpressionNoIn
	LogicalORExpressionNoIn || LogicalANDExpressionNoIn
</pre>
    </div>

    <p>
        【セマンティックス】
    </p>

    <p>
        　プロダクション
    </p>

    <div class="pre-div">
<pre>
LogicalANDExpression : LogicalANDExpression &amp;&amp; BitwiseORExpression
</pre>
    </div>

    <p>
        は、次のように評価されます。
    </p>

    <div class="pre-div">
<pre>
1. lref は、LogicalANDExpressionを評価した結果とする
2. lval は、 GetValue(lref) とする
3. ToBoolean(lval) が、falseである場合、 lval を返す
4. rref は、BitwiseORExpressionを評価した結果とする
5. GetValue(rref) を返す
</pre>
    </div>

    <p>
        　プロダクション
    </p>

    <div class="pre-div">
<pre>
LogicalORExpression : LogicalORExpression || LogicalANDExpression
</pre>
    </div>

    <p>
        は、次のように評価されます。
    </p>

    <div class="pre-div">
<pre>
1. lref は、LogicalORExpressionを評価した結果とする
2. lval は、 GetValue(lref) とする
3. ToBoolean(lval) が、 trueである場合、 lvalを返す
4. rref は、LogicalANDExpressionを評価した結果とする
5. GetValue(rref) を返す
</pre>
    </div>

    <p>
        　LogicalANDExpressionNoInとLogicalORExpressionNoInプロダクションは、LogicalANDExpression、BitwiseORExpression、LogicalORExpressionをそれぞれ含む代わりにLogicalANDExpressionNoIn、BitwiseORExpressionNoIn、LogicalORExpressionNoInを含んで評価される場合を除き、
        LogicalANDExpression と LogicalORExpression と同じ方法で評価されます。
    </p>

    <p>
        [注釈]
    </p>

    <p>
        　 &amp;&amp; や || 演算子によって生成した値は、Boolean型である必要はありません。
        生成した値は、常に2つのオペランドの内の一方の値になります。
    </p>


</article>
<article>


    <h2>11.12 条件演算子 ( ? : ) / Conditional Operator </h2>


    <h3 id="x11.12">11.12 条件演算子 ( ? : )<a href="#x11.12">#</a></h3>

    <div class="pre-div">
<pre>
【構文】
ConditionalExpression :
	LogicalORExpression
	LogicalORExpression ? AssignmentExpression : AssignmentExpression

ConditionalExpressionNoIn :
	LogicalORExpressionNoIn
	LogicalORExpressionNoIn ? AssignmentExpression : AssignmentExpressionNoIn
</pre>
    </div>

    <p>
        【セマンティックス】
    </p>

    <p>
        　プロダクション
    </p>

    <div class="pre-div">
<pre>
ConditionalExpression : LogicalORExpression ? AssignmentExpression : AssignmentExpression
</pre>
    </div>

    <p>
        は、次のように評価されます。
    </p>

    <div class="pre-div">
<pre>
1. lref は、LogicalORExpressionを評価した結果とする
2. ToBoolean(GetValue(lref)) が、 trueである場合、
	a. trueRef は、AssignmentExpressionを評価した結果とする
	b. GetValue(trueRef) を返す
3.それ以外の場合、
	a. falseRef は、2つめのAssignmentExpressionを評価した結果とする
	b. GetValue(falseRef) を返す
</pre>
    </div>

    <p>
        　ConditionalExpressionNoInプロダクションは、LogicalORExpression、1つめのAssignmentExpression、2つめのAssignmentExpressionをそれぞれ含む代わりにLogicalORExpressionNoIn、AssignmentExpression
        、AssignmentExpressionNoInを含んで評価される場合を除き、ConditionalExpressionと同じ方法で評価されます。
    </p>

    <p>
        [注釈]
    </p>

    <p>
        　ECMAScript内のConditionalExpression(条件式)における文法は、2つめの副次式がExpression(式)とすることを許容する一方、3つめの式については、ConditionalExpressionにすることを制限する
        C や Java での場合とは、ほんの少しばかり異なります。
        ECMAScript内のこの相違における動機は、条件の一方(arm of a
        conditional)だけを有効にする場合、紛らわしさを排除したい場合、中央の式の大部分が、かなり無駄なカンマ式である場合の何れかによって規定される式の指定を許容する為です。
    </p>


</article>
<article>


    <h2>11.13 代入演算子 / Assignment Operators </h2>


    <h3 id="x11.13">11.13 代入演算子<a href="#x11.13">#</a></h3>

    <div class="pre-div">
<pre>
【構文】
AssignmentExpression :
	ConditionalExpression
	LeftHandSideExpression = AssignmentExpression
	LeftHandSideExpression AssignmentOperator AssignmentExpression

AssignmentExpressionNoIn :
	ConditionalExpressionNoIn
	LeftHandSideExpression = AssignmentExpressionNoIn
	LeftHandSideExpression AssignmentOperator AssignmentExpressionNoIn

AssignmentOperator :

 *= /= %= += -= &lt;&lt;= &gt;&gt;= &gt;&gt;&gt;= &amp;= ^= |=

の何れか1つ
</pre>
    </div>

    <p>
        【セマンティックス】
    </p>

    <p>
        　AssignmentExpressionNoIn プロダクションは、ConditionalExpression と AssignmentExpressionを含む代わりにConditionalExpressionNoIn
        と AssignmentExpressionNoInを含んで評価される場合を除き、AssignmentExpressionプロダクションと同じ方法で評価されます。
    </p>

    <h3 id="x11.13.1">11.13.1 単純な代入 ( = )<a href="#x11.13.1">#</a></h3>

    <p>
        　プロダクション
    </p>

    <div class="pre-div">
<pre>
AssignmentExpression : LeftHandSideExpression = AssignmentExpression
</pre>
    </div>

    <p>
        は、次のように評価されます。
    </p>

    <div class="pre-div">
<pre>
1. lref は、LeftHandSideExpressionを評価した結果とする
2. rref は、AssignmentExpressionを評価した結果とする
3. rval は、 GetValue(rref) とする
4.次の条件が全て trueである場合、SyntaxError例外を投げる(スローする)
・ReferenceであるType(lref) が、true
・IsStrictReference(lref) が、 true
・Type(GetBase(lref)) が、環境レコード
・GetReferencedName(lref) が、 "eval" または "arguments"の何れか
5. PutValue(lref, rval) を呼ぶ
6. rval を返す
</pre>
    </div>

    <p>
        [注釈]
    </p>

    <p>
        　strictモードのコード内に代入が現れる場合、その LeftHandSide (左辺)については、未解決の参照を評価してはいけません。
        ReferenceError例外とする場合には、代入について投げます(スローします)。
        LeftHandSide はまた、属性値 {[[Writable]]:false}を伴うデータプロパティ、属性値
        {[[Set]]:undefined}を伴うアクセサプロパティ、値falseを持つ[[Extensible]]内部プロパティであるオブジェクトの存在しない(non-existent)プロパティなどについては参照しない場合があります。
        これらのケースについては、TypeError例外が投げられます(スローされます)。
    </p>

    <h3 id="x11.13.2">11.13.2 複雑な代入 ( op= )<a href="#x11.13.2">#</a></h3>

    <p>
        　AssignmentOperatorが、上記で示された演算子の1つを表す @= と @ である場合、
    </p>

    <p>
        　プロダクション
    </p>

    <div class="pre-div">
<pre>
AssignmentExpression : LeftHandSideExpression AssignmentOperator AssignmentExpression
</pre>
    </div>

    <p>
        は、次のように評価されます。
    </p>

    <div class="pre-div">
<pre>
1. lref は、LeftHandSideExpressionを評価した結果とする
2. lval は、 GetValue(lref) とする
3. rref は、AssignmentExpressionを評価した結果とする
4. rval は、 GetValue(rref) とする
5. r は、 lval と rval に演算子 @ を適用した結果とする
6.次の条件が全て trueである場合、SyntaxError例外を投げる(スローする)
・ReferenceであるType(lref) が、 true
・IsStrictReference(lref) が、 true
・Type(GetBase(lref)) が、 Environment Record(環境レコード)
・GetReferencedName(lref) が、 "eval" または "arguments"の何れか
7. PutValue(lref, r) を呼ぶ
8. r を返す
</pre>
    </div>

    <p>
        [注釈]
    </p>

    <p>
        　11.13.1の注釈参照
    </p>


</article>
<article>


    <h2>11.14 カンマ演算子 ( , ) / Comma Operator </h2>


    <h3 id="x11.14">11.14 カンマ演算子 ( , )<a href="#x11.14">#</a></h3>

    <div class="pre-div">
<pre>
【構文】
Expression :
	AssignmentExpression Expression , AssignmentExpression

ExpressionNoIn :
	AssignmentExpressionNoIn ExpressionNoIn , AssignmentExpressionNoIn
</pre>
    </div>

    <p>
        【セマンティックス】
    </p>

    <p>
        　プロダクション
    </p>

    <div class="pre-div">
<pre>
Expression : Expression , AssignmentExpression
</pre>
    </div>

    <p>
        は、次のように評価されます。
    </p>

    <div class="pre-div">
<pre>
1. lref は、Expressionを評価した結果とする
2. GetValue(lref) を呼ぶ
3. rref は、AssignmentExpressionを評価した結果とする
4. GetValue(rref) を返す
</pre>
    </div>

    <p>
        　ExpressionNoInは、Expression と AssignmentExpressionのそれぞれを含む代わりにExpressionNoIn と
        AssignmentExpressionNoInを含んで評価される場合を除き、Expressionプロダクションと同じ方法で評価されます。
    </p>

    <p>
        [注釈]
    </p>

    <p>
        　GetValueは、観測可能な副作用を持つ場合がある為、その値が使用されない場合でさえ呼ばれなければいけません。
    </p>


</article>
<article>


    <h2>12 文 / Statements </h2>

    





<pre>
【構文】
Statement :
	Block
	VariableStatement
	EmptyStatement
	ExpressionStatement
	IfStatement
	IterationStatement
	ContinueStatement
	BreakStatement
	ReturnStatement
	WithStatement
	LabelledStatement
	SwitchStatement
	ThrowStatement
	TryStatement
	DebuggerStatement
</pre>

    <p>
        【セマンティックス】
    </p>

    <p>
        　Statement(文)は、それ自身をLabelledStatement(ラベル付きの文)の一部とすることが可能等々といったようにLabelledStatementの一部とすることが可能です。
        この方法を導入したラベルは、個別の文のセマンティクスを説明する場合に"現在のラベルのセット(集合)"といったようにひとまとめに参照されます。
        LabelledStatementには、任意のラベル集合へのラベルの導入以外のセマンティック上の意味合いはありません。
        IterationStatement (反復文)や SwitchStatement (Switch文)のラベルのセットは、最初は1つのカラの要素を含みます。
        他の文のラベルのセットは、最初はカラです。
    </p>

    <p>
        　Statementを評価した結果は、常にCompletion(完了)値です。

    <p>
        [注釈]
    </p>

    <p>
        　ECMAScriptの実装を使用した一部の拡張は、文としてFunctionDeclaration(関数宣言)の使用をサポートすることが知られています。
        しかしながら、FunctionDeclarationsのように適用したセマンティクスについては、実装間において重大かつ両立し得ないバリエーションがあります。
        これらの理由は、コード内のStatement結果としてのFunctionDeclarationの使用は、実装間での移植が確実でないという点から、その相違は相容れないからです。
        ECMAScriptの実装においては、FunctionDeclarationの使用を禁ずるか、このような使用方法と遭遇した場合に警告を発することが推奨されます。
        ECMAScriptの将来のエディション(版)では、Statementコンテキスト内で定義した関数における意味を移植する選択肢を定義するかもしれません。
    </p>
    </p>

    <p><a href="http://www.webzoit.net/hp/it/internet/homepage/script/ecmascript/ecma262_51/contents/12/12_1/"
          title="ブロック">12.1 ブロック</a></p>

    <p><a href="http://www.webzoit.net/hp/it/internet/homepage/script/ecmascript/ecma262_51/contents/12/12_2/"
          title="変数文">12.2 変数文</a></p>

    <p><a href="http://www.webzoit.net/hp/it/internet/homepage/script/ecmascript/ecma262_51/contents/12/12_3/"
          title="空(カラ)文">12.3 空(カラ)文</a>
    </p>

    <p><a href="http://www.webzoit.net/hp/it/internet/homepage/script/ecmascript/ecma262_51/contents/12/12_4/"
          title="式文">12.4 式文</a></p>

    <p><a href="http://www.webzoit.net/hp/it/internet/homepage/script/ecmascript/ecma262_51/contents/12/12_5/"
          title=" if 文">12.5 if 文</a></p>

    <p><a href="http://www.webzoit.net/hp/it/internet/homepage/script/ecmascript/ecma262_51/contents/12/12_6/"
          title="反復文">12.6 反復文</a></p>

    <p><a href="http://www.webzoit.net/hp/it/internet/homepage/script/ecmascript/ecma262_51/contents/12/12_7/"
          title=" continue 文">12.7
        continue 文</a></p>

    <p><a href="http://www.webzoit.net/hp/it/internet/homepage/script/ecmascript/ecma262_51/contents/12/12_8/"
          title=" break 文">12.8 break
        文</a></p>

    <p><a href="http://www.webzoit.net/hp/it/internet/homepage/script/ecmascript/ecma262_51/contents/12/12_9/"
          title=" return 文">12.9 return
        文</a></p>

    <p><a href="http://www.webzoit.net/hp/it/internet/homepage/script/ecmascript/ecma262_51/contents/12/12_10/"
          title=" with 文">12.10 with
        文</a></p>

    <p><a href="http://www.webzoit.net/hp/it/internet/homepage/script/ecmascript/ecma262_51/contents/12/12_11/"
          title=" switch 文">12.11 switch
        文</a></p>

    <p><a href="http://www.webzoit.net/hp/it/internet/homepage/script/ecmascript/ecma262_51/contents/12/12_12/"
          title="ラベル付き文">12.12
        ラベル付き文</a></p>

    <p><a href="http://www.webzoit.net/hp/it/internet/homepage/script/ecmascript/ecma262_51/contents/12/12_13/"
          title=" throw 文">12.13 throw
        文</a></p>

    <p><a href="http://www.webzoit.net/hp/it/internet/homepage/script/ecmascript/ecma262_51/contents/12/12_14/"
          title=" try 文">12.14 try 文</a>
    </p>

    <p><a href="http://www.webzoit.net/hp/it/internet/homepage/script/ecmascript/ecma262_51/contents/12/12_15/"
          title=" debugger 文">12.15
        debugger 文</a></p>


</article>
<article>


    <h2>12.1 ブロック / Block </h2>


    <h3 id="x12.1">12.1 ブロック<a href="#x12.1">#</a></h3>

<pre>
【構文】
Block :
	{ StatementListopt }

StatementList :
	Statement
	StatementList Statement
</pre>

    <p>
        【セマンティックス】
    </p>

    <p>
        　プロダクション Block : { } は、次のように評価されます。
    </p>

    <div class="pre-div">
<pre>
1.return (normal, empty, empty)
</pre>
    </div>

    <p>
        　プロダクション Block : { StatementList } は、次のように評価されます。
    </p>

    <div class="pre-div">
<pre>
1.StatementListを評価した結果を返す
</pre>
    </div>

    <p>
        　プロダクション StatementList : Statement は、次のように評価されます。
    </p>

    <div class="pre-div">
<pre>
1. s は、Statementを評価した結果とする
2.例外が投げられた(スローされた)場合、V は例外である return (throw, V, empty) とする(スローされた例外が何もないかのように現在の処理を実行)
3. s を返す
</pre>
    </div>

    <p>
        　プロダクション StatementList : StatementList Statement は、次のように評価されます。
    </p>

    <div class="pre-div">
<pre>
1. sl は、StatementListを評価した結果とする
2. sl が、中途完了(an abrupt completion)である場合、 slを返す
3. s は、Statementを評価した結果とする
4.例外が投げられた(スローされた)場合、V は例外である return (throw, V, empty) とする(スローされた例外が何もないかのように現在の処理を実行)
5. s.value が、emptyである場合、 V = sl.value とし、それ以外の場合、 V = s.value とする
6.return (s.type, V, s.target)
</pre>
    </div>

    <p>
        [注釈]
    </p>

    <p>
        　StatementListの値を確保する上記アルゴリズムのステップ 5 と 6 は、StatementList内で最後の値を生成したStatementの値です。
        例えば、次は、全て値 1 を返す eval 関数を呼びます。
    </p>

<pre>
eval("1;;;;;")
eval("1;{}")
eval("1;var a;")
</pre>


</article>
<article>


    <h2>12.2 変数ステートメント / Variable Statement </h2>


    <h3 id="x12.2">12.2 変数ステートメント<a href="#x12.2">#</a></h3>

    <div class="pre-div">
<pre>
【構文】
VariableStatement :
	var VariableDeclarationList ;

VariableDeclarationList :
	VariableDeclaration
	VariableDeclarationList , VariableDeclaration

VariableDeclarationListNoIn :
	VariableDeclarationNoIn
	VariableDeclarationListNoIn , VariableDeclarationNoIn

VariableDeclaration :
	Identifier Initialiseropt

VariableDeclarationNoIn :
	Identifier InitialiserNoInopt

Initialiser :
	= AssignmentExpression

InitialiserNoIn :
	= AssignmentExpressionNoIn
</pre>
    </div>

    <p>
        　変数ステートメントは、10.5 で定義したように生成される変数を宣言します。
        変数は、生成される場合、Undefined(未定義)として初期化されます。
        イニシャライザーを伴う変数は、その変数が生成される際ではなく、VariableStatementが実行される際に当該AssignmentExpressionの値を関連付けられます。
    </p>

    <p>
        【セマンティックス】
    </p>

    <p>
        　プロダクション VariableStatement : var VariableDeclarationList ; は、次のように評価されます。
    </p>

    <div class="pre-div">
<pre>
1.VariableDeclarationListを評価
2.return (normal, empty, empty)
</pre>
    </div>

    <p>
        　プロダクション VariableDeclarationList :VariableDeclaration は、次のように評価されます。
    </p>

    <div class="pre-div">
<pre>
1.VariableDeclarationを評価
</pre>
    </div>

    <p>
        　プロダクション VariableDeclarationList : VariableDeclarationList , VariableDeclaration は、次のように評価されます。
    </p>

    <div class="pre-div">
<pre>
1.VariableDeclarationListを評価
2.VariableDeclarationを評価
</pre>
    </div>

    <p>
        　プロダクション VariableDeclaration : Identifier は、次のように評価されます。
    </p>

    <div class="pre-div">
<pre>
1.識別子(Identifier)内にあるものと文字の並びが同じものを含むString値を返す
</pre>
    </div>

    <p>
        　プロダクション VariableDeclaration : Identifier Initialiser は、次のように評価されます。
    </p>

    <div class="pre-div">
<pre>
1. lhs は、11.1.2で定義したようにIdentifier(識別子)を評価した結果とする
2. rhs は、Initialiser(イニシャライザー)を評価した結果とする
3. value は、 GetValue(rhs) とする
4. PutValue(lhs, value) を呼ぶ
5.識別子(Identifier)内にあるものと文字の並びが同じものを含むString値を返す
</pre>
    </div>

    <p>
        [注釈]
    </p>

    <p>
        　VariableDeclaration(変数宣言)のString値は、 for-in 文(12.6.4)の評価の中で使用されます。
    </p>

    <p>
        　VariableDeclarationが、文を伴って内側にネストされたり、VariableDeclaration内の識別子が文のオブジェクト型環境レコードを伴うバインディングオブジェクトのプロパティ名と同名である場合には、ステップ4は、当該識別子のVariableEnvironmentバインディングへの代わりにプロパティに値を関連付けるでしょう。
    </p>

    <p>
        プロダクション Initialiser : = AssignmentExpression は、次のように評価されます。
    </p>

    <div class="pre-div">
<pre>
1.VariableEnvironmentを評価した結果を返す
</pre>
    </div>

    <p>
        　VariableDeclarationListNoIn、VariableDeclarationNoIn、InitialiserNoInは、VariableDeclarationList、VariableDeclaration、Initialiser
        、AssignmentExpressionのそれぞれ含む代わりにVariableDeclarationListNoIn、VariableDeclarationNoIn、InitialiserNoIn、AssignmentExpressionNoInを含んで評価される場合を除き、VariableDeclarationList、VariableDeclaration、Initialiserプロダクションと同じ方法で評価されます。
    </p>


    <h3 id="x12.2.1">12.2.1 Strict(厳格)モードの制限・制約<a href="#x12.2.1">#</a></h3>

    <p>
        　VariableDeclaration や VariableDeclarationNoIn が、strictコード内に現れたり、当該識別子が "eval" や
        "arguments"である場合には、SyntaxErrorです。
    </p>


</article>
<article>


    <h2>12.3 空文・カラ文 / Empty Statement </h2>


    <h3 id="x12.3">12.3 空文・カラ文 / Empty Statement<a href="#x12.3">#</a></h3>

<pre>
【構文】

EmptyStatement :
	;
</pre>

    <p>
        【セマンティックス】
    </p>

    <p>
        　プロダクション EmptyStatement : ; は、次のように評価されます。
    </p>

    <div class="pre-div">
<pre>
1. return (normal, empty, empty)
</pre>
    </div>


</article>
<article>


    <h2>12.4 式ステートメント / Expression Statement </h2>


    <h3 id="x12.4">12.4 式ステートメント<a href="#x12.4">#</a></h3>

    <div class="pre-div">
<pre>
【構文】
ExpressionStatement :
[lookahead ? {{, function}] Expression ;
</pre>
    </div>

    <p>
        [注釈]
    </p>

    <p>
        　ExpressionStatement(式の文)は、ブロックとの曖昧さを作り出す可能性があるので開始波カッコ "{" を伴って始めることはできません。
        また、ExpressionStatementは、FunctionDeclaration(関数宣言)との曖昧さを作り出す可能性があるのでfunctionキーワードを伴って始めることはできません
    </p>

    <p>
        【セマンティックス】
    </p>

    <p>
        　プロダクション
    </p>

    <div class="pre-div">
<pre>
ExpressionStatement : [lookahead ? {{, function}] Expression;
( ? は、∈ の否定形)
</pre>
    </div>

    <p>
        は、次のように評価されます。
    </p>

    <div class="pre-div">
<pre>
1. exprRef は、Expressionを評価した結果とする
2. return (normal, GetValue(exprRef), empty)
</pre>
    </div>


</article>
<article>


    <h2>12.5 if 文 / The if Statement </h2>


    <h3 id="x12.5">12.5 if 文<a href="#x12.5">#</a></h3>

    <div class="pre-div">
<pre>
【構文】
IfStatement :
	if ( Expression ) Statement else Statement
	if ( Expression ) Statement
</pre>
    </div>

    <p>
        　それぞれ他のどのifに関連する選択なのかが曖昧である場合は、他に何も一致するものがないという場合を除き、可能な限り最も近いものと関連させるようにしましょう。
    </p>

    <p>
        【セマンティックス】
    </p>

    <p>
        　プロダクション
    </p>

    <div class="pre-div">
<pre>
IfStatement : if ( Expression ) Statement else Statement
</pre>
    </div>

    <p>
        は、次のように評価されます。
    </p>

    <div class="pre-div">
<pre>
1. exprRef は、Expressionを評価した結果とする
2. ToBoolean(GetValue(exprRef)) が、 trueである場合、
	a.1つめの文を評価した結果を返す
3.それ以外の場合、
	a.2つめの文を評価した結果を返す
</pre>
    </div>

    <p>
        　プロダクション
    </p>

    <div class="pre-div">
<pre>
IfStatement : if ( Expression ) Statement
</pre>
    </div>

    <p>
        は、次のように評価されます。
    </p>

    <div class="pre-div">
<pre>
1. exprRef は、Expressionを評価した結果とする
2. ToBoolean(GetValue(exprRef)) が、 falseである場合、 return (normal, empty, empty)
3. Statementを評価した結果を返す
</pre>
    </div>


</article>
<article>


<h2>12.6 反復ステートメント / Iteration Statements </h2>


<h3 id="x12.6">12.6 反復ステートメント<a href="#x12.6">#</a></h3>

<div class="pre-div">
<pre>
【構文】
IterationStatement :
	do Statement while ( Expression );
	while ( Expression ) Statement
	for (ExpressionNoInopt; Expressionopt ; Expressionopt ) Statement
	for ( var VariableDeclarationListNoIn; Expressionopt ; Expressionopt ) Statement
	for ( LeftHandSideExpression in Expression ) Statement
	for ( var VariableDeclarationNoIn in Expression ) Statement
</pre>
</div>

<h3 id="x12.6.1">12.6.1 do-while 文<a href="#x12.6.1">#</a></h3>

<p>
    　プロダクション
</p>

<div class="pre-div">
<pre>
do Statement while ( Expression );
</pre>
</div>

<p>
    は、次のように評価されます。
</p>

<div class="pre-div">
<pre>
1. V = empty とする
2. iteratingは、trueとする
3. iteratingが、trueの間、繰り返し
	a. stmt は、Statementを評価した結果とする
	b. stmt.value が、emptyではない場合、 V = stmt.valueとする
	c. stmt.type が、continueでない、または、 stmt.target が、現在のラベルのセットではない場合、
		i. stmt.type が、breakで且つ、 stmt.target が現在のラベルのセットである場合、return (normal, V, empty)
		ii. stmt が、途中完了(an abrupt completion)である場合、 stmt を返す
	d. exprRef は、Expressionを評価した結果とする
	e. ToBoolean(GetValue(exprRef)) が、falseである場合、iteratingにfalseを設定
4. return (normal, V, empty)
</pre>
</div>

<h3 id="x12.6.2">12.6.2 while 文<a href="#x12.6.2">#</a></h3>

<p>
    　プロダクション
</p>

<div class="pre-div">
<pre>
IterationStatement : while ( Expression ) Statement
</pre>
</div>

<p>
    は、次のように評価されます。
</p>

<div class="pre-div">
<pre>
1. V = empty とする
2.繰り返す
	a. exprRef は、Expressionを評価した結果とする
	b. ToBoolean(GetValue(exprRef)) が、 falseである場合、return (normal, V, empty)
	c. stmt は、Statementを評価した結果とする
	d. stmt.value が、emptyではない場合、 V = stmt.value とする
	e. stmt.type が、continueでない、または、 stmt.target が、現在のラベルのセットではない場合、
		i. stmt.type が、breakで且つ、 stmt.target が、現在のラベルのセット内にある場合、
			1. return (normal, V, empty)
		ii. stmt が、途中完了(an abrupt completion)である場合、 stmt を返す
</pre>
</div>

<h3 id="x12.6.3">12.6.3 for 文<a href="#x12.6.3">#</a></h3>

<p>
    　プロダクション
</p>

<div class="pre-div">
<pre>
IterationStatement : for (ExpressionNoInopt ; Expressionopt ; Expressionopt) Statement
</pre>
</div>

<p>
    は、次のように評価されます。
</p>

<div class="pre-div">
<pre>
1. ExpressionNoIn が存在する場合、
	a. exprRef は、ExpressionNoInを評価した結果とする
	b. GetValue(exprRef)を呼ぶ(この値は使われないが、副作用を持つ場合がある)
2. V = empty とする
3.繰り返す
	a.1つめのExpressionが存在する場合、
		i. testExprRef は、1つめのExpressionを評価した結果とする
		ii. ToBoolean(GetValue(testExprRef)) が、 falseである場合、 return (normal, V, empty)
	b. stmt は、Statementを評価した結果とする
	c. stmt.value が、emptyではない場合、 V = stmt.value とする
	d. stmt.type が、breakで且つ、 stmt.target が現在のラベルのセット内にある場合、return (normal, V, empty)
	e. stmt.type が、continueでない、または、 stmt.target が、現在のラベルのセット内にない場合、
		i. stmt が、途中完了(an abrupt completion)である場合、 stmt を返す
	f.2つめのExpressionが存在する場合、
		i. incExprRef は、2つめのExpressionを評価した結果とする
		ii. GetValue(incExprRef) を呼ぶ(この値は使用されない)
</pre>
</div>

<p>
    　プロダクション
</p>

<div class="pre-div">
<pre>
IterationStatement : for ( var VariableDeclarationListNoIn ; Expressionopt ; Expressionopt ) Statement
</pre>
</div>

<p>
    は、次のように評価されます。
</p>

<div class="pre-div">
<pre>
1. VariableDeclarationListNoInを評価
2. V = empty とする
3.繰り返す
	a.1つめのExpressionが存在する場合、
		i. testExprRef は、1つめのExpressionを評価した結果とする
		ii. ToBoolean(GetValue(testExprRef)) が、 falseである場合、 return (normal, V, empty)
	b. stmt は、Statementを評価した結果とする
	c. stmt.value が、emptyではない場合、 V = stmt.value とする
	d. stmt.type が、breakで且つ、 stmt.target が、現在のラベルのセット内にある場合、 return (normal, V, empty)
	e. stmt.type が、continueでない、または、 stmt.target が、現在のラベルのセット内にない場合、
		i. stmt が、途中完了(an abrupt completion)である場合、 stmt を返す
	f.2つめのExpressionが存在する場合、
		i. incExprRef は、2つめのExpressionを評価した結果とする
		ii. GetValue(incExprRef)を呼ぶ(この値は使用されない)
</pre>
</div>

<h3 id="x12.6.4">12.6.4 for-in 文<a href="#x12.6.4">#</a></h3>

<p>
    　プロダクション
</p>

<div class="pre-div">
<pre>
IterationStatement : for ( LeftHandSideExpression in Expression ) Statement
</pre>
</div>

<p>
    は、次のように評価されます。
</p>

<div class="pre-div">
<pre>
1. exprRef は、Expressionを評価した結果とする
2. experValue は、 GetValue(exprRef) とする
3. experValue が、 null または、 undefinedである場合、 return (normal, empty, empty)
4. obj は、 ToObject(experValue) とする
5. V = empty とする
6.繰り返す
	a. P は、[[Enumerable]]属性が、trueである obj の次のプロパティの名称とする、そのようなプロパティがない場合、 return (normal, V, empty)
	b. lhsRef は、 LeftHandSideExpression を評価した結果とする (それは繰り返しと評価される場合がある)
	c. PutValue(lhsRef, P) を呼ぶ
	d. stmt は、Statementを評価した結果とする
	e. stmt.value が、 emptyである場合、 V = stmt.value とする
	f. stmt.type が、 breakで且つ stmt.target が、現在のラベルのセット内にある場合、 return (normal, V, empty)
	g. stmt.type が、continueでない、または、 stmt.target が、現在のラベルのセット内にない場合、
		i. stmt が、途中完了(an abrupt completion)である場合、 stmt を返す
</pre>
</div>

<p>
    　プロダクション
</p>

<div class="pre-div">
<pre>
IterationStatement : for ( var VariableDeclarationNoIn in Expression ) Statement
</pre>
</div>

<p>
    は、次のように評価されます。
</p>

<div class="pre-div">
<pre>
1. varName は、VariableDeclarationNoInを評価した結果とする
2. exprRef は、Expressionを評価した結果とする
3. experValue は、 GetValue(exprRef) とする
4. experValue が、 null または、 undefinedである場合、return (normal, empty, empty)
5. obj は、 ToObject(experValue) とする
6. V = empty とする
7.繰り返す
	a. P は、[[Enumerable]]属性がtrueである obj の次のプロパティの名称とする、そのようなプロパティがない場合には、 return (normal, V, empty)
	b. varRef は、識別子参照 (11.1.2)にあったように varName を評価した結果とする、それは繰り返しと評価される場合がある
	c. PutValue(varRef, P) を呼ぶ
	d. stmt は、Statementを評価した結果とする
	e. stmt.value が、emptyではない場合、 let V = stmt.value とする
	f. stmt.type が、 breakで且つ、stmt.target が、現在のラベルのセット内にある場合、 return (normal, V, empty)
	g. stmt.type が、continueでない、または、 stmt.target が現在のラベルのセット内にない場合、
		i. stmt が、途中完了(an abrupt completion)である場合、 stmt を返す
</pre>
</div>

<p>
    　(1つめのアルゴリズムのステップ 6.a. 、2つめのステップ 7.a. にある)プロパティの仕組みと列挙順は、指定されません。
    列挙中のオブジェクトのプロパティは、列挙中に削除される場合があります。
    プロパティが、列挙中に削除され、もはや存在しない場合、それは存在しないでしょう。
    新たなプロパティが、列挙中に列挙されるオブジェクトに追加される場合、新たに追加されたプロパティが、アクティブな列挙内に存在する保証はありません。
    プロパティ名は、列挙子内に1度以上現れてはいけません。
</p>

<p>
    　オブジェクトのプロパティを列挙中は、当該プロトタイプの列挙中のプロパティ、またはプロトタイプのプロトタイプ等々といった再帰を含みますが、同じ名称であるプロパティを持つプロトタイプチェーン内にあるオブジェクトの前に何かがある為に「陰になった」("shadowed"である)場合、プロトタイプのプロトタイプは列挙されません。
    [[Enumerable]]属性の値は、プロトタイプチェーンにおけるプロトタイプオブジェクトのプロトタイプが、前のオブジェクトによって隠されているかどうかについて決める際には考慮されません。
</p>

<p>
    [注釈]
</p>

<p>
    11.13.1.注釈参照
</p>


</article>
<article>


    <h2>12.7 continue 文 / The continue Statement </h2>


    <h3 id="x12.7">12.7 continue 文<a href="#x12.7">#</a></h3>

    <div class="pre-div">
<pre>
【構文】
ContinueStatement :
	continue ;
	continue [no LineTerminator here] Identifier;
</pre>
    </div>

    <p>
        【セマンティックス】
    </p>

    <p>
        プログラムは、次の何れかが、trueである場合、構文上の誤りがあると考えられます。
    </p>
    <ul>
        <li>プログラムが、IterationStatement(iteration・反復文)内で(関数の境界を超えずに)直接または、間接的にネストされない場合にオプションの識別子なしで continue 文を含む</li>
        <li>プログラムが、IterationStatement(iteration・反復文)に(関数の境界を超えずに)括られるラベルのセット内に現れない識別子においてオプションの識別子を伴って continue 文を含む
        </li>
    </ul>
    <p>
        　識別子のない ContinueStatement は、次のように評価されます。
    </p>

    <div class="pre-div">
<pre>
1.return (continue, empty, empty)
</pre>
    </div>

    <p>
        　オプションの識別子を伴う ContinueStatement は、次のように評価されます。
    </p>

    <div class="pre-div">
<pre>
1.return (continue, empty, Identifier)
</pre>
    </div>


</article>
<article>


    <h2>12.8 break 文 / The break Statement </h2>


    <h3 id="x12.8">12.8 break 文<a href="#x12.8">#</a></h3>

    <div class="pre-div">
<pre>
【構文】
BreakStatement :
	break ;
	break [no LineTerminator here] Identifier ;
</pre>
    </div>

    <p>
        【セマンティックス】
    </p>

    <p>
        プログラムは、次の何れかが、trueである場合、構文上の誤りがあると考えられます。
    </p>
    <ul>
        <li>プログラムが、IterationStatement(iteration・反復文) や
            SwitchStatement(switch文)内で(関数の境界を超えずに)直接または、間接的にネストされない場合にオプションの識別子なしで break 文を含む
        </li>
        <li>プログラムが、(関数の境界を超えない)文で括られるラベルのセット内に現れない識別子である場合にオプションの識別子を伴う break 文を含む</li>
    </ul>
    <p>
        　識別子のない BreakStatement は、次のように評価されます。
    </p>

    <div class="pre-div">
<pre>
1.return (break, empty, empty).
</pre>
    </div>

    <p>
        　識別子を伴う BreakStatement は、次のように評価されます。
    </p>

    <div class="pre-div">
<pre>
1.return (break, empty, Identifier).
</pre>
    </div>


</article>
<article>


    <h2>12.9 return 文 / The return Statement </h2>


    <h3 id="x12.9">12.9 return 文<a href="#x12.9">#</a></h3>

    <div class="pre-div">
<pre>
【構文】
ReturnStatement :
	return ;
	return [no LineTerminator here] Expression ;
</pre>
    </div>

    <p>
        【セマンティックス】
    </p>

    <p>
        　ECMAScriptのプログラムは、FunctionBody(関数本体)内に何もない return 文を含む場合、構文上の誤りがあると考えられます。
        実行を中止する為の関数に起因する return 文は、callerに値を返します。
        Expression が、省略される場合、戻り値は、undefined(未定義)です。
        それ以外の場合、戻り値は、Expression(式)の値です。
    </p>

    <p>
        　ReturnStatement は、次のように評価されます。
    </p>

    <div class="pre-div">
<pre>
1.Expressionが、存在しない場合、return (return, undefined, empty)
2. exprRef は、Expressionを評価した結果とする
3.return (return, GetValue(exprRef), empty)
</pre>
    </div>


</article>
<article>


    <h2>12.10 with 文 / The with Statement </h2>


    <h3 id="x12.10">12.10 with 文<a href="#x12.10">#</a></h3>

    <div class="pre-div">
<pre>
【構文】
WithStatement :
	with ( Expression ) Statement
</pre>
    </div>

    <p>
        　 with 文は、現在の実行コンテキストの語彙的な環境に生成したオブジェクトについてオブジェクト型環境レコードを追加します。
        その場合、引数とした語彙的な環境を使って文を実行します。
        最後にそれは元の語彙的な環境を復元します。
    </p>

    <p>
        【セマンティックス】
    </p>

    <p>
        　プロダクション
    </p>

    <div class="pre-div">
<pre>
WithStatement : with ( Expression ) Statement
</pre>
    </div>

    <p>
        は、次のように評価されます。
    </p>

    <div class="pre-div">
<pre>
1. val は、Expressionを評価した結果とする
2. obj は、 ToObject(GetValue(val)) とする
3. oldEnv は、実行中の実行コンテキストのLexicalEnvironmentとする
4. newEnv は、引数として obj と oldEnv を渡すことによってNewObjectEnvironmentを呼んだ結果とする
5. newEnv の provideThis フラグに true を設定
6. 実行中の実行コンテキストのLexicalEnvironmentに newEnv を設定
7. C は、Statementを評価した結果とするが、評価中に例外が投げられる(スローされる)場合、  V が例外である場合、 C は、 (throw, V, empty)とする(、もし、投げられる(スローされる)例外がない場合のように現在の結果を実行する)
8.実行中の実行コンテキストのLexicalEnvironmentに oldEnv を設定
9. C を返す
</pre>
    </div>

    <p>
        [注釈]
    </p>

    <p>
        　通常、中途完了(abrupt completion)、例外如何に関わらず、操作上、どんなに組み込み文が残ったとしてもLexicalEnvironmentは、常に元の状態に復元されます。
    </p>

    <h3 id="x12.10.1">12.10.1 strict(厳格)モードの制限・制約<a href="#x12.10.1">#</a></h3>

    <p>
        　strictモードのコードは、WithStatementに含まれない場合があります。
        このようなコンテキスト内でのWithStatementの出現は、SyntaxErrorとして扱われます。
    </p>


</article>
<article>


    <h2>12.11 switch 文 / The switch Statement </h2>


    <h3 id="x12.11">12.11 switch 文<a href="#x12.11">#</a></h3>

    <div class="pre-div">
<pre>
【構文】
SwitchStatement :
	switch ( Expression ) CaseBlock

CaseBlock :
	{ CaseClausesopt }
	{ CaseClausesopt DefaultClause CaseClausesopt }

CaseClauses :
	CaseClause
	CaseClauses CaseClause

CaseClause :
	case Expression : StatementListopt

DefaultClause :
	default : StatementListopt
</pre>
    </div>

    <p>
        【セマンティックス】
    </p>

    <p>
        　プロダクション
    </p>

    <div class="pre-div">
<pre>
SwitchStatement : switch ( Expression ) CaseBlock
</pre>
    </div>

    <p>
        は、次のように評価されます。
    </p>

    <div class="pre-div">
<pre>
1. exprRef は、Expressionを評価した結果とする
2. R は、パラメータとして GetValue(exprRef)を渡すことによってCaseBlockを評価した結果とする
3. R.type が、 break 且つ、 R.target が、現在のラベルのセット内にある場合、return (normal, R.value, empty)
4. Rを返す
</pre>
    </div>

    <p>
        　プロダクション
    </p>

    <div class="pre-div">
<pre>
CaseBlock : { CaseClausesopt }
</pre>
    </div>

    <p>
        は、入力パラメータ input が与えられ、次のように評価されます。
    </p>

    <div class="pre-div">
<pre>
1. V = empty とする
2. A は、ソーステキスト順におけるCaseClauseアイテムのリストとする
3. searching は、true とする
4. searching が trueである間、繰り返す
	a. C は、 A にある次のCaseClauseとする、そのようなCaseClauseがない場合、return (normal, V, empty)
	b. clauseSelector は、C を評価した結果とする
	c. input が、 === 演算子によって定義したように clauseSelector と同等である場合、
		i. searching に false を設定
		ii. C が、StatementListを持つ場合、
			1. C のStatementListを評価し、 R は、 result とする
			2. R が、中途完了(an abrupt completion)である場合、R を返す
			3. V = R.value とする
5.繰り返す
	a. C は、 A にある次のCaseClauseとする、もし、そのようなCaseClauseがない場合、return (normal, V, empty)
	b. C が、StatementListを持つ場合、
		i. C のStatementListを評価し、 R は、 result とする
		ii. R.value が、emptyではない場合、 V = R.valueとする
		iii. R が、中途完了(an abrupt completion)である場合、return (R.type, V, R.target)
</pre>
    </div>

    <p>
        　プロダクション
    </p>

    <div class="pre-div">
<pre>
CaseBlock : { CaseClausesopt DefaultClause CaseClausesopt }
</pre>
    </div>

    <p>
        は入力パラメータ input を与えられ、次のように評価されます。
    </p>

    <div class="pre-div">
<pre>
1. V = empty とする
2. A は、ソーステキスト順において1つめのCaseClausesとなるCaseClauseアイテムのリストとする
3. B は、ソーステキスト順において2つめのCaseClausesとなるCaseClauseアイテムのリストとする
4. found は、falseとする
5. AにあるCaseClauseごとに順に文字 C として繰り返す
	a. found が、 falseである場合、
		i. clauseSelector は、 C を評価した結果とする
		ii. input が、 === 演算子によって定義したようにclauseSelectorと同等である場合、 found に trueを設定
	b. found が、 trueである場合
		i. C が、StatementListを持つ場合、
			1. C のStatementListを評価し、 R は、 result とする
			2. R.value が、emptyではない場合、 V = R.value とする
			3. R が、中途完了(an abrupt completion)である場合、return (R.type, V, R.target)とする
6. foundInB は、 falseとする
7. found が、 falseである場合、
	a. foundInB 且つ、未処理の B の要素全てが、falseの間、繰り返す
		i. C は、B にある次のCaseClauseとする
		ii. clauseSelectorは、 Cを評価した結果とする
		iii. input が、 === 演算子によって定義したようにclauseSelectorと同等である場合、
			1. foundInB にtrueを設定
			2. C が、 StatementListを持つ場合、
				a CのStatementListを評価し、 R は、 resultとする
				b もし、 R.value が、emptyではない場合、 V = R.valueとする
				c もし、R が、中途完了(an abrupt completion)である場合、return (R.type, V, R.target)とする
8. foundInB が、false且つ、 DefaultClause が、StatementListを持つ場合、
	a.DefaultClauseのStatementListを評価し、 R は、 resultとする
	b. R.value が、 emptyではない場合、 V = R.valueとする
	c. R 、中途完了(an abrupt completion)である場合、return (R.type, V, R.target)とする
9.繰り返す(注記として ステップ 7.a.i が実行される場合には、このループは、Bの始点で始まらない)
	a. C は、Bにある次のCaseClauseとする、そのようなCaseClauseがない場合、return (normal, V, empty)とする
	b. C が、StatementListを持つ場合、
		i. C のStatementListを評価し、 R は、resultとする
		ii. R.value が、 emptyではない場合、 V = R.value とする
		iii. R が、中途完了(an abrupt completion)である場合、return (R.type, V, R.target)とする
</pre>
    </div>

    <p>
        　プロダクション
    </p>

    <div class="pre-div">
<pre>
CaseClause : case Expression : StatementListopt
</pre>
    </div>

    <p>
        は、次のように評価されます。
    </p>

    <div class="pre-div">
<pre>
1. exprRef は、Expressionを評価した結果とする
2. GetValue(exprRef)を返す
</pre>
    </div>

    <p>
        [注釈]
    </p>

    <p>
        　評価中のCaseClauseは、関連するStatementListを実行しません。
        それは、単にExpressionを評価し、どのStatementListの実行を開始するかを決める為に使用されるCaseBlockアルゴリズムにおける値を返します。
    </p>


</article>
<article>


    <h2>12.12 ラベル付き文 / Labelled Statements </h2>


    <h3 id="x12.12">12.12 ラベル付き文<a href="#x12.12">#</a></h3>

    <div class="pre-div">
<pre>
【構文】
LabelledStatement :
Identifier : Statement
</pre>
    </div>

    <p>
        【セマンティックス】
    </p>

    <p>
        　Statementは、ラベルで前置される場合があります。
        ラベルづけした文は、ラベル付けした break と継続する文を伴う接続詞の中でだけ使用されます。
        ECMAScriptには、 goto 文はありません。
    </p>

    <p>
        　ECMAScriptのプログラムは、ラベルとしての同一の識別子を伴うLabelledStatementによって括られるLabelledStatementを含む場合、構文上の誤りであると考えられます。
        これは、ラベル付けした文の内側で直接または間接的にネストされるFunctionDeclarationの本体内に現れるラベルには適用しません。
    </p>

    <p>
        　プロダクション Identifier : Statement は、Statementとその際に評価中のStatementのラベルのセットに識別子を追加することによって評価されます。
        LabelledStatementそれ自身が、カラではないラベルのセットを持つ場合、これらのラベルもまた、それを評価する前にStatementのラベルのセットに追加されます。
        評価中のStatementの結果が、L が識別子と同等である場合において(break, V, L)である場合、当該プロダクションは、(normal, V, empty)内にある結果となります。
    </p>

    <p>
        　LabelledStatementの評価に先だって、含まれるStatementは、カラである1つ要素から成るラベルのセットを処理中であるものとみなされる状況におけるIterationStatement や
        SwitchStatementである場合を除き、カラのラベルのセットを処理中であるものとみなされます。
    </p>


</article>
<article>


    <h2>12.13 throw 文 / The throw Statement </h2>


    <h3 id="x12.13">12.13 throw 文<a href="#x12.13">#</a></h3>

    <div class="pre-div">
<pre>
【構文】
ThrowStatement :
	throw [no LineTerminator here] Expression ;
</pre>
    </div>

    <p>
        【セマンティックス】
    </p>

    <p>
        　プロダクション
    </p>

    <div class="pre-div">
<pre>
ThrowStatement : throw [no LineTerminator here] Expression ;
</pre>
    </div>

    <p>
        は、次のように評価されます。
    </p>

    <div class="pre-div">
<pre>
1. exprRef は、Expressionを評価した結果とする
2. return (throw, GetValue(exprRef), empty)
</pre>
    </div>


</article>
<article>


    <h2>12.14 try 文 / The try Statement </h2>


    <h3 id="x12.14">12.14 try 文<a href="#x12.14">#</a></h3>

    <div class="pre-div">
<pre>
【構文】
TryStatement :
	try Block Catch
	try Block Finally
	try Block Catch Finally

Catch :
	catch ( Identifier ) Block

Finally :
	finally Block
</pre>
    </div>

    <p>
        　 try 文は、 ランタイムエラー(実行時エラー)や throw 文のように現れる例外的な条件についてコードのブロックで括ります。
        catch 句は、例外操作(exception-handling)コードを提供します。
        catch 句が、例外を捕捉した場合、その識別子は、例外にバインド(連結・結合)されます。
    </p>

    <p>
        【セマンティックス】
    </p>

    <p>
        　プロダクション
    </p>

    <div class="pre-div">
<pre>
TryStatement : try Block Catch
</pre>
    </div>

    <p>
        は、次のように評価されます。
    </p>

    <div class="pre-div">
<pre>
1. B は、Blockを評価した結果とする
2. B.type が、throwではない場合、Bを返す
3.パラメータ B.value を伴う Catch を評価した結果を返す
</pre>
    </div>

    <p>
        　プロダクション
    </p>

    <div class="pre-div">
<pre>
TryStatement : try Block Finally
</pre>
    </div>

    <p>
        は、次のように評価されます。
    </p>

    <div class="pre-div">
<pre>
1. B は、Blockを評価した結果とする
2. F は、Finallyを評価した結果とする
3. F.type が、normalである場合、 Bを返す
4. F を返す
</pre>
    </div>

    <p>
        　プロダクション
    </p>

    <div class="pre-div">
<pre>
TryStatement : try Block Catch Finally
</pre>
    </div>

    <p>
        は、次のように評価されます。
    </p>

    <div class="pre-div">
<pre>
1. B は、Blockを評価した結果とする
2. B.type が、 throwである場合、
	a. C は、パラメータ B.valueを伴う Catch を評価した結果とする
3.それ以外の場合、 B.type が、throwではない場合、
	a. C は、 Bとする
4. F は、Finallyを評価した結果とする
5. F.type が、normalである場合、Cを返す
6. F を返す
</pre>
    </div>

    <p>
        　プロダクション
    </p>

    <div class="pre-div">
<pre>
Catch : catch ( Identifier ) Block
</pre>
    </div>

    <p>
        は、次のように評価されます。
    </p>

    <div class="pre-div">
<pre>
1. C は、このプロダクションに解釈されるパラメータとする
2. oldEnv は、実行中の実行コンテキストのLexicalEnvironmentとする
3. catchEnv は、引数として oldEnv を渡すことによってNewDeclarativeEnvironmentを呼んだ結果とする
4.引数として識別子のString値を渡すことによって catchEnv の具体的なメソッドCreateMutableBindingを呼ぶ
5.引数として識別子、C、falseを渡すことによって catchEnv の具体的なメソッドSetMutableBindingを呼ぶ、注釈としては、最後の引数は、このような状況下では、さして重要ではない
6.実行中の実行コンテキストのLexicalEnvironmentをcatchEnvに設定
7. B は、Blockを評価した結果とする
8.実行中の実行コンテキストのLexicalEnvironmentをoldEnvに設定
9. B を返す
</pre>
    </div>

    <p>
        [注釈]
    </p>

    <p>
        　操作が、どれほどBlockを残したとしてもLexicalEnvironmentは、常に元の状態に復元されます。
    </p>

    <p>
        　プロダクション
    </p>

    <div class="pre-div">
<pre>
Finally : finally Block
</pre>
    </div>

    <p>
        は、次のように評価されます。
    </p>

    <div class="pre-div">
<pre>
1.Blockを評価した結果を返す
</pre>
    </div>

    <h3 id="x12.14.1">12.14.1 strict(厳格)モードの制限・制約 ／ Strict Mode Restrictions<a href="#x12.14.1">#</a></h3>

    <p>
        　 Catch を伴うTryStatementがstrict(厳格)コード内で現れたり、 Catch プロダクションの識別子が、"eval" または、
        "arguments"の何れかである場合には、SyntaxErrorです。
    </p>


</article>
<article>


    <h2>12.15 debugger 文 / The debugger statement </h2>


    <h3 id="x12.15">12.15 debugger 文<a href="#x12.15">#</a></h3>

    <div class="pre-div">
<pre>
【構文】
DebuggerStatement :
	debugger ;
</pre>
    </div>

    <p>
        【セマンティックス】
    </p>

    <p>
        　評価中のDebuggerStatementプロダクションは、debuggerの下で実行する際、ブレークポイントに起因する実装を許容する場合があります。
        debuggerが存在しない場合やこの文がアクティブではない場合、観測可能な効果は、何もありません。
    </p>

    <p>
        　プロダクション
    </p>

    <div class="pre-div">
<pre>
DebuggerStatement : debugger ;
</pre>
    </div>

    <p>
        は、次のように評価されます。
    </p>

    <div class="pre-div">
<pre>
1.実装定義のデバッグ機能が利用可能であり、使用可能な状態にある場合、
	a.実装定義済みのデバッグアクションを実行
	b. result は、実装定義の Completion 値とする
2.それ以外の場合、
	a. result は、(normal, empty, empty)とする
3.resultを返す
</pre>
    </div>


</article>
<article>


<h2>13 関数定義 / Function Definition </h2>

<h3 id="x13">13 関数定義<a href="#x13">#</a></h3>

<div class="pre-div">
<pre>
【構文】
FunctionDeclaration :
	function Identifier ( FormalParameterListopt ) { FunctionBody }

FunctionExpression :
	function Identifieropt ( FormalParameterListopt ) { FunctionBody }

FormalParameterList :
	Identifier FormalParameterList , Identifier

FunctionBody : SourceElementsopt
</pre>
</div>

<p>
    【セマンティックス】
</p>

<p>
    プロダクション
</p>

<div class="pre-div">
<pre>
FunctionDeclaration : function Identifier ( FormalParameterListopt ) { FunctionBody }
</pre>
</div>

<p>
    は、宣言結合のインスタンス化 (10.5 Declaration Binding instantiation )中で次のようにインスタンス化されます。
</p>

<div class="pre-div">
<pre>
1.FormalParameterListoptによって指定したパラメータとFunctionBodyによって指定したボディを伴う 13.2 で指定したような新たなFunctionオブジェクトを生成した結果を返す
  Scopeとして実行中の実行コンテキストのVariableEnvironmentに渡す
  FunctionDeclarationがstrict(モードの)コードに含まれる場合、当該FunctionBodyが、strict(モードの)コードである場合には、Strictフラグとしてtrueを渡す
</pre>
</div>

<p>
    プロダクション
</p>

<div class="pre-div">
<pre>
FunctionExpression : function ( FormalParameterListopt ) { FunctionBody }
</pre>
</div>

<p>
    は、次のように評価されます。
</p>

<div class="pre-div">
<pre>
1.FormalParameterListoptによって指定したパラメータとFunctionBodyによって指定したボディを伴う 13.2 で指定したような新たなFunctionオブジェクトを生成した結果を返す
  Scopeとして実行中の実行コンテキストのLexicalEnvironmentに渡す
  FunctionExpressionが、strict(モードの)コードに含まれる場合、当該FunctionBodyが、strict(モードの)コードである場合には、Strictフラグとしてtrueを渡す
</pre>
</div>

<p>
    プロダクション
</p>

<div class="pre-div">
<pre>
FunctionExpression : function Identifier ( FormalParameterListopt ) { FunctionBody }
</pre>
</div>

<p>
    は、次のように評価されます。
</p>

<div class="pre-div">
<pre>
1. funcEnv は、引数として実行中の実行コンテキストの語彙環境を渡すことによってNewDeclarativeEnvironmentを呼んだ結果とする
2. envRec は、funcEnvの環境レコードとする
3.引数として識別子のString値を渡すことによって envRec の具体的なメソッドCreateImmutableBindingを呼ぶ
4. closure は、FormalParameterListoptによって指定したパラメータとFunctionBodyによって指定したボディを伴う 13.2 で指定したような新たなFunctionオブジェクトを生成した結果とする
   Scopeとして funcEnv 内で渡す
   FunctionExpressionが、strict(モードの)コードに含まれる場合や、そのFunctionBodyが、strict(モードの)コードである場合には、Strictフラグとしてtrueを渡す
5.引数としてIdentifierとclosureのString値を渡すことによって envRec の具体的なメソッドInitializeImmutableBindingを呼ぶ
6. closureを返す
</pre>
</div>

<p>
    [注釈]
</p>

<p>
    　 FunctionExpression (関数式) 内の識別子は、それ自身を再帰的に呼ぶ関数を許容する為に FunctionExpression の FunctionBody (関数本体)内から参照されることが可能です。
    しかしながら、(この項冒頭の【構文】の) FunctionDeclaration (関数宣言)内とは異なり、 FunctionExpression (関数式)そのものに含まれる Identifier (つまり、関数名としての
    Identifier )は、参照不可であり、 FunctionExpression を括るスコープへの影響はありません。
</p>

<p>
    プロダクション
</p>

<div class="pre-div">
<pre>
FunctionBody : SourceElementsopt
</pre>
</div>

<p>
    は、次のように評価されます。
</p>

<div class="pre-div">
<pre>
1. FunctionBodyの code は、FunctionDeclaration や FunctionExpressionの一部が、strict(モードの)コードに含まれる場合、または、当該SourceElementsの指定プロローグ (14.1 指定プロローグ)が、Use Strict 指定を含む場合、または、10.1.1 内の条件の一部を適用する場合には、strictモードのコード
  このFunctionBodyのコードが、strictモードのコードである場合、SourceElementsは、strictモードのコードのように次のステップで評価
  それ以外の場合には、SourceElementsは、非strictモードのコードのように次のステップで評価
2. SourceElementsが、存在する場合には、SourceElementsを評価した結果を返す
3.それ以外の場合、return (normal, undefined, empty)
</pre>
</div>


<h3 id="x13.1">13.1 厳格(strict)モードの制限・制約 ／ Strict Mode Restrictions<a href="#x13.1">#</a></h3>

<p>
    　識別子の値がstrictモードのFunctionDeclaration や FunctionExpressionのFormalParameterList内に1つ以上現れる場合には、SyntaxErrorエラーです。
</p>

<p>
    　識別子 "eval" や識別子 "arguments" が、strictモードのFunctionDeclaration や
    FunctionExpressionのFormalParameterList内に現れる場合には、SyntaxErrorエラーです。
</p>

<p>
    　識別子 "eval" や識別子 "arguments" が、strictモードのFunctionDeclaration や FunctionExpressionの識別子として現れる場合には、SyntaxErrorエラーです。
</p>

<h3 id="x13.2">13.2 Functionオブジェクトを生成<a href="#x13.2">#</a></h3>

<p>
    　オプションのFormalParameterListによって指定したパラメータリスト、FunctionBodyによって指定した本体、Scopeによって指定した語彙環境、Booleanフラグ Strict と
    Functionオブジェクトを与えた場合には、次のように構築されます。
</p>

<div class="pre-div">
<pre>
1.新たにネイティブなECMAScriptオブジェクトを生成し、F は、オブジェクトとする
2. 8.12で説明したような F から成る[[Get]]を除く内部メソッドを全て設定
3. F の[[Class]]内部プロパティに"Function"を設定
4. F の[[Prototype]]内部プロパティに15.3.3.1で指定したように標準組み込みFunctionプロトタイプオブジェクトを設定
5. 15.3.5.4で説明したように F から成る[[Get]]内部プロパティを設定
6. 13.2.1で説明したように F から成る[[Call]]内部プロパティを設定
7. 13.2.2で説明したように F から成る[[Construct]]内部プロパティを設定
8. 15.3.5.3で説明したように F から成る[[HasInstance]]内部プロパティを設定
9. F の[[Scope]]内部プロパティにScopeの値を設定
10. names は、FormalParameterListの識別子と一致する文字列であり、左から右に向かってテキスト順で含まれる List とする
   もし、指定されるパラメータがない場合には、 names は、カラのリストとする
11. F の[[FormalParameters]]内部プロパティにnamesを設定
12. F の[[Code]]内部プロパティにFunctionBodyを設定
13. F の[[Extensible]]内部プロパティにtrueを設定
14. len は、FormalParameterListで指定した正規のパラメータの数とする
   もし、指定されるパラメータがない場合には、 len は、0とする
15.引数 "length"、プロパティ記述子 {[[Value]]: len, [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false}、falseを伴う F の[[DefineOwnProperty]]内部プロパティを呼ぶ
16. proto は、名称を伴う標準組み込みコンストラクタであるObjectとなる式 new Object() によって構築されるかのように新たなオブジェクトを生成した結果とする
17.引数 "constructor"、プロパティ記述子 {[[Value]]: F, { [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true}、 falseを伴う proto の内部メソッド[[DefineOwnProperty]]を呼ぶ
18.引数  "prototype"、プロパティ記述子  {[[Value]]: proto, { [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false}、 falseを伴う F の内部メソッド[[DefineOwnProperty]]を呼ぶ
19. Strict が、trueである場合、
	a. thrower は、 [[ThrowTypeError]] 関数オブジェクト (13.2.3)とする
	b.引数 "caller"、PropertyDescriptor {[[Get]]: thrower, [[Set]]: thrower, [[Enumerable]]: false, [[Configurable]]: false}、falseを伴う F の内部メソッド[[DefineOwnProperty]]を呼ぶ
	c.引数 "arguments"、PropertyDescriptor {[[Get]]: thrower, [[Set]]: thrower, [[Enumerable]]: false, [[Configurable]]: false}、falseを伴う F の内部メソッド[[DefineOwnProperty]]を呼ぶ
20. F を返す
</pre>
</div>

<p>
    [注釈]
</p>

<p>
    　prototype プロパティは、コンストラクタとして使用される関数という可能性を許容する為に関数ごとに自動的に生成されます。
</p>

<h3 id="x13.2.1">13.2.1 [[Call]]<a href="#x13.2.1">#</a></h3>

<p>
    　Functionオブジェクト F における内部メソッド[[Call]]が、 this 値と引数のリストを伴って呼ばれる際には、次のステップがとられます。
</p>

<div class="pre-div">
<pre>
1. funcCtx は、10.4.3で説明したように引数リスト args と this 値を渡すことによって F の内部プロパティ[[FormalParameters]]の値を使用して関数コードにおける新たな実行コンテキストを生成した結果とする
2. result は、 F の内部プロパティ[[Code]]の値であるFunctionBodyを評価した結果とする
   F が内部プロパティ[[Code]]を持たない場合や当該値がカラのFunctionBodyである場合、 result は、(normal, undefined, empty) とする
3.実行コンテキスト以前に復元中に、実行コンテキスト funcCtx を抜ける
4. result.type が、 throwである場合、 result.value を投げる(スローする)
5. result.type が、 returnである場合、 result.value を返す
6.それ以外の場合、 result.type は、normalとしなければならず、またundefinedを返す
</pre>
</div>

<h3 id="x13.2.2">13.2.2 [[Construct]]<a href="#x13.2.2">#</a></h3>

<p>
    　関数オブジェクト F　における内部メソッド[[Construct]]が、引数として利用可能なカラのリストを伴って呼ばれる場合、次のステップがとられます。
</p>

<div class="pre-div">
<pre>
1. obj は、新たに生成したネイティブECMAScriptオブジェクトとする
2. 8.12で指定したように obj の全ての内部メソッドを設定
3. obj の内部プロパティ[[Class]]に"Object"を設定
4. obj の内部プロパティ[[Extensible]]に trueを設定
5. proto は、引数"prototype"を伴う F の内部プロパティ[[Get]]を呼ぶ値とする
6. Type(proto) が、 Objectであれば、 obj の内部プロパティ[[Prototype]]に protoを設定
7. Type(proto) が、 Objectでなければ、 obj の内部プロパティ[[Prototype]]に 15.2.4で説明したように標準組み込みObject型プロトタイプオブジェクトを設定
8. resultは、this 値として obj を提供し、 args として[[Construct]]に渡した引数リストの提供することによって F の内部プロパティ[[Call]]を呼んだものを結果とする
9. Type(result) が、Objectである場合、 result を返す
10. objを返す
</pre>
</div>

<h3 id="x13.2.3">13.2.3 [[ThrowTypeError]] 関数オブジェクト<a href="#x13.2.3">#</a></h3>

<p>
    　[[ThrowTypeError]] オブジェクトは、次のように1度だけ定義される一意の関数オブジェクトです。
</p>

<div class="pre-div">
<pre>
1.新たなネイティブECMAScriptオブジェクトを生成し、 F は、オブジェクトとする
2. 8.12で説明したように F の全ての内部プロパティを設定
3. F の内部プロパティ[[Class]]に"Function"を設定
4. F の内部プロパティ[[Prototype]]に 15.3.3.1で指定したように標準組み込みFunctionプロトタイプオブジェクトを設定
5. 13.2.1で説明したように F の内部プロパティ[[Call]]を設定
6. F の内部プロパティ[[Scope]]にGlobal環境を設定
7. F の内部プロパティ[[FormalParameters]]にカラのリストを設定
8. F の内部プロパティ[[Code]]に無条件にTypeError例外を投げ(スローし)、他に実行するものが何もないFunctionBodyとして設定
9.引数"length"、プロパティ記述子 {[[Value]]: 0, [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false}、 falseを伴う F の内部メソッド[[DefineOwnProperty]]を呼ぶ
10. F の内部プロパティ[[Extensible]]に falseを設定
11. [[ThrowTypeError]]は、F とする
</pre>
</div>


</article>
<article>


    <h2>14 プログラム / Program </h2>


    <h3 id="x14">14 プログラム<a href="#x14">#</a></h3>


    <div class="pre-div">
<pre>
【構文】
Program :
	SourceElementsopt

SourceElements :
	SourceElement
	SourceElements SourceElement

SourceElement :
	Statement
	FunctionDeclaration
</pre>
    </div>

    <p>
        【セマンティックス】
    </p>

    <p>
        プロダクション
    </p>

    <div class="pre-div">
<pre>
Program : SourceElementsopt
</pre>
    </div>

    <p>
        は、次のように評価されます。
    </p>

    <div class="pre-div">
<pre>
1.このProgramのコードは、指定プロローグ (14.1 指定プロローグ)が、 Use Strict 指定を含む当該SourceElementsから成る場合や一部が、 10.1.1を適用した条件から成る場合、strict mode(厳格モード)のコード
   Programのコードが、strict mode(厳格モード)のコードである場合、SourceElementsは、strict mode(厳格モード)のコードのように次のステップ内で評価され、それ以外は、SourceElementsは、非strict mode(厳格モード)のコードのように次のステップ内で評価される
2. SourceElementsが、存在しない場合には、return (normal, empty, empty)
3. progCxt は、 10.4.1で説明したようにグローバルコードにおける新たな実行コンテキストとする
4. result は、SourceElementsを評価した結果とする
5.実行コンテキスト progCxt を抜ける
6. resultを返す
</pre>
    </div>

    <p>
        [注釈]
    </p>

    <p>
        　Programの評価を初期化中、また、このような評価の結果を伴う処理中における複数のプロセスは、この仕様によって定義されるのではなく、ECMAScriptの実装によって定義されます。
    </p>

    <p>
        プロダクション
    </p>

    <div class="pre-div">
<pre>
SourceElements : SourceElements SourceElement
</pre>
    </div>

    <p>
        は、次のように評価されます。
    </p>

    <div class="pre-div">
<pre>
1. headResult は、SourceElementsを評価した結果とする
2. headResult が、中途完了(an abrupt completion)である場合、 headResultを返す
3. tailResult は、SourceElementを評価した結果とする
4. tailResult.value が、 emptyである場合、 V = headResult.value とし、それ以外の場合、 V = tailResult.valueとする
5. return (tailResult.type, V, tailResult.target)
</pre>
    </div>

    <p>
        プロダクション
    </p>

    <div class="pre-div">
<pre>
SourceElement : Statement
</pre>
    </div>

    <p>
        は、次のように評価されます。
    </p>

    <div class="pre-div">
<pre>
1. Statementを評価した結果を返す
</pre>
    </div>

    <p>
        プロダクション
    </p>

    <div class="pre-div">
<pre>
SourceElement : FunctionDeclaration
</pre>
    </div>

    <p>
        は、次のように評価されます。
    </p>

    <div class="pre-div">
<pre>
1. return (normal, empty, empty).
</pre>
    </div>


</article>
<article>


    <h2>14.1 指定プロローグとUse Strict 指定 / Directive Prologues and Use Strict Directive </h2>


    <h3 id="x14.1">14.1 指定プロローグとUse Strict 指定<a href="#x14.1">#</a></h3>

    <p>
        　指定プロローグ(前置指定)は、Program (プログラム)や FunctionBody (関数本体)の最初の SourceElement (ソース要素)プロダクション、また、セミコロンに続けて StringLiteral
        (文字列リテラル・文字そのままの)トークン (字句)全体を構成する並びにある各 ExpressionStatement (式文・式の文)として現れる ExpressionStatement プロダクションの最も長い並びです。
        セミコロンは、明示的に現れる場合や自動セミコロン挿入によって挿入される場合があります。
        指定プロローグは、カラの並びになることもあります。
    </p>

    <p>
        　Use Strict指定は、正確な文字の並び "use strict" や 'use strict'の何れかのStringLiteralを持つ指定プロローグ内のExpressionStatementです。
        Use Strict指定は、EscapeSequence (エスケープシーケンス・エスケープ文字の並び)や LineContinuation (行継続)を含まない場合もあります。
    </p>

    <p>
        　指定プロローグは、1つ以上のUse Strict指定を含む場合があります。
        しかしながら、ある実装は、これが現れる場合、警告を発する場合があります。
    </p>

    <p>
        [注釈]
    </p>

    <p>
        　指定プロローグのExpressionStatementプロダクションは、通常、含まれているSourceElementsプロダクションの評価中に評価されます。
        実装は、Use Strict指定がなく、指定プロローグ内に現れる ExpressionStatement プロダクションという実装仕様上の意味を定義する場合があります。
        適切な通知の仕組みが存在する場合、指定プロローグ内でUse Strict指定がなかったり、実装によって定義した意味を持たない ExpressionStatement に遭遇した場合、実装は、警告を発するべきです。
    </p>


</article>
<article>


    <h2>15 標準組み込みECMAScriptオブジェクト / Standard Built-in ECMAScript Objects </h2>


    <h3 id="x15">15 標準組み込みECMAScriptオブジェクト<a href="#x15">#</a></h3>


    <p>
        　特定の組み込みオブジェクトは、ECMAScriptプログラムが実行を開始する度に利用可能です。
        その1つとしてGlobalオブジェクトは、実行中のプログラムの語彙的な環境の一部です。
        それ以外は、Globalオブジェクトの内部プロパティとしてアクセス可能です。
    </p>

    <p>
        　特段に記述されない限りにおいては、組み込みオブジェクトの内部プロパティ[[Class]]は、その組み込みオブジェクトが内部プロパティ[[Call]]を持つ場合には、"Function"であり、その組み込みオブジェクトが内部プロパティ[[Call]]を持たない場合には、"Object"です。
        特段に記述されない限りにおいては、組み込みオブジェクトの内部プロパティ[[Extensible]]は、最初は値trueを持ちます。
    </p>

    <p>
        　多くの組み込みオブジェクトは関数であり、引数を伴って実行することが可能です。
        それらの内の一部は、更にコンストラクタであり、それらは、new 演算子を伴って使用することを意図した関数です。
        各組み込み関数について、この仕様は、関数とFunctionオブジェクトのプロパティによって要求される引数を説明します。
        各組み込み関数について、この仕様は、更にコンストラクタのプロトタイプオブジェクトのプロパティ、また、コンストラクタを実行する式 new によって返される特定のオブジェクトのインスタンスを指定するプロパティを説明します。
    </p>

    <p>
        　特定の関数の概要について特段の記述がない場合には、この項で説明した関数やコンストラクタが、1つ以上の複数の引数を要求することが記述された関数を与えられる場合、その関数やコンストラクタは、引数がundefinedという値(未定義値)である場合にも、まるで十分にオプションの引数があったかのように確実に動作させましょう。
    </p>

    <p>
        　特定の関数の概要について特段の記述がない場合には、この項で説明した関数やコンストラクタが、1つ以上の複数の引数を許容することが記述された関数を与えられる場合、呼ぶまでは評価される余分な引数は、関数によって無視されます。
        しかしながら、実装は、余分な引数の存在について単に述部であるTypeError例外を投げる(スローする)ことなく、このような動作と同じ length
        (一般的に取るべき引数の数を示すプロパティ)の引数と関連する実装固有の動作を定義する場合があります。
    </p>

    <p>
        [注釈]
    </p>

    <p>
        　組み込み関数の設定における付加的な機能を追加する実装においては、既存の関数に新たなパラメータを追加するのではなく、新たな関数を追加することによってそうすることが推奨されます。
    </p>

    <p>
        　各組み込み関数と組み込みコンストラクタには、その内部プロパティ[[Prototype]]の値として式 Function.prototype (15.3.4)
        という初期値を持つFunctionプロトタイプオブジェクトがあります。
    </p>

    <p>
        　特段の記述がない限り、各組み込みプロトタイプオブジェクトには、そのオブジェクト型プロトタイプオブジェクトを除き、その内部プロパティ[[Prototype]]の値として式 Object.prototype
        (15.2.4)の初期値であるObject型のプロトタイプオブジェクトがあります。
    </p>

    <p>
        　この項で説明した組み込み関数の注釈としては、コンストラクタは、特定の関数の説明に記述されない限り、内部メソッド[[Construct]]を実装することはありません。
        この項で説明した組み込み関数の注釈としては、コンストラクタは、特定の関数の説明に記述されない限り、prototypeプロパティを持ちます。
        この項では、コンストラクタが「関数として呼ばれる場合」と「 new 式の一部として呼ばれる場合」で異なる動作について一般的な説明をします。
    </p>

    <p>
        　「関数として呼ばれる場合」は、コンストラクタの内部メソッド[[Call]]の呼び出しと一致する動作をし、「 new
        式の一部として呼ばれる場合」には、コンストラクタの内部メソッド[[Construct]]の呼び出しと一致する動作をします。
    </p>

    <p>
        　この項の中で説明したコンストラクタ、通常の関数、または両方である各組み込みFunctionオブジェクトは、値が整数であるlengthプロパティを持っています。
        特段の記述がない限り、この値は、オプションのパラメータを含んでいる場合、関数概要における節の見出しで表示した名前付き引数の最大値と同等です。
    </p>

    <p>
        [注釈]
    </p>

    <p>
        　例えば、Stringプロトタイプオブジェクトの slice プロパティの初期値であるFunctionオブジェクトは、節の見出しであり、2つの名前付き引数 start と
        endを表示する"String.prototype.slice (start, end)"の下で説明されるので、よってFunctionオブジェクトにおける length プロパティの値は、2 になります。
    </p>

    <p>
        　状況に応じてこの項で説明した組み込みFunctionオブジェクトの length プロパティは、属性 { [[Writable]]: false, [[Enumerable]]: false,
        [[Configurable]]: false } を持ちます。
        この項で説明した他のプロパティのそれぞれは、特段の記述がない限り、属性 { [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true } を持ちます。
    </p>

    <p><a href="http://www.webzoit.net/hp/it/internet/homepage/script/ecmascript/ecma262_51/contents/15/15_1/"
          title="Globalオブジェクト">15.1
        Globalオブジェクト</a></p>

    <p><a href="http://www.webzoit.net/hp/it/internet/homepage/script/ecmascript/ecma262_51/contents/15/15_2/"
          title="Objectオブジェクト">15.2
        Objectオブジェクト</a></p>

    <p><a href="http://www.webzoit.net/hp/it/internet/homepage/script/ecmascript/ecma262_51/contents/15/15_3/"
          title="Functionオブジェクト">15.3
        Functionオブジェクト</a></p>

    <p><a href="http://www.webzoit.net/hp/it/internet/homepage/script/ecmascript/ecma262_51/contents/15/15_4/"
          title="Arrayオブジェクト">15.4
        Arrayオブジェクト</a></p>

    <p><a href="http://www.webzoit.net/hp/it/internet/homepage/script/ecmascript/ecma262_51/contents/15/15_5/"
          title="Stringオブジェクト">15.5
        Stringオブジェクト</a></p>

    <p><a href="http://www.webzoit.net/hp/it/internet/homepage/script/ecmascript/ecma262_51/contents/15/15_6/"
          title="Booleanオブジェクト">15.6
        Booleanオブジェクト</a></p>

    <p><a href="http://www.webzoit.net/hp/it/internet/homepage/script/ecmascript/ecma262_51/contents/15/15_7/"
          title="Numberオブジェクト">15.7
        Numberオブジェクト</a></p>

    <p><a href="http://www.webzoit.net/hp/it/internet/homepage/script/ecmascript/ecma262_51/contents/15/15_8/"
          title="Mathオブジェクト">15.8
        Mathオブジェクト</a></p>

    <p><a href="http://www.webzoit.net/hp/it/internet/homepage/script/ecmascript/ecma262_51/contents/15/15_9/"
          title="Dateオブジェクト">15.9
        Dateオブジェクト</a></p>

    <p><a href="http://www.webzoit.net/hp/it/internet/homepage/script/ecmascript/ecma262_51/contents/15/15_10/"
          title="RegExpオブジェクト">15.10
        RegExpオブジェクト</a></p>

    <p><a href="http://www.webzoit.net/hp/it/internet/homepage/script/ecmascript/ecma262_51/contents/15/15_11/"
          title="Errorオブジェクト">15.11
        Errorオブジェクト</a></p>

    <p><a href="http://www.webzoit.net/hp/it/internet/homepage/script/ecmascript/ecma262_51/contents/15/15_12/"
          title="JSONオブジェクト">15.12
        JSONオブジェクト</a></p>


</article>
<article>


    <h2>15.1 Globalオブジェクト / The Global Object </h2>


    <h3 id="x15.1">15.1 Globalオブジェクト<a href="#x15.1">#</a></h3>


    <p>
        　一意のGlobalオブジェクトは、操作が一部の実行コンテキストを入力する前に生成されます。
    </p>

    <p>
        　特段の記述がない限り、Globalオブジェクトの標準組み込みプロパティは、属性 {[[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true}
        を持ちます。
    </p>

    <p>
        　Globalオブジェクトは、内部プロパティ[[Construct]]を持たず、new 演算子を伴うコンストラクタとしてGlobalオブジェクトを使用することは不可能です
    </p>

    <p>
        　Globalオブジェクトは、内部プロパティ[[Call]]を持たず、関数としてGlobalオブジェクトを実行することは不可能です。
    </p>

    <p>
        　Globalオブジェクトの内部プロパティ[[Prototype]] と [[Class]]の値は、実装依存(implementation-dependent)です。
    </p>

    <p>
        　この仕様の中で定義したプロパティについての追記としては、Globalオブジェクトは、オプションでホスト定義のプロパティを持つ場合があります。
        これは、Globalオブジェクトがそれ自身である値を持つプロパティを含む場合があるということであり、例えば、HTMLドキュメントオブジェクトモデルでは、Globalオブジェクトのwindowプロパティは、Globalオブジェクト自身です。
    </p>

    <p><a href="http://www.webzoit.net/hp/it/internet/homepage/script/ecmascript/ecma262_51/contents/15/15_1/15_1_1/"
          title="GlobalオブジェクトのValueプロパティ">15.1.1 GlobalオブジェクトのValueプロパティ</a></p>

    <p><a href="http://www.webzoit.net/hp/it/internet/homepage/script/ecmascript/ecma262_51/contents/15/15_1/15_1_2/"
          title="GlobalオブジェクトのFunctionプロパティ">15.1.2 GlobalオブジェクトのFunctionプロパティ</a></p>

    <p><a href="http://www.webzoit.net/hp/it/internet/homepage/script/ecmascript/ecma262_51/contents/15/15_1/15_1_3/"
          title="URI 操作関数のプロパティ">15.1.3
        URI 操作関数のプロパティ</a></p>

    <p><a href="http://www.webzoit.net/hp/it/internet/homepage/script/ecmascript/ecma262_51/contents/15/15_1/15_1_4/"
          title="Globalオブジェクトのコンストラクタプロパティ">15.1.4 Globalオブジェクトのコンストラクタプロパティ</a></p>

    <p><a href="http://www.webzoit.net/hp/it/internet/homepage/script/ecmascript/ecma262_51/contents/15/15_1/15_1_5/"
          title="Globalオブジェクトのその他のプロパティ">15.1.5 Globalオブジェクトのその他のプロパティ</a></p>


</article>
<article>


    <h2>15.2 Objectオブジェクト / Object Objects </h2>


    <h3 id="x15.2">15.2 Objectオブジェクト<a href="#x15.2">#</a></h3>


    <p><a href="http://www.webzoit.net/hp/it/internet/homepage/script/ecmascript/ecma262_51/contents/15/15_2/15_2_1/"
          title="関数として呼ぶ Objectのコンストラクタ">15.2.1 関数として呼ぶ Objectのコンストラクタ</a></p>

    <p><a href="http://www.webzoit.net/hp/it/internet/homepage/script/ecmascript/ecma262_51/contents/15/15_2/15_2_2/"
          title="Object コンストラクタ">15.2.2
        Object コンストラクタ</a></p>

    <p><a href="http://www.webzoit.net/hp/it/internet/homepage/script/ecmascript/ecma262_51/contents/15/15_2/15_2_3/"
          title="Objectコンストラクタのプロパティ">15.2.3 Objectコンストラクタのプロパティ</a></p>

    <p><a href="http://www.webzoit.net/hp/it/internet/homepage/script/ecmascript/ecma262_51/contents/15/15_2/15_2_4/"
          title="Objectのprototypeオブジェクトのプロパティ">15.2.4 Objectのprototypeオブジェクトのプロパティ</a></p>

    <p><a href="http://www.webzoit.net/hp/it/internet/homepage/script/ecmascript/ecma262_51/contents/15/15_2/15_2_5/"
          title="Objectインスタンスのプロパティ">15.2.5 Objectインスタンスのプロパティ</a></p>


</article>
<article>


    <h2>15.3 Function オブジェクト / Function Objects </h2>


    <h3 id="x15.3">15.3 Function オブジェクト<a href="#x15.3">#</a></h3>


    <p><a href="http://www.webzoit.net/hp/it/internet/homepage/script/ecmascript/ecma262_51/contents/15/15_3/15_3_1/"
          title="関数として呼んだ Function コンストラクタ">15.3.1 関数として呼んだ Function コンストラクタ</a></p>

    <p><a href="http://www.webzoit.net/hp/it/internet/homepage/script/ecmascript/ecma262_51/contents/15/15_3/15_3_2/"
          title="Functionコンストラクタ">15.3.2
        Functionコンストラクタ</a></p>

    <p><a href="http://www.webzoit.net/hp/it/internet/homepage/script/ecmascript/ecma262_51/contents/15/15_3/15_3_3/"
          title="Functionコンストラクタのプロパティ">15.3.3 Functionコンストラクタのプロパティ</a></p>

    <p><a href="http://www.webzoit.net/hp/it/internet/homepage/script/ecmascript/ecma262_51/contents/15/15_3/15_3_4/"
          title="Functionプロトタイプオブジェクトのプロパティ">15.3.4 Functionプロトタイプオブジェクトのプロパティ</a></p>

    <p><a href="http://www.webzoit.net/hp/it/internet/homepage/script/ecmascript/ecma262_51/contents/15/15_3/15_3_5/"
          title="Functionインスタンスのプロパティ">15.3.5 Functionインスタンスのプロパティ</a></p>


</article>
<article>


    <h2>15.4 Arrayオブジェクト / Array Objects </h2>


    <h3 id="x15.4">15.4 Arrayオブジェクト<a href="#x15.4">#</a></h3>


    <p>
        　Arrayオブジェクトは、特定のプロパティ名のクラスに特別な待遇を与えます。
        (String値の書式において)プロパティ名 P は、 ToString(ToUint32(P)) が、Pと等しく、 ToUint32(P) が、2の32乗-1と等しくない場合に限り、配列インデックスです。
        property名を持つプロパティは、要素を呼ぶこともある配列インデックスでもあります。
        全てのArrayオブジェクトは、値が常に2の32乗より小さい非負の整数である length プロパティを持ちます。
        length プロパティの値は、配列インデックスを持つプロパティごとの名称よりも数値的に大きくなります。
        Arrayオブジェクトのプロパティは、常に生成または変更され、他のプロパティは、この不変性を維持する必要がある場合に調整されます。
        特に名前付きで追加されるプロパティは、常に配列インデックスであり、必要があれば、その配列インデックスの数値以上にする為に length プロパティが変更されます。
        また、length プロパティは、自動的に削除される新たな長さよりも小さくならない値を持つ配列インデックスである名称を持つプロパティごとに常に 変更されます。
        この制約は、Arrayオブジェクトの自身のプロパティにだけ適用されるものであり、その prototype から継承される場合がある length や配列インデックスによって影響を受けることはありません。
    </p>

    <p>
        　次のアルゴリズムがtrueを返す場合、オブジェクト O は、希薄(sparse)になると言われます。
    </p>

    <div class="pre-div">
<pre>
1. len は、引数"length"を伴う O の内部メソッド[[Get]]を呼んだ結果とする
2. 0≦i&lt;ToUint32(len) の範囲内にある整数 i ごとに
	a. elem は、引数 ToString(i) を伴う O の内部メソッド[[GetOwnProperty]]を呼んだ結果とする
	b. elem が、undefinedである場合、trueを返す
3.falseを返す
</pre>
    </div>
    <p><a href="http://www.webzoit.net/hp/it/internet/homepage/script/ecmascript/ecma262_51/contents/15/15_4/15_4_1/"
          title="関数として呼んだ Array コンストラクタ">15.4.1 関数として呼んだ Array コンストラクタ</a></p>

    <p><a href="http://www.webzoit.net/hp/it/internet/homepage/script/ecmascript/ecma262_51/contents/15/15_4/15_4_2/"
          title="Array コンストラクタ">15.4.2
        Array コンストラクタ</a></p>

    <p><a href="http://www.webzoit.net/hp/it/internet/homepage/script/ecmascript/ecma262_51/contents/15/15_4/15_4_3/"
          title="Array コンストラクタのプロパティ">15.4.3 Array コンストラクタのプロパティ</a></p>

    <p><a href="http://www.webzoit.net/hp/it/internet/homepage/script/ecmascript/ecma262_51/contents/15/15_4/15_4_4/"
          title="Arrayプロトタイプオブジェクトのプロパティ">15.4.4 Arrayプロトタイプオブジェクトのプロパティ</a></p>

    <p><a href="http://www.webzoit.net/hp/it/internet/homepage/script/ecmascript/ecma262_51/contents/15/15_4/15_4_5/"
          title="Arrayインスタンスのプロパティ">15.4.5 Arrayインスタンスのプロパティ</a></p>


</article>
<article>


    <h2>15.5 String オブジェクト / String Objects </h2>


    <h3 id="x15.5">15.5 String オブジェクト<a href="#x15.5">#</a></h3>


    <p><a href="http://www.webzoit.net/hp/it/internet/homepage/script/ecmascript/ecma262_51/contents/15/15_5/15_5_1/"
          title="関数として呼ばれる String コンストラクタ">15.5.1 関数として呼ばれる String コンストラクタ</a></p>

    <p><a href="http://www.webzoit.net/hp/it/internet/homepage/script/ecmascript/ecma262_51/contents/15/15_5/15_5_2/"
          title="String コンストラクタ">15.5.2
        String コンストラクタ</a></p>

    <p><a href="http://www.webzoit.net/hp/it/internet/homepage/script/ecmascript/ecma262_51/contents/15/15_5/15_5_3/"
          title="String コンストラクタのプロパティ">15.5.3 String コンストラクタのプロパティ</a></p>

    <p><a href="http://www.webzoit.net/hp/it/internet/homepage/script/ecmascript/ecma262_51/contents/15/15_5/15_5_4/"
          title="Stringプロトタイプオブジェクトのプロパティ">15.5.4 Stringプロトタイプオブジェクトのプロパティ</a></p>

    <p><a href="http://www.webzoit.net/hp/it/internet/homepage/script/ecmascript/ecma262_51/contents/15/15_5/15_5_5/"
          title="String インスタンスのプロパティ">15.5.5 String インスタンスのプロパティ</a></p>


</article>
<article>


    <h2>15.6 Booleanオブジェクト / Boolean Objects </h2>


    <h3 id="x15.6">15.6 Booleanオブジェクト<a href="#x15.6">#</a></h3>

    <h3 id="x15.6.1">15.6.1 関数として呼ぶBooleanコンストラクタ<a href="#x15.6.1">#</a></h3>

    <p>
        　 Booleanが、コンストラクタではなく、関数として呼ばれる際には、型変換を実行します。
    </p>

    <h3 id="x15.6.1.1">15.6.1.1 Boolean (value)<a href="#x15.6.1.1">#</a></h3>

    <p>
        　 ToBoolean(value) によって算出したBoolean値を返します。
    </p>

    <h3 id="x15.6.2">15.6.2 Boolean コンストラクタ<a href="#x15.6.2">#</a></h3>

    <p>
        　 Booleanが、new 式の一部として呼ばれる場合、それはコンストラクタであり、新たに生成したオブジェクトを初期化します。
    </p>

    <h3 id="x15.6.2.1">15.6.2.1 new Boolean (value)<a href="#x15.6.2.1">#</a></h3>

    <p>
        　新たに構成したオブジェクトの内部プロパティ[[Prototype]]は、 Boolean.prototype (15.6.3.1)の初期値であるオリジナルのBooleanプロトタイプオブジェクトに設定されます。
    </p>

    <p>
        　新たに構成したBoolean型オブジェクトの内部プロパティ[[Class]]は、"Boolean"に設定されます。
    </p>

    <p>
        　新たに構成したBoolean型オブジェクトの内部プロパティ[[PrimitiveValue]]は、 ToBoolean(value) に設定されます。
    </p>

    <p>
        　新たに構成したBoolean型オブジェクトの内部プロパティ[[Extensible]]は、 trueに設定されます。
    </p>

    <h3 id="x15.6.3">15.6.3 Boolean コンストラクタのプロパティ<a href="#x15.6.3">#</a></h3>

    <p>
        　 Booleanコンストラクタの内部プロパティ[[Prototype]]の値は、Functionプロトタイプオブジェクト(15.3.4)です。
        更に内部プロパティと(値が1である)lengthプロパティ、Booleanコンストラクタは、次のプロパティも持ちます。
    </p>

    <h3 id="x15.6.3.1">15.6.3.1 Boolean.prototype<a href="#x15.6.3.1">#</a></h3>

    <p>
        　 Boolean.prototype の初期値は、Booleanプロトタイプオブジェクト(15.6.4)です。
        このプロパティは、属性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false } を持ちます。
    </p>

    <h3 id="x15.6.4">15.6.4 Booleanプロトタイプオブジェクトのプロパティ<a href="#x15.6.4">#</a></h3>

    <p>
        　 Booleanプロトタイプオブジェクトは、値がfalseであるそれ自身の(その[[Class]]が"Boolean"である)Booleanオブジェクトです。
        Booleanプロトタイプオブジェクトの内部プロパティ[[Prototype]]の値は、標準組み込みObjectプロトタイプオブジェクト(15.2.4)です。
    </p>

    <h3 id="x15.6.4.1">15.6.4.1 Boolean.prototype.constructor<a href="#x15.6.4.1">#</a></h3>

    <p>
        　 Boolean.prototype.constructor の初期値は、組み込みBooleanコンストラクタです。
    </p>

    <h3 id="x15.6.4.2">15.6.4.2 Boolean.prototype.toString ( )<a href="#x15.6.4.2">#</a></h3>

    <p>
        　(toStringは、)次のステップが取られます。
    </p>

    <div class="pre-div">
<pre>
1. B は、 this 値とする
2. Type(B) が、 Boolean である場合、 b は、 B とする
3. Type(B) が、 Object 且つ、B の内部プロパティ[[Class]]の値が"Boolean"である場合、b は、B の内部プロパティ[[PrimitiveValue]]の値とする
4.それ以外の場合、TypeError例外を投げる(スローする)
5. b が、 true である場合、"true"を返し、それ以外の場合、"false"を返す
</pre>
    </div>

    <h3 id="x15.6.4.3">15.6.4.3 Boolean.prototype.valueOf ( )<a href="#x15.6.4.3">#</a></h3>

    <p>
        　(valueOfは、)次のステップが取られます。
    </p>

    <div class="pre-div">
<pre>
1. B は、 this 値とする
2. Type(B) が、 Boolean である場合、 b は、 B とする
3. Type(B) が、 Object 且つ、B の内部プロパティ[[Class]]の値が"Boolean"である場合、b は、B の内部プロパティ[[PrimitiveValue]]の値とする
4.それ以外の場合、TypeError例外を投げる(スローする)
5. b を返す
</pre>
    </div>

    <h3 id="x15.6.5">15.6.5 Boolean インスタンスのプロパティ<a href="#x15.6.5">#</a></h3>

    <p>
        　 Booleanインスタンスは、Booleanプロトタイプオブジェクトと値が、"Boolean"であるそれらの内部プロパティ[[Class]]からプロパティを継承します。
        Booleanインスタンスは、内部プロパティ[[PrimitiveValue]]も持ちます。
        内部プロパティ[[PrimitiveValue]]は、このBooleanオブジェクトによって表したBoolean値です。
    </p>


</article>
<article>


    <h2>15.7 Number オブジェクト / Number Objects </h2>


    <h3 id="x15.7">15.7 Number オブジェクト<a href="#x15.7">#</a></h3>


    <p><a href="http://www.webzoit.net/hp/it/internet/homepage/script/ecmascript/ecma262_51/contents/15/15_7/15_7_1/"
          title="関数として呼ぶ Number コンストラクタ">15.7.1 関数として呼ぶ Number コンストラクタ</a></p>

    <p><a href="http://www.webzoit.net/hp/it/internet/homepage/script/ecmascript/ecma262_51/contents/15/15_7/15_7_2/"
          title="Number コンストラクタ">15.7.2
        Number コンストラクタ</a></p>

    <p><a href="http://www.webzoit.net/hp/it/internet/homepage/script/ecmascript/ecma262_51/contents/15/15_7/15_7_3/"
          title="Number コンストラクタのプロパティ">15.7.3 Number コンストラクタのプロパティ</a></p>

    <p><a href="http://www.webzoit.net/hp/it/internet/homepage/script/ecmascript/ecma262_51/contents/15/15_7/15_7_4/"
          title="Number プロトタイプオブジェクトのプロパティ">15.7.4 Number プロトタイプオブジェクトのプロパティ</a></p>

    <p><a href="http://www.webzoit.net/hp/it/internet/homepage/script/ecmascript/ecma262_51/contents/15/15_7/15_7_5/"
          title="Number インスタンスのプロパティ">15.7.5 Number インスタンスのプロパティ</a></p>


</article>
<article>


    <h2>15.8 Math オブジェクト / The Math Object </h2>


    <h3 id="x15.8">15.8 Math オブジェクト<a href="#x15.8">#</a></h3>


    <p>
        　 Math オブジェクトは、いくつかの関数から成る、いくつかの名前付きプロパティを持つ単独のオブジェクトです。
    </p>

    <p>
        　 Math オブジェクトの内部プロパティ[[Prototype]]の値は、標準組み込みObjectプロトタイプオブジェクト(15.2.4)です。
        Math オブジェクトの内部プロパティ[[Class]]の値は、"Math"です。
    </p>

    <p>
        　 Math オブジェクトは、内部プロパティ[[Construct]]を持っていません。
        つまり、new 演算子を伴ってコンストラクタとしてMath オブジェクトを使用することはできません。
    </p>

    <p>
        　 Math オブジェクトは、内部プロパティ[[Call]]を持っていません。
        つまり、Math オブジェクトを関数として呼び出すことはできません。
    </p>

    <p>
        [注釈]
    </p>

    <p>
        　この仕様について、フレーズ" x におけるNumber値"は、8.5 で定義した技術的な意味を持ちます。
    </p>

    <p><a href="http://www.webzoit.net/hp/it/internet/homepage/script/ecmascript/ecma262_51/contents/15/15_8/15_8_1/"
          title="Math オブジェクトの値プロパティ">15.8.1 Math オブジェクトの値プロパティ</a></p>

    <p><a href="http://www.webzoit.net/hp/it/internet/homepage/script/ecmascript/ecma262_51/contents/15/15_8/15_8_2/"
          title="MathオブジェクトのFunctionプロパティ">15.8.2 MathオブジェクトのFunctionプロパティ</a></p>


</article>
<article>


<h2>15.9 Date オブジェクト / Date Objects </h2>


<h3 id="x15.9">15.9 Date オブジェクト<a href="#x15.9">#</a></h3>


<p><a href="http://www.webzoit.net/hp/it/internet/homepage/script/ecmascript/ecma262_51/contents/15/15_9/15_9_1/"
      title="Date オブジェクトの概要と抽象操作の定義">15.9.1 Date オブジェクトの概要と抽象操作の定義</a></p>

<p>
    --<a
        href="http://www.webzoit.net/hp/it/internet/homepage/script/ecmascript/ecma262_51/contents/15/15_9/15_9_1/15_9_1_1/"
        title="時間の値と時間の範囲">15.9.1.1 時間の値と時間の範囲</a></p>

<p>
    --<a
        href="http://www.webzoit.net/hp/it/internet/homepage/script/ecmascript/ecma262_51/contents/15/15_9/15_9_1/15_9_1_2/"
        title="日数と1日の時間">15.9.1.2 日数と1日の時間</a></p>

<p>
    --<a
        href="http://www.webzoit.net/hp/it/internet/homepage/script/ecmascript/ecma262_51/contents/15/15_9/15_9_1/15_9_1_3/"
        title="年間の日数">15.9.1.3 年間の日数</a></p>

<p>
    --<a
        href="http://www.webzoit.net/hp/it/internet/homepage/script/ecmascript/ecma262_51/contents/15/15_9/15_9_1/15_9_1_4/"
        title="月間の数">15.9.1.4
    月間の数</a></p>

<p>
    --<a
        href="http://www.webzoit.net/hp/it/internet/homepage/script/ecmascript/ecma262_51/contents/15/15_9/15_9_1/15_9_1_5/"
        title="日付の数">15.9.1.5
    日付の数</a></p>

<p>
    --<a
        href="http://www.webzoit.net/hp/it/internet/homepage/script/ecmascript/ecma262_51/contents/15/15_9/15_9_1/15_9_1_6/"
        title="曜日">15.9.1.6
    曜日</a></p>

<p>
    --<a
        href="http://www.webzoit.net/hp/it/internet/homepage/script/ecmascript/ecma262_51/contents/15/15_9/15_9_1/15_9_1_7/"
        title="地域の時間帯(ローカルタイムゾーン)調整">15.9.1.7 地域の時間帯(ローカルタイムゾーン)調整</a></p>

<p>
    --<a
        href="http://www.webzoit.net/hp/it/internet/homepage/script/ecmascript/ecma262_51/contents/15/15_9/15_9_1/15_9_1_8/"
        title="夏時間調整(DST / Daylight Saving Time Adjustment)">15.9.1.8 夏時間調整(DST / Daylight Saving Time
    Adjustment)</a></p>

<p>
    --<a
        href="http://www.webzoit.net/hp/it/internet/homepage/script/ecmascript/ecma262_51/contents/15/15_9/15_9_1/15_9_1_9/"
        title="ローカルタイム / ローカル時間 / Local Time">15.9.1.9 ローカルタイム / ローカル時間 / Local Time</a></p>

<p>
    --<a
        href="http://www.webzoit.net/hp/it/internet/homepage/script/ecmascript/ecma262_51/contents/15/15_9/15_9_1/15_9_1_10/"
        title="時間、分、秒、ミリ秒 ／ Hours, Minutes, Second, and Milliseconds">15.9.1.10 時間、分、秒、ミリ秒 ／ Hours, Minutes, Second,
    and Milliseconds</a></p>

<p>
    --<a
        href="http://www.webzoit.net/hp/it/internet/homepage/script/ecmascript/ecma262_51/contents/15/15_9/15_9_1/15_9_1_11/"
        title="MakeTime (hour, min, sec, ms)">15.9.1.11 MakeTime (hour, min, sec, ms)</a></p>

<p>
    --<a
        href="http://www.webzoit.net/hp/it/internet/homepage/script/ecmascript/ecma262_51/contents/15/15_9/15_9_1/15_9_1_12/"
        title="MakeDay (year, month, date)">15.9.1.12 MakeDay (year, month, date)</a></p>

<p>
    --<a
        href="http://www.webzoit.net/hp/it/internet/homepage/script/ecmascript/ecma262_51/contents/15/15_9/15_9_1/15_9_1_13/"
        title="MakeDate (day, time)">15.9.1.13 MakeDate (day, time)</a></p>

<p>
    --<a
        href="http://www.webzoit.net/hp/it/internet/homepage/script/ecmascript/ecma262_51/contents/15/15_9/15_9_1/15_9_1_14/"
        title="TimeClip (time)">15.9.1.14 TimeClip (time)</a></p>

<p>
    --<a
        href="http://www.webzoit.net/hp/it/internet/homepage/script/ecmascript/ecma262_51/contents/15/15_9/15_9_1/15_9_1_15/"
        title="日付時刻文字列の書式">15.9.1.15 日付時刻文字列の書式</a></p>

<p>----15.9.1.15.1 拡張した年</p>

<p><a href="http://www.webzoit.net/hp/it/internet/homepage/script/ecmascript/ecma262_51/contents/15/15_9/15_9_2/"
      title="関数として呼ぶ Dateコンストラクタ">15.9.2 関数として呼ぶ Dateコンストラクタ</a></p>

<p>--15.9.2.1 Date ( [ year [, month [, date [, hours [, minutes [, seconds [, ms ] ] ] ] ] ] ] )</p>

<p><a href="http://www.webzoit.net/hp/it/internet/homepage/script/ecmascript/ecma262_51/contents/15/15_9/15_9_3/"
      title="Date コンストラクタ">15.9.3
    Date コンストラクタ</a></p>

<p>--15.9.3.1 new Date (year, month [, date [, hours [, minutes [, seconds [, ms ] ] ] ] ] )</p>

<p>--15.9.3.2 new Date (value)</p>

<p>--15.9.3.3 new Date ( )</p>

<p><a href="http://www.webzoit.net/hp/it/internet/homepage/script/ecmascript/ecma262_51/contents/15/15_9/15_9_4/"
      title="Date コンストラクタのプロパティ">15.9.4 Date コンストラクタのプロパティ</a></p>

<p>--15.9.4.1 Date.prototype</p>

<p>--15.9.4.2 Date.parse (string)</p>

<p>--15.9.4.3 Date.UTC (year, month [, date [, hours [, minutes [, seconds [, ms ] ] ] ] ] )</p>

<p>--15.9.4.4 Date.now ( )</p>

<p><a href="http://www.webzoit.net/hp/it/internet/homepage/script/ecmascript/ecma262_51/contents/15/15_9/15_9_5/"
      title="Date プロトタイプオブジェクトのプロパティ">15.9.5 Date プロトタイプオブジェクトのプロパティ</a></p>

<p>--15.9.5.1 Date.prototype.constructor</p>

<p>--15.9.5.2 Date.prototype.toString ( )</p>

<p>--15.9.5.3 Date.prototype.toDateString ( )</p>

<p>--15.9.5.4 Date.prototype.toTimeString ( )</p>

<p>--15.9.5.5 Date.prototype.toLocaleString ( )</p>

<p>--15.9.5.6 Date.prototype.toLocaleDateString ( )</p>

<p>--15.9.5.7 Date.prototype.toLocaleTimeString ( )</p>

<p>--15.9.5.8 Date.prototype.valueOf ( )</p>

<p>--15.9.5.9 Date.prototype.getTime ( )</p>

<p>--15.9.5.10 Date.prototype.getFullYear ( )</p>

<p>--15.9.5.11 Date.prototype.getUTCFullYear ( )</p>

<p>--15.9.5.12 Date.prototype.getMonth ( )</p>

<p>--15.9.5.13 Date.prototype.getUTCMonth ( )</p>

<p>--15.9.5.14 Date.prototype.getDate ( )</p>

<p>--15.9.5.15 Date.prototype.getUTCDate ( )</p>

<p>--15.9.5.16 Date.prototype.getDay ( )</p>

<p>--15.9.5.17 Date.prototype.getUTCDay ( )</p>

<p>--15.9.5.18 Date.prototype.getHours ( )</p>

<p>--15.9.5.19 Date.prototype.getUTCHours ( )</p>

<p>--15.9.5.20 Date.prototype.getMinutes ( )</p>

<p>--15.9.5.21 Date.prototype.getUTCMinutes ( )</p>

<p>--15.9.5.22 Date.prototype.getSeconds ( )</p>

<p>--15.9.5.23 Date.prototype.getUTCSeconds ( )</p>

<p>--15.9.5.24 Date.prototype.getMilliseconds ( )</p>

<p>--15.9.5.25 Date.prototype.getUTCMilliseconds ( )</p>

<p>--15.9.5.26 Date.prototype.getTimezoneOffset ( )</p>

<p>--15.9.5.27 Date.prototype.setTime (time)</p>

<p>--15.9.5.28 Date.prototype.setMilliseconds (ms)</p>

<p>--15.9.5.29 Date.prototype.setUTCMilliseconds (ms)</p>

<p>--15.9.5.30 Date.prototype.setSeconds (sec [, ms ] )</p>

<p>--15.9.5.31 Date.prototype.setUTCSeconds (sec [, ms ] )</p>

<p>--15.9.5.32 Date.prototype.setMinutes (min [, sec [, ms ] ] )</p>

<p>--15.9.5.33 Date.prototype.setUTCMinutes (min [, sec [, ms ] ] )</p>

<p>--15.9.5.34 Date.prototype.setHours (hour [, min [, sec [, ms ] ] ] )</p>

<p>--15.9.5.35 Date.prototype.setUTCHours (hour [, min [, sec [, ms ] ] ] )</p>

<p>--15.9.5.36 Date.prototype.setDate (date)</p>

<p>--15.9.5.37 Date.prototype.setUTCDate (date)</p>

<p>--15.9.5.38 Date.prototype.setMonth (month [, date ] )</p>

<p>--15.9.5.39 Date.prototype.setUTCMonth (month [, date ] )</p>

<p>--15.9.5.40 Date.prototype.setFullYear (year [, month [, date ] ] )</p>

<p>--15.9.5.41 Date.prototype.setUTCFullYear (year [, month [, date ] ] )</p>

<p>--15.9.5.42 Date.prototype.toUTCString ( )</p>

<p>--15.9.5.43 Date.prototype.toISOString ( )</p>

<p>--15.9.5.44 Date.prototype.toJSON ( key )</p>

<p><a href="http://www.webzoit.net/hp/it/internet/homepage/script/ecmascript/ecma262_51/contents/15/15_9/15_9_6/"
      title="Date インスタンスのプロパティ">15.9.6 Date インスタンスのプロパティ</a></p>


</article>
<article>


    <h2>15.10 RegExp (正規表現)オブジェクト / RegExp (Regular Expression) Objects </h2>


    <h3 id="x15.10">15.10 RegExp (Regular Expression／正規表現) オブジェクト<a href="#x15.10">#</a></h3>


    <p>
        　 RegExpオブジェクトは、正規表現とその関連付けたフラグを含みます。
    </p>

    <p>
        [注釈]
    </p>

    <p>
        　正規表現の書式と機能は、プログラミング言語 Perl 5 にある正規表現機能を元にモデル化されています。
    </p>

    <p><a href="http://www.webzoit.net/hp/it/internet/homepage/script/ecmascript/ecma262_51/contents/15/15_10/15_10_1/"
          title="パターン">15.10.1
        パターン</a></p>

    <p><a href="http://www.webzoit.net/hp/it/internet/homepage/script/ecmascript/ecma262_51/contents/15/15_10/15_10_2/"
          title="パターンのセマンティックス">15.10.2
        パターンのセマンティックス</a></p>

    <p>--&nbsp;15.10.2.1 表記法</p>

    <p>--&nbsp;15.10.2.2 パターン</p>

    <p>--&nbsp;15.10.2.3 論理和</p>

    <p>--&nbsp;15.10.2.4 選択肢</p>

    <p>--&nbsp;15.10.2.5 用語</p>

    <p>--&nbsp;15.10.2.6 アサーション</p>

    <p>--&nbsp;15.10.2.7 量指定子</p>

    <p>--&nbsp;15.10.2.8 Atom</p>

    <p>--&nbsp;15.10.2.9 AtomEscape</p>

    <p>--&nbsp;15.10.2.10 CharacterEscape</p>

    <p>--&nbsp;15.10.2.11 DecimalEscape</p>

    <p>--&nbsp;15.10.2.12 CharacterClassEscape</p>

    <p>--&nbsp;15.10.2.13 CharacterClass</p>

    <p>--&nbsp;15.10.2.14 ClassRanges</p>

    <p>--&nbsp;15.10.2.15 NonemptyClassRanges</p>

    <p>--&nbsp;15.10.2.16 NonemptyClassRangesNoDash</p>

    <p>--&nbsp;15.10.2.17 ClassAtom</p>

    <p>--&nbsp;15.10.2.18 ClassAtomNoDash</p>

    <p>--&nbsp;15.10.2.19 ClassEscape</p>

    <p><a href="http://www.webzoit.net/hp/it/internet/homepage/script/ecmascript/ecma262_51/contents/15/15_10/15_10_3/"
          title="関数として呼んだ RegExp コンストラクタ">15.10.3 関数として呼んだ RegExp コンストラクタ</a></p>

    <p>--&nbsp;15.10.3.1 RegExp(pattern, flags)</p>

    <p><a href="http://www.webzoit.net/hp/it/internet/homepage/script/ecmascript/ecma262_51/contents/15/15_10/15_10_4/"
          title="RegExp コンストラクタ">15.10.4 RegExp コンストラクタ</a></p>

    <p>--&nbsp;15.10.4.1 new RegExp(pattern, flags)</p>

    <p><a href="http://www.webzoit.net/hp/it/internet/homepage/script/ecmascript/ecma262_51/contents/15/15_10/15_10_5/"
          title="RegExp コンストラクタのプロパティ">15.10.5 RegExp コンストラクタのプロパティ</a></p>

    <p>--&nbsp;15.10.5.1 RegExp.prototype</p>

    <p><a href="http://www.webzoit.net/hp/it/internet/homepage/script/ecmascript/ecma262_51/contents/15/15_10/15_10_6/"
          title="RegExpプロトタイプオブジェクトのプロパティ">15.10.6 RegExpプロトタイプオブジェクトのプロパティ</a></p>

    <p>--&nbsp;15.10.6.1 RegExp.prototype.constructor</p>

    <p>--&nbsp;15.10.6.2 RegExp.prototype.exec(string)</p>

    <p>--&nbsp;15.10.6.3 RegExp.prototype.test(string)</p>

    <p>--&nbsp;15.10.6.4 RegExp.prototype.toString()</p>

    <p><a href="http://www.webzoit.net/hp/it/internet/homepage/script/ecmascript/ecma262_51/contents/15/15_10/15_10_7/"
          title="RegExp インスタンスのプロパティ">15.10.7 RegExp インスタンスのプロパティ</a></p>

    <p>--&nbsp;15.10.7.1 source</p>

    <p>--&nbsp;15.10.7.2 global</p>

    <p>--&nbsp;15.10.7.3 ignoreCase</p>

    <p>--&nbsp;15.10.7.4 multiline</p>

    <p>--&nbsp;15.10.7.5 lastIndex</p>


</article>
<article>


    <h2>15.11 Error オブジェクト / Error Objects </h2>


    <h3 id="x15.11">15.11 Error オブジェクト<a href="#x15.11">#</a></h3>


    <p>
        　 Errorオブジェクトのインスタンスは、実行エラーが発生する際に例外として投げられ(スローされ)ます。
    </p>

    <p>
        　 Errorオブジェクトはまた、ユーザー定義の例外クラスにおける基準オブジェクトとして提供する場合もあります。
    </p>

    <p><a href="http://www.webzoit.net/hp/it/internet/homepage/script/ecmascript/ecma262_51/contents/15/15_11/15_11_1/"
          title="関数として呼んだ Error コンストラクタ">15.11.1 関数として呼んだ Error コンストラクタ</a></p>

    <p>--&nbsp;15.11.1.1 Error (message)</p>

    <p><a href="http://www.webzoit.net/hp/it/internet/homepage/script/ecmascript/ecma262_51/contents/15/15_11/15_11_2/"
          title="Error コンストラクタ">15.11.2
        Error コンストラクタ</a></p>

    <p>--&nbsp;15.11.2.1 new Error (message)</p>

    <p><a href="http://www.webzoit.net/hp/it/internet/homepage/script/ecmascript/ecma262_51/contents/15/15_11/15_11_3/"
          title="Error コンストラクタのプロパティ">15.11.3 Error コンストラクタのプロパティ</a></p>

    <p>--&nbsp;15.11.3.1 Error.prototype</p>

    <p><a href="http://www.webzoit.net/hp/it/internet/homepage/script/ecmascript/ecma262_51/contents/15/15_11/15_11_4/"
          title="Errorプロトタイプオブジェクトのプロパティ">15.11.4 Errorプロトタイプオブジェクトのプロパティ</a></p>

    <p>--&nbsp;15.11.4.1 Error.prototype.constructor</p>

    <p>--&nbsp;15.11.4.2 Error.prototype.name</p>

    <p>--&nbsp;15.11.4.3 Error.prototype.message</p>

    <p>--&nbsp;15.11.4.4 Error.prototype.toString ( )</p>

    <p><a href="http://www.webzoit.net/hp/it/internet/homepage/script/ecmascript/ecma262_51/contents/15/15_11/15_11_5/"
          title="Error インスタンスのプロパティ">15.11.5 Error インスタンスのプロパティ</a></p>

    <p><a href="http://www.webzoit.net/hp/it/internet/homepage/script/ecmascript/ecma262_51/contents/15/15_11/15_11_6/"
          title="この標準規格で使用したネイティブなErrorの種類">15.11.6 この標準規格で使用したネイティブなErrorの種類</a></p>

    <p>--&nbsp;15.11.6.1 EvalError</p>

    <p>--&nbsp;15.11.6.2 RangeError</p>

    <p>--&nbsp;15.11.6.3 ReferenceError</p>

    <p>--&nbsp;15.11.6.4 SyntaxError</p>

    <p>--&nbsp;15.11.6.5 TypeError</p>

    <p>--&nbsp;15.11.6.6 URIError</p>

    <p><a href="http://www.webzoit.net/hp/it/internet/homepage/script/ecmascript/ecma262_51/contents/15/15_11/15_11_7/"
          title="NativeError オブジェクト構造">15.11.7 NativeError オブジェクト構造</a></p>

    <p>--&nbsp;15.11.7.1 関数として呼んだ NativeError コンストラクタ</p>

    <p>--&nbsp;15.11.7.2 NativeError (message)</p>

    <p>--&nbsp;15.11.7.3 NativeError コンストラクタ</p>

    <p>--&nbsp;15.11.7.4 new NativeError (message)</p>

    <p>--&nbsp;15.11.7.5 NativeError コンストラクタのプロパティ</p>

    <p>--&nbsp;15.11.7.6 NativeError.prototype</p>

    <p>--&nbsp;15.11.7.7 NativeErrorプロトタイプオブジェクトのプロパティ</p>

    <p>--&nbsp;15.11.7.8 NativeError.prototype.constructor</p>

    <p>--&nbsp;15.11.7.9 NativeError.prototype.name</p>

    <p>--&nbsp;15.11.7.10 NativeError.prototype.message</p>

    <p>--&nbsp;15.11.7.11 NativeError インスタンスのプロパティ</p>


</article>
<article>


    <h2>15.12 JSON オブジェクト / The JSON Object </h2>


    <h3 id="x15.12">15.12 JSON オブジェクト<a href="#x15.12">#</a></h3>


    <p>
        　JSONオブジェクトは、JSONテキストを解析し、構築する為に使用される parse と stringify という2つの関数を含む単一のオブジェクトです。
    </p>

    <p>
        　JSON Data Interchange Format (JSONデータ変換書式) は、 RFC 4627 <a href="http://www.ietf.org/rfc/rfc4627.txt">&lt;http://www.ietf.org/rfc/rfc4627.txt&gt;</a>
        で説明されます。
    </p>

    <p>
        　この仕様内で使用した JSON Data Interchange Format (JSONデータ変換書式) は、2つの例外があるものの(、それ以外は、) RFC 4627 で説明したものと全く同じです。
    </p>
    <ul>
        <li>ECMAScriptのJSONの文法のトップレベルの JSONText プロダクションは、 RFC 4627 によって指定したような任意の JSONObject や任意の JSONArray
            の存在を制限したものではなく、何らかの JSONValue から構成される場合があります。
        </li>
        <li>JSON.parse と JSON.stringify
            の実装に準拠するということは、書式への削除や拡張なしで、この仕様内で定義した確実な書式変換をサポートしなければならないということです。これは、非JSON書式と拡張を許容するJSONパーサーを許可する RFC 4627
            とは異なります。
        </li>
    </ul>
    <p>
        　 JSONオブジェクトの内部プロパティ[[Prototype]]の値は、標準組み込みObjectプロトタイプ(15.2.4)です。
        JSONオブジェクトの内部プロパティ[[Class]]の値は、"JSON"です。
        JSONオブジェクトの内部プロパティ[[Extensible]]の値は、trueに設定されます。
    </p>

    <p>
        　 JSONオブジェクトは、内部プロパティ[[Construct]]を持たず、new 演算子を伴うコンストラクタとしてJSONオブジェクトを使用することはできません。
        JSONオブジェクトは、内部プロパティ[[Call]]を持たず、関数としてJSONオブジェクトを呼び出すことはできません。
    </p>

    <p><a href="http://www.webzoit.net/hp/it/internet/homepage/script/ecmascript/ecma262_51/contents/15/15_12/15_12_1/"
          title="JSONの文法">15.12.1
        JSONの文法</a></p>

    <p><a href="http://www.webzoit.net/hp/it/internet/homepage/script/ecmascript/ecma262_51/contents/15/15_12/15_12_2/"
          title="parse ( text [ , reviver ] )">15.12.2 parse ( text [ , reviver ] )</a></p>

    <p><a href="http://www.webzoit.net/hp/it/internet/homepage/script/ecmascript/ecma262_51/contents/15/15_12/15_12_3/"
          title="stringify ( value [ , replacer [ , space ] ] )">15.12.3 stringify ( value [ , replacer [ , space ] ]
        )</a></p>


</article>
<article>


    <h2>16 エラー / Errors </h2>


    <h3 id="x16">16 エラー<a href="#x16">#</a></h3>

    <p>
        　実装は、関連するECMAScript言語の構成が評価される場合には、ほぼ全てに渡り、エラーを報告しなければいけません。
        初期エラーとは、そのエラーを含んでいるプログラム内にある構成の評価に優先して検出、報告されることが可能なエラーです。
        実装は、当該プログラムの最初の評価に優先してプログラム内の初期エラーを報告しなければいけません。
        eval コード内の初期エラーは、 eval が呼ばれた時点で報告されますが、それは eval コード内の任意の構成の評価に優先して報告されます。
        初期エラーではない全てのエラーは、実行エラーです。
    </p>

    <p>
        　実装は、初期エラーとしての次のエラーの種類のインスタンスを扱わなければいけません。
    </p>
    <ul>
        <li>任意の構文エラー</li>
        <li>同名で割り当てられる複数の get プロパティや同名で割り当てられる複数の set プロパティを持つ ObjectLiteral を定義する試行</li>
        <li>割り当てられるデータプロパティと同名で割り当てられる複数の get や set プロパティの両方を持つ ObjectLiteral を定義する試行</li>
        <li>実装定義の構文の拡張ではない正規表現リテラル内のエラー</li>
        <li>同名で割り当てられる複数のデータプロパティを持つ ObjectLiteral を定義するstrictモードのコード内での試行</li>
        <li>strictモードのコード内での WithStatement (With 文)の出現</li>
        <li>単独のstrictモードの FunctionDeclaration (関数宣言)や FunctionExpression (関数式)から成る任意の FormalParameterList
            (関数のパラメータリスト)内で1度以上現れる Identifier (識別子)の値の出現
        </li>
        <li> return, break, continue の不適切な使用</li>
        <li>(例えば、代入文 3=4 を実行する等)リファレンスではない値を生成されることが可能な初期決定における任意の値上で PutValue を呼ぶ試行</li>
    </ul>
    <p>
        　実装は、いかなる状況においてもエラーなく実行できない構成であることを裏付けることが可能なコンパイラであったとしても初期エラーとして他の種類のエラーを扱わないようにしましょう。
        実装は、そのようなケースにおいては初期警告を発する場合があるにしても関連する構成が、実際に実行されるまでは、エラーを報告すべきではありません。
    </p>

    <p>
        　実装は、次の場合を除き、既に記述したように全てのエラーを報告しましょう。
    </p>
    <ul>
        <li>実装が、プログラム構文、正規表現構文、フラグ構文などを拡張する可能性がある場合<br/>これを許容するということは、( eval の呼び出し、正規表現リテラルの使用、
            FunctionコンストラクタやRegExpコンストラクタの使用のような)全ての操作は、プログラム構文、正規表現構文、フラグ構文などへの実装定義の拡張に遭遇する場合、SyntaxErrorを投げる(スローする)代わりに実装定義の動作を表す為に実行されるSyntaxErrorを投げる(スローする)ことが許容されるという事です。
        </li>
        <li>実装が、この仕様内で説明したそれらを超える型、値、オブジェクト、プロパティ、関数を提供する場合<br/>これは、( ReferenceError
            のような)エラーを投げる(スローする)代わりに実装定義の動作を持つように(グローバルスコープ内で変数を探すような)構成の要因となる場合があります。
        </li>
        <li>実装が、 fractionDigits (小数の桁)引数や precision (精度)引数が、指定した範囲を超える際に toFixed, toExponential, toPrecision
            の為にRangeErrorを投げる(スローする)のではなく、動作を定義する場合
        </li>
    </ul>


</article>
<article>


    <h2>付録 A (有用情報) 文法の要約 </h2>


    <h3>付録 A (有用情報) 文法の要約</h3>

    <p><a href="">A.1 語彙的な文法</a></p>

    <p><a href="">A.2 Number 変換</a></p>

    <p><a href="">A.3 式</a></p>

    <p><a href="">A.4 ステートメント・文</a></p>

    <p><a href="">A.5 関数とプログラム</a></p>

    <p><a href="">A.6 Universal Resource Identifier / URI 文字クラス</a></p>

    <p><a href="">A.7 正規表現</a></p>

    <p><a href="">A.8 JSON</a></p>

    <p>--<a href="">A.8.1 JSONの語彙的な文法</a></p>

    <p>--<a href="">A.8.2 JSON構文の文法</a></p>


</article>
<article>


<h2>付録 B (有益な情報) 互換性 Standard ECMA-262 5.1 Edition</h2>


<h3>付録 B (有益な情報) 互換性</h3>

<h3>B.1 追加構文</h3>

<p>
    　ECMAScriptの過去の版(エディション)には、8進数リテラルと8進数エスケープシーケンス指定の為の追加構文と追加セマンティックスが含まれていました。
    (しかし、)これらは、ECMAScriptのこの版(エディション)からは削除されています。
    この非標準の添付書では、一部の古いECMAScriptプログラムに伴う互換性において8進数リテラルと8進数エスケープシーケンスの為の一定の構文とセマンティックスを提示します。
</p>

<h3>B.1.1 数値リテラル</h3>

<p>
    　 7.8.3 の構文とセマンティックスは、strictモードのコードにおいて許容されないこの拡張を除き、次のように拡張することが可能です。
</p>

<div class="pre-div">
<pre>
【構文】
NumericLiteral ::
	DecimalLiteral
	HexIntegerLiteral
	OctalIntegerLiteral

OctalIntegerLiteral ::
	0 OctalDigit
	OctalIntegerLiteral OctalDigit

OctalDigit ::
	0 1 2 3 4 5 6 7
の内の1つ
</pre>
</div>

<div class="pre-div">
<pre>
【セマンティックス】
・ NumericLiteral の  MV  :: OctalIntegerLiteral は、 OctalIntegerLiteral の MV
・ OctalDigit の  MV  :: 0 は、 0
・ OctalDigit の  MV  :: 1 は、 1
・ OctalDigit の  MV  :: 2 は、 2
・ OctalDigit の  MV  :: 3 は、 3
・ OctalDigit の  MV  :: 4 は、 4
・ OctalDigit の  MV  :: 5 は、 5
・ OctalDigit の  MV  :: 6 は、 6
・ OctalDigit の  MV  :: 7 は、 7
・ OctalIntegerLiteral の  MV :: 0 OctalDigit は、 OctalDigit の MV
・ OctalIntegerLiteral の  MV :: OctalIntegerLiteral OctalDigit は、 ( OctalIntegerLiteral の MV 8通り ) OctalDigit の MV をプラス
</pre>
</div>

<h3>B.1.2 文字列リテラル</h3>

<p>
    　 7.8.4 の構文とセマンティックスは、strictモードのコードにおいて許容されないこの拡張を除き、次のように拡張することが可能です。
</p>

<div class="pre-div">
<pre>
【構文】
EscapeSequence ::
	CharacterEscapeSequence
	OctalEscapeSequence
	HexEscapeSequence
	UnicodeEscapeSequence

OctalEscapeSequence ::
	OctalDigit[lookahead ? DecimalDigit]
	ZeroToThree OctalDigit [lookahead ? DecimalDigit]
	FourToSeven OctalDigit
	ZeroToThree OctalDigit
(？は、∈の否定形)

OctalDigit ZeroToThree ::
	0 1 2 3
の1つ

FourToSeven ::
	4 5 6 7
の1つ
</pre>
</div>

<div class="pre-div">
<pre>
【セマンティックス】
・  EscapeSequence の CV  :: OctalEscapeSequence は、OctalEscapeSequence の CV
・  OctalEscapeSequence の CV  :: OctalDigit [lookahead ? DecimalDigit] は、 コードユニット値が OctalDigit の  MV である文字
・  OctalEscapeSequence の CV  :: ZeroToThree OctalDigit [lookahead ? DecimalDigit] は、 コードユニット値が ( ZeroToThree の  MV を8通り) OctalDigit の  MV をプラス
・  OctalEscapeSequence の CV  :: FourToSeven OctalDigit は、 コードユニット値が  (  FourToSeven の  MV を8通り) OctalDigit の  MV をプラス
・  OctalEscapeSequence の CV  :: ZeroToThree OctalDigit OctalDigit は、 コードユニット値が ( ZeroToThree の MV の64(つまり8の2乗)通り) プラス (8 times the MV of the first OctalDigit の MV 8通り) プラス 2つめの OctalDigit の MV の文字
・  ZeroToThree の  MV  :: 0 は、 0
・  ZeroToThree の  MV  :: 1 は、 1
・  ZeroToThree の  MV  :: 2 は、 2
・  ZeroToThree の  MV  :: 3 は、 3
・  FourToSeven の  MV  :: 4 は、 4
・  FourToSeven の  MV  :: 5 は、 5
・  FourToSeven の  MV  :: 6 は、 6
・  FourToSeven の  MV  :: 7 は、 7
</pre>
</div>

<h3>B.2 追加プロパティ</h3>

<p>
    　ECMAScriptの一部の実装は、標準ネイティブオブジェクトの一部について追加プロパティを含みます。
    この非標準の添付書では、この標準規格のプロパティやそれらのセマンティックス部分を作成することなく、このようなプロパティと同一のセマンティックスを示唆しています。
</p>

<h3>B.2.1 escape (string)</h3>

<p>
    　 escape関数は、グローバルオブジェクトのプロパティです。
    16進数エスケープシーケンスによって置換される特定の文字において文字列値の新しいバージョンを算出します。
    それらの文字については、コードユニット値が 0xFF 、または、より小さい場合、書式 %xx という2ケタのエスケープシーケンス付きで置換されます。
    それらの文字については、コードユニット値が 0xFF より大きい場合、書式 %uxxxx という4ケタ以下のエスケープシーケンス付きで置換されます。
</p>

<p>
    　 escape関数は、引数 string を1つ取って呼ばれる際には、次のステップが取られます。
</p>

<div class="pre-div">
<pre>
1. ToString(string) を呼ぶ
2. 1項の結果内の文字数を算出する
3. R は、カラの文字列とする
4. k は、0とする
5. k が、2項の数と等しい場合、R を返す
6. 1項の結果内の位置 k にある(16ビット符号なし整数として表現した)文字を取得する
7. 6項の結果が、ブランクのない69文字“ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789@*_+-./” である場合、ステップ13へ
8. 6項の結果が、256よりも小さい場合、ステップ11へ
9.  wxyz が、6項の結果の値である4つの16進数のエンコード方式である場合、 S は、“%uwxyz”という6文字を含んだ文字列とする
10.ステップ14へ
11. xy が、6項の結果の値である2つの16進数のエンコード方式である場合、 S は、“%xy”という3文字を含んだ文字列とする
12.ステップ14へ
13. S は、単一文字である6項の結果を含む文字列とする
14. R は、 R の前の値 と S を連結することによって算出した新たな文字列値とする
15. k を1で増分する
16. ステップ5へ
</pre>
</div>

<p>
    [注釈]
</p>

<p>
    　エンコード方式は、部分的に RFC 1738 で説明したエンコード方式に基づきますが、 全体としては、RFC 1738 の内容とみなすことなく上記で説明されるこの標準規格内で指定したエンコード方式となります。
    このエンコード方式は、 RFC 3986 によってなされた RFC 1738 への変更の影響は受けません。
</p>

<h3>B.2.2 unescape (string)</h3>

<p>
    　 unescape関数は、グローバルオブジェクトのプロパティです。
    それは、ソート済みのエスケープシーケンスにおいて文字列値の新たなバージョンを算出し、それが表す文字で置換されるescape関数によって導入される場合があります。
</p>

<p>
    　 unescape関数が、引数 string を1つ伴って呼ばれる際には、次のステップが取られます。
</p>

<div class="pre-div">
<pre>
1. ToString(string) を呼ぶ
2. 1項の結果内の文字数を算出する
3. R は、カラの文字列とする
4. k は、0とする
5. k が、2項の数と等しい場合、R を返す
6. c は、1項の結果の位置 k にある文字とする
7. c が、 % ではない場合、ステップ18へ
8. k が、 2項の結果-6 よりも大きい場合、ステップ14へ
9. 1項の結果の位置 k+1 にある文字が、 u ではない場合、ステップ14へ
10. 1項の結果の位置 k+2, k+3, k+4, k+5 にある4文字が、全て16進数値ではない場合、ステップ14へ
11. c は、 1項の結果の位置 k+2, k+3, k+4, k+5 にある4つの16進数値によって表した整数であるコードユニット値を持つ文字とする
12. k を5で増分する
13. ステップ18へ
14. k が、2項の結果-3 より大きい場合、ステップ18へ
15. 1項の結果の位置 k+1 と k+2 にある2文字が、共に16進数ではない場合、ステップ18へ
16. c は、2つのゼロにプラス1項の結果内の位置 k+1 と k+2 にある2つの16進数値によって表した整数であるコードユニット値を持つ文字とする
17. kを2で増分する
18. R は、 Rの前の値 と c を連結することによって算出した新たな文字列値とする
19. kを1で増分する
20.ステップ5へ
</pre>
</div>

<h3>B.2.3 String.prototype.substr (start, length)</h3>

<p>
    　 substrメソッドは、 start と length という2つの引数を取り、このオブジェクトを文字位置 start から始まり、 length 文字め(、または、 length が、 undefined
    である場合、当該文字列の末尾)まで走査し、変換した結果の部分文字列を返します。
    start が、負の値である場合、 sourceLength が、文字列の length である場合、 (sourceLength+start) として扱われます。
    その結果は、String値であってStringオブジェクトではありません。
</p>

<p>
    　(substrメソッドは、)次のステップが取られます。
</p>

<div class="pre-div">
<pre>
1. ToStringを呼び、その引数として this 値を与える
2. ToInteger(start) を呼ぶ
3. length が、 undefined である場合、+∞ を使用し、それ以外の場合、 ToInteger(length) を呼ぶ
4. 1項の結果にある文字数を算出する
5. 2項の結果が、正の値または、ゼロである場合、2項の結果を使用し、それ以外の場合、 max(Result(4)+Result(2),0) を使用する
6. min(max(Result(3),0), Result(4)-Result(5)) を算出する(3項、4項、5項の結果を使用して算出)
7. 6項の結果 ≦ 0 となる場合、カラの文字列 "" を返す
8. 5項の結果の位置にある文字を伴って始まる1項の結果から6項の結果が連続する複数文字を含む文字列を返す
</pre>
</div>

<p>
    　 substrメソッドのlengthプロパティは、2です。
</p>

<p>
    [注釈]
</p>

<p>
    　 substr関数は、汎用的であることが意図され、this 値がStringオブジェクトとなることを要求しません
    その為、メソッドとして使用される場合、オブジェクトの他の種類に転送することが可能です。
</p>

<h3>B.2.4 Date.prototype.getYear ( )</h3>

<p>
    [注釈]
</p>

<p>
    　2000年問題を回避することから(このgetYearよりも) getFullYear メソッドの方が、ほぼ全ての目的において好まれます。
</p>

<p>
    　 getYearメソッドが、引数を伴わずに呼ばれる際には、次のステップが取られます。
</p>

<div class="pre-div">
<pre>
1. t は、this 時間値とする
2. t が、 NaN である場合、NaN を返す
3. YearFromTime(LocalTime(t)) - 1900 を返す
</pre>
</div>

<h3>B.2.5 Date.prototype.setYear (year)</h3>

<p>
    [注釈]
</p>

<p>
    　2000年問題を回避することから(このsetYearよりも) setFullYear メソッドの方が、ほぼ全ての目的において好まれます。
</p>

<p>
    　 setYearメソッドが、 year という引数1つを伴って呼ばれる際には、次のステップが取られます。
</p>

<div class="pre-div">
<pre>
1. t は、 LocalTime(this time value) の結果とするが、 this 時間値が、 NaN である場合、 t は、 +0 とする
2. ToNumber(year) を呼ぶ
3. 2項の結果が、NaN である場合、 this 値の内部プロパティ[[PrimitiveValue]]にNaNを設定し、NaNを返す
4. 2項の結果が、NaN ではなく、且つ、 0 ≦ ToInteger(Result(2)) ≦ 99 (2項の結果を代入)である場合、  ToInteger(Result(2)) + 1900 とし、それ以外の場合、4項の結果は、2項の結果とする
5. MakeDay(Result(4), MonthFromTime(t), DateFromTime(t)) を算出する
6. UTC(MakeDate(Result(5), TimeWithinDay(t))) を算出する
7. this 値の内部プロパティ[[PrimitiveValue]]に TimeClip(Result(6)) を設定する
8. this 値の内部プロパティ[[PrimitiveValue]] の値を返す
</pre>
</div>

<h3>B.2.6 Date.prototype.toGMTString ( )</h3>

<p>
    [注釈]
</p>

<p>
    　(この toGMTString よりも)プロパティ toUTCString が好んで使用されます。
    toGMTString プロパティは、古いコードを伴う互換性の為に主に提供されます。
    新たなECMAScriptコード内で使用される toUTCString プロパティが推奨されます。
</p>

<p>
    　 Date.prototype.toGMTString の初期値であるFunctionオブジェクトは、 Date.prototype.toUTCString の初期値であるFunctionオブジェクトと同一です。
</p>


</article>
<article>


    <h2>付録 C (有益な情報) ECMAScriptのStrictモード </h2>


    <h3>付録 C (有益な情報) ECMAScriptのStrictモード</h3>

    <h3>strictモードの制限と例外</h3>
    <ul>
        <li>Identifier(識別子) "implements", "interface", "let", "package", "private", "protected", "public", "static",
            "yield" は、strictモード ( 7.6.12 )内のトークン(字句) FutureReservedWord(将来の予約語) として分類されます。
        </li>
        <li>準拠する実装は、strictモードのコードを処理中は、 B.1.1 で説明したように OctalIntegerLiteral を含む為に NumericLiteral
            (7.8.3)の構文を拡張しない場合があります。
        </li>
        <li>準拠する実装は、strictモードのコードを処理中 ( 10.1.1 参照)は、 B.1.2 で説明したように OctalEscapeSequence(8進エスケープシーケンス) を含む為に
            EscapeSequence(エスケープシーケンス) の構文を拡張しない場合があります。
        </li>
        <li>宣言されていない識別子やそれ以外の未解決の参照への関連付けについては、グローバルオブジェクト内でプロパティを生成しません。
            単純な関連付けが、strictモードのコード内に現れる場合、その LeftHandSide は、未解決のReference(参照)を評価してはいけません。
            評価するとReferenceError例外が投げられ(スローされ)ます(8.7.2)。
            LeftHandSide(左辺) は、また、属性値 {[[Writable]]:false} を伴うデータプロパティ、属性値 {[[Set]]:undefined}
            を伴うアクセサプロパティや内部プロパティ[[Extensible]]が値 false を持つオブジェクトの実在しないプロパティへの参照にはならない場合があります。
            これらのケースについては、TypeError例外が投げられ(スローされ)ます(11.13.1)。
        </li>
        <li>Identifier(識別子) eval や引数は、代入演算子(11.13)や PostfixExpression(後置式) (11.3)の
            LeftHandSideExpression(左辺式)として、または、前置増分演算子(11.4.4)や減分演算子(11.4.5)によって操作した UnaryExpression(単項式)として現れない場合があります。
        </li>
        <li>strictモードの関数における引数オブジェクトは、アクセス上のTypeError例外を投げる(スローする)場合、 "caller" と "callee"
            と名付けた設定なしのアクセサプロパティを定義します(10.6)。
        </li>
        <li>strictモードの関数における引数オブジェクトは、それらの関数の関連付けをする正規のパラメータと一致するプロパティ値をインデックスしたそれらの配列を直接共有しません。(10.6)。</li>
        <li>strictモードの関数においては、引数オブジェクトが、当該引数オブジェクトへのローカル識別子の引数の関連付けを生成した場合、不変であり、その為、関連付ける式のターゲットとならない場合があります(10.5)。
        </li>
        <li>strictモードのコードが、一部のデータプロパティ(11.1.5)の1つ以上の定義を伴う ObjectLiteral を含む場合、SyntaxErrorです。</li>
        <li>Identifier(識別子) "eval" やIdentifier(識別子) "arguments" が、任意の PropertyAssignment(プロパティの関連付け) の任意の
            PropertySetParameterList(プロパティへのパラメータリスト設定) 内にあるIdentifier(識別子)として現れ、それが厳格(strict)なコード内に含まれる場合や、その
            FunctionBody(関数本体) が、strictモードのコードである場合には、SyntaxErrorです。
        </li>
        <li>Strictモードの eval コードは、 eval への caller の環境変数内で変数や関数をインスタンス化することはできません。
            その代わり、新しい環境変数が生成され、その環境は、当該 eval コードにおけるインスタンス化をバインディングする定義の為に使用されます(10.4.2)。
        </li>
        <li> this が、strictモードのコード内で評価される場合、 this 値は、オブジェクトに強制変換されます。
            null や undefined である this 値は、グローバルオブジェクトに変換されませんし、プリミティブ(原始的な)値は、ラッパオブジェクトには変換されません。
            ( Function.prototype.apply と Function.prototype.call を使用させる呼び出しを含む)関数呼び出し経由で解析した this 値は、解析した this
            値をオブジェクトに強制変換することはありません(10.4.3, 11.1.1, 15.3.4.3, 15.3.4.4)。
        </li>
        <li>delete演算子が、strictモードのコード内に現れる場合、その UnaryExpression(単項式)
            が、直接変数、関数の引数、関数名等を参照する場合、SyntaxErrorが投げられ(スローされ)ます(11.4.1)。
        </li>
        <li>delete演算子が、strictモードのコード内に現れる場合、その削除されるプロパティが、属性 { [[Configurable]]:false }
            を持つ場合、TypeErrorが投げられ(スローされ)ます(11.4.1)。
        </li>
        <li> VariableDeclaration(変数宣言) や VariableDeclarationNoIn(変数宣言なし) が、厳格な(strict)コード内に現れたり、そのIdentifier(識別子)が、 eval
            や arguments である場合、SyntaxErrorです(12.2.1)。
        </li>
        <li>Strictモードのコードは、 WithStatement( with 文) を含まない場合があります。
            このような文脈における WithStatement( with 文) の出現は、SyntaxErrorです(12.10)。
        </li>
        <li> Catch を伴う TryStatement( try 文) が、strictモードのコード内に現れたり、そのIdentifier(識別子)が、 eval や arguments
            である場合、SyntaxErrorです(12.14.1)。
        </li>
        <li>Identifier(識別子) eval や arguments が、strictモードの FunctionDeclaration(関数宣言) や FunctionExpression(関数式) の任意の
            FormalParameterList(正規のパラメータリスト) 内に現れる場合、SyntaxErrorです(13.1)。
        </li>
        <li>strictモードの関数は、同じ名称を持つ2つ以上の正規のパラメータを持たない場合があります。
            FunctionDeclaration(関数宣言)、FunctionExpression(関数式)、Functionコンストラクタ を使って関数を生成する試行は、 SyntaxErrorです (13.1,
            15.3.2)。
        </li>
        <li>実装は、 caller と名付けたプロパティのstrictモードの関数や関数のインスタンスの引数という意味においてこの仕様内で定義した範囲を超えて拡張しない場合があります。
            ECMAScriptのコードは、strictモードの関数と一致する関数オブジェクト上でこれらの名称を持つプロパティを生成または編集しない場合があります( 10.6, 13.2, 15.3.4.5.3)。
        </li>
        <li> FunctionDeclaration(関数宣言) や FunctionExpression(関数式) のIdentifierとして、または、正規のパラメータ名としてIdentifier(識別子) eval や
            argments をstrictモードのコード内で使用することは、SyntaxErrorです(13.1)。
            Functionコンストラクタ(15.3.2)を使用してこのようなstrictモードの関数を直接定義する試行には、SyntaxError例外を投げる(スローする)でしょう。
        </li>
    </ul>


</article>
<article>


    <h2>付録 D (有益な情報) 利用可能な第3版互換性への影響を伴う第5版での訂正事項と明確化 </h2>


    <h3>付録 D (有益な情報) 利用可能な第3版互換性への影響を伴う第5版での訂正事項と明確化</h3>
    <h4>全体を通して:</h4>

    <p>
        　第3版仕様にあった"式 new Array() によるかのような"のようなフレーズの意味は、誤解の対象となります。
    </p>

    <p>
        　第5版仕様では、全ての内部参照と標準組み込みオブジェクト、メソッド全てにおけるテキストは、現在、一致する名前付きプロパティの動的な値ではなく、その意図は、実際の組み込みオブジェクトが使用されることであり、それを明示的にさせることによって明確にしています。
    </p>

    <h4>11.8.2, 11.8.3, 11.8.5:</h4>

    <p>
        　ECMAScriptでは一般に評価順を左から右に使用しますが、エディション3仕様の言語では、 &gt; と &lt;= 演算子については、部分的に右から左の順に結果を出していました。
    </p>

    <p>
        　仕様書では、現在、全ての評価順を左から右に指定するようにこれらの演算子について修正されています。
    </p>

    <p>
        　しかしながら、この順序の変更は、評価処理中に副作用が現れる場合、潜在的に観測可能となっています。
    </p>

    <h4>11.1.4:</h4>

    <p>
        　第5版では、 ArrayInitialiser の末尾にある後続するカンマは、配列の大きさに追加しないという事実を明確にしておきます。
    </p>

    <p>
        　これは、第3版仕様からのセマンティック変更ではありませんが、一部の実装では、この誤解を以前から持つ場合があります。
    </p>

    <h4>11.2.3:</h4>

    <p>
        　第5版では、当該アルゴリズムのステップ2と3の順を逆転させています。
    </p>

    <p>
        　エディション1～3内で指定したようにオリジナルの順は、 MemberExpression (メンバ式)を評価した結果に影響する可能性がある Arguments を評価中の副作用のように間違った指定でした。
    </p>

    <h4>12.4:</h4>

    <p>
        　第3版では、tryステートメントの catch 句に渡した例外パラメータの名称解決におけるスコープとして提供する new Object() によるかのように任意のオブジェクトが生成されます。
    </p>

    <p>
        　実際の例外オブジェクトが、関数で且つ、 catch 句の中から呼ばれる場合、そのスコープのオブジェクトは、その呼び出しの this 値として渡されるでしょう。
    </p>

    <p>
        　関数の本体は、その後、その this 値上に新たなプロパティを定義し、それらのプロパティは、関数が返した後に catch 句のスコープ内にあるバインディングする識別子が見えるようになります。
    </p>

    <p>
        　第5版では、例外パラメータが関数として呼ばれる場合、 this 値として undefined (未定義)が、渡されます。
    </p>

    <h4>13:</h4>

    <p>
        　第3版では、任意の識別子を伴うプロダクション FunctionExpression (関数式)は、関数の名称を検索する為のスコープとして提供する為のスコープチェーンに new Object()
        によるかのように生成したオブジェクトを追加します。
    </p>

    <p>
        　このようなオブジェクトに適用する識別子解決の規則(第3版の 10.1.4 )は、識別子を解決する為に試行される際には、おそらく必要に応じてオブジェクトのプロトタイプチェーンに続くでしょう。
    </p>

    <p>
        　これは、そのスコープ内にある識別子として可視である Object.prototype のプロパティ全てを意味します。
    </p>

    <p>
        　実際には、第3版に完全に準拠している実装は、このセマンティックスを実装していません。
    </p>

    <p>
        　第5版では、その関数の名称をバインドする宣言型環境レコードを使用することによって指定したセマンティックスを変更します。
    </p>

    <h4>14:</h4>

    <p>
        　第3版では、プロダクション
    </p>

    <div class="pre-div">
<pre>
SourceElements : SourceElements SourceElement
</pre>
    </div>

    <p>
        におけるアルゴリズムは、Blockと同じ方法で値を出す文を正しく伝達するようにはなりません。
    </p>

    <p>
        　これは、Programのテキスト評価中に誤った結果を生成してしまう eval 関数内で結果を得ることが可能でした。
    </p>

    <p>
        　実際には、第3版に完全に準拠している実装は、第5版で指定したものではなく、正確な伝達が実装されています。
    </p>

    <h4>15.10.6:</h4>

    <p>
        　 RegExp.prototype は、現在、オブジェクトのインスタンスではなく、 RegExp オブジェクトとなっています。
    </p>

    <p>
        　 Object.prototype.toString を使用することによって観測可能なその内部プロパティ[[Class]]の値は、現在、"Object"ではなく、"RegExp"となっています。
    </p>


</article>
<article>


<h2>付録 E (有益な情報) 第3版と非互換として導入する第5版での追加と変更 </h2>


<h3>付録 E (有益な情報) 第3版と非互換として導入する第5版での追加と変更</h3>
<h4>7.1:</h4>

<p>
    　Unicode形式の制御文字が、処理する前にECMAScriptのソーステキストから取り除かれることは、もはや、なくなりました。
</p>

<p>
    　第5版では、そのような文字が、 StringLiteral や RegularExpressionLiteral
    内に現れる場合、その文字が、リテラルに組み込まれないであろう第3版の文字の中にあるリテラルに組み込まれることはないでしょう。
</p>

<h4>7.2:</h4>

<p>
    　Unicode文字 &lt;BOM&gt;
    は、識別子となって現れる途中にあるその存在は、第3版では(実際には)発生しなかったと思われる構文エラーの中で結果として現れる可能性がありましたが、現在は、ホワイトスペースとして扱われるようになっています。
</p>

<h4>7.3:</h4>

<p>
    　エスケープシーケンスが先行する行終端文字は、現在、文字列リテラルトークン(文字どおりの字句)内にあることも許容されるようになっています。
</p>

<p>
    　(ちなみに)第3版では、(この場合、)構文エラーが、出されていたことでしょう。
</p>

<h4>7.8.5:</h4>

<p>
    　正規表現リテラルは、現在、当該リテラルが評価される都度、一意のオブジェクトを返すようになっています。
</p>

<p>
    　この変更により、そのようなリテラル値の当該オブジェクトの素性をテストしたり、共有した副作用に敏感な任意のプログラムによって検出されます。
</p>

<h4>7.8.5:</h4>

<p>
    　第5版は、RegExp オブジェクト を RegularExpressionLiteral に変換する際に生成されるであろう利用可能なRegExpコンストラクタのエラーについて初期に報告することを要求します。
</p>

<p>
    　第5版より以前の実装は、実際のオブジェクトの生成実行時までそのようなエラーを報告することを遅延させていました。
</p>

<h4>7.8.5:</h4>

<p>
    　第5版では、復号・復号化(アンエスケープ)した "/" (スラッシュ)文字が、正規表現リテラル内で任意の CharacterClass として現れる場合があります。
</p>

<p>
    　第3版では、そのような文字は、リテラルの末尾の文字として解釈されていたことでしょう。
</p>

<h4>10.4.2:</h4>

<p>
    　第5版では、 eval コードにおける環境変数と語彙的な環境両方であるものとしてグローバル環境を使用する eval 関数を間接的に呼びます。
</p>

<p>
    　第3版では、間接的な eval における caller の変数と語彙的な環境は、 eval コード(自体)における環境として使用されていました。
</p>

<h4>15.4.4:</h4>

<p>
    　第5版では、 Array.prototype の全てのメソッドは、汎用的であることが意図されます。
</p>

<p>
    　第3版では、 toString と toLocaleString は、汎用的ではありませんでしたから、Arrayのインスタンスではないオブジェクトに適用した場合、TypeError例外を投げる(スローする)でしょう。
</p>

<h4>10.6:</h4>

<p>
    　第5版では、引数オブジェクトのプロパティをインデックスした配列は、列挙される実際の正規パラメータと一致します。
</p>

<p>
    　第3版では、そのようなプロパティは、列挙されませんでした。
</p>

<h4>10.6:</h4>

<p>
    　第5版では、引数オブジェクトの内部プロパティ[[Class]]の値は、"Arguments"です。
</p>

<p>
    　第3版では、それは、"Object"でした。
</p>

<p>
    　これにより toString が、引数オブジェクトのメソッドとして呼ばれる際には、観測可能となっています。
</p>

<h4>12.6.4:</h4>

<p>
    　 for-in 文は、もはや null や undefined を評価する式では、TypeErrorを投げ(スローし)ないようになっています。
</p>

<p>
    　代わりにその文は、式の値が、何も列挙されないプロパティを伴うオブジェクトであった場合のように動作します。
</p>

<h4>15:</h4>

<p>
    　第5版内では、次の新しいプロパティは、第3版に存在する組み込みオブジェクトについて定義されます。
</p>

<div class="pre-div">
<pre>
Object.getPrototypeOf ,
Object.getOwnPropertyDescriptor ,
Object.getOwnPropertyNames ,
Object.create ,
Object.defineProperty ,
Object.defineProperties ,
Object.seal ,
Object.freeze ,
Object.preventExtensions ,
Object.isSealed ,
Object.isFrozen ,
Object.isExtensible ,
Object.keys ,
Function.prototype.bind ,
Array.prototype.indexOf ,
Array.prototype.lastIndexOf ,
Array.prototype.every ,
Array.prototype.some ,
Array.prototype.forEach ,
Array.prototype.map ,
Array.prototype.filter ,
Array.prototype.reduce ,
Array.prototype.reduceRight ,
String.prototype.trim ,
Date.now ,
Date.prototype.toISOString ,
Date.prototype.toJSON
</pre>
</div>

<h4>15:</h4>

<p>
    　実装は、現在、明示的に指定されない限り、標準組み込みメソッドについて外部の引数を無視することが要求されることになっています。
</p>

<p>
    　第3版では、外部引数の操作については指定されておらず、実装は、明示的にTypeError例外を投げる(スローする)ことが許容されていました。
</p>

<h4>15.1.1:</h4>

<p>
    　Globalオブジェクトの値プロパティ NaN、∞、undefinedは、読み取り専用プロパティとするように変更されています。
</p>

<h4>15.1.2.1:</h4>

<p>
    　実装は、もはや直接呼ばれない方法において eval の使用を制限することを許容されなくなりました。
</p>

<p>
    　追記すると任意の eval の呼び出しは、 caller の変数環境ではなく、その( eval の)変数環境としてグローバル環境を使用する直接呼び出しではなくなっています。
</p>

<h4>15.1.2.2:</h4>

<p>
    　関数 parseInt の仕様は、もはや8進数値としての0を伴って始まる文字列を扱うことを実装に許容しなくなりました。
</p>

<h4>15.3.4.3:</h4>

<p>
    　第3版では、2つめの引数が、配列オブジェクトや引数オブジェクトの何れでもない Function.prototype.apply に渡される場合、TypeErrorが、投げられ(スローされ)ます。
</p>

<p>
    　第5版では、2つめの引数は、有効な length プロパティを持つ任意の一般的な配列風のオブジェクトの種類となる場合があります。
</p>

<h4>15.3.4.3, 15.3.4.4:</h4>

<p>
    　第3版では、 Function.prototype.apply や Function.prototype.call の何れかに1つめの引数として undefined や null を渡すとGlobalオブジェクトが、 this
    値として間接的に呼び出した対象となる関数に渡される要因になります。
</p>

<p>
    　1つめの引数が、プリミティブ(原始的な)値である場合、 this 値として渡されるプリミティブ(原始的な)値上で ToObject を呼んだ結果とします。
</p>

<p>
    　第5版では、これらの変換は、実行されず、実際の1つめの引数は、 this 値として渡されます。
</p>

<p>
    　この違いは、対象となる関数を実行する変換と一致する為、通常は、既存のECMAScript第3版には見られることではないでしょう。
</p>

<p>
    　しかしながら、実装によっては、この違いが、 apply や call を使って呼んだホストオブジェクト関数に見られる場合があります。
</p>

<p>
    　追記すると this 値として渡した null や undefined を伴うこの方法で標準組み込み関数を呼び出すと、多くの場合、第3版の動作とは異なる第5版での実装における動作をするでしょう。
</p>

<p>
    　特に第5版の組み込み関数は、 this 値として null や undefined を渡した場合、一般にTypeError例外を投げる(スローする)任意のオブジェクトとして、渡した this 値を実際に使用する為に指定されます。
</p>

<h4>15.3.5.2:</h4>

<p>
    　第5版では、Functionインスタンスのプロトタイププロパティは、列挙されません。
</p>

<p>
    　第3版では、このプロパティは、列挙されました。
</p>

<h4>15.5.5.2:</h4>

<p>
    　第5版では、Stringオブジェクトの[[PrimitiveValue]の個々の文字は、Stringオブジェクトのプロパティをインデックスした配列としてアクセスされる場合があります。
</p>

<p>
    　これらのプロパティは、書き込み不可、かつ、設定不可であり、同名の継承したプロパティを覆い(シャドウし)ます。
</p>

<p>
    　第3版では、これらのプロパティは、存在せず、ECMAScriptのコードは、そのような名称を持つ書き込み可能なプロパティを動的に追加または削除可能であり、そのような名称を持つ継承したプロパティにアクセスすることが可能でした。
</p>

<h4>15.9.4.2:</h4>

<p>
    　 Date.parse は、現在、最初に ISO フォーマット文字としてその引数を解析する試行を要求するようになっています。
</p>

<p>
    　このフォーマットを使用する一方、(失敗(failure)を含む)実装仕様固有の動作に依存しないプログラムは、異なる動作をする場合があります。
</p>

<h4>15.10.2.12:</h4>

<p>
    　第5版では、 \s は、併せて &lt;BOM&gt; ともマッチするようになっています。
</p>

<h4>15.10.4.1:</h4>

<p>
    　第3版では、オブジェクトのソースプロパティのString値の書式は、実装定義であるRegExpコンストラクタによって正確に生成しました。
</p>

<p>
    　第5版では、Stringは、特定の指定した必要条件と一致しなければならず、その為、第3版の実装によって生成した書式とは異なる場合があります。
</p>

<h4>15.10.6.4:</h4>

<p>
    　第3版では、 RegExp.prototype.toString の結果は、RegExpオブジェクトのソースプロパティから伝送される必要はありませんでした。
</p>

<p>
    　第5版では、その結果は、特定の方法でソースプロパティから伝送されなければならず、その為、第3版の実装によって生成した結果から伝送される場合があります。
</p>

<h4>15.11.2.1, 15.11.4.3:</h4>

<p>
    　第5版では、Errorオブジェクトのmessageプロパティにおける初期値が、Errorコンストラクタ経由で指定されない場合、プロパティの初期値は、カラの文字列となります。
</p>

<p>
    　第3版では、このような初期値は、実装定義とされていました。
</p>

<h4>15.11.4.4:</h4>

<p>
    　第3版では、 Error.prototype.toString の結果は、実装定義です。
</p>

<p>
    　第5版では、その結果は、完全に特定され、その為、一部の第3版の実装とは異なる場合があります。
</p>

<h4>15.12:</h4>

<p>
    　第5版では、名称 JSON は、グローバル環境で定義されます。
</p>

<p>
    　第3版では、名称の存在についてのテストを行うとプログラムや実装で定義されない限りは、undefined (未定義)であることが示されるでしょう。
</p>


</article>
<article>


<h2>付録 F (有益な情報) 第5.1版での技術的に重要な訂正事項と明確化 Standard ECMA-262 5.1 Edition</h2>


<h3>付録 F (有益な情報) 第5.1版での技術的に重要な訂正事項と明確化</h3>
<h4>7.8.4:</h4>

<p>
    　 CV定義は、DoubleStringCharacter :: LineContinuation と SingleStringCharacter :: LineContinuation について追加しました。
</p>

<h4>10.2.1.1.3:</h4>

<p>
    　引数 S は、無視されます。
</p>

<p>
    　それは、恒久的なバインディングの設定を試行する際に例外が投げられる(スローされる)かどうかを制御します。
</p>

<h4>10.2.1.2.2:</h4>

<p>
    　アルゴリズムのステップ 5 では、trueは、[[DefineOwnProperty]]への最後の引数として渡されます。
</p>

<h4>10.5:</h4>

<p>
    　ステップ 5.e の前者のアルゴリズムは、現在、 5.f となるようになっており、新しいステップ 5.e は、グローバル関数を再定義する際に第3版との互換性を復元する為に追加されていました。
</p>

<h4>11.5.3:</h4>

<p>
    　箇条書きの最後のアイテムには、 IEEE 754 round-to-nearest (近似値への丸め処理)モードの使用が指定されます。
</p>

<h4>12.6.3:</h4>

<p>
    　欠落した ToBoolean は、双方のアルゴリズムのステップ 3.a.ii の中で復元しました。
</p>

<h4>12.6.4:</h4>

<p>
    　2つの段落のそれぞれに追加した最後の文章は、特定のプロパティの列挙の要件を明確にします。
</p>

<h4>12.7, 12.8, 12.9:</h4>

<p>
    　 BNF / Backus-Naur Form (バッカス・ナウア記法)は、任意の式がセミコロンの前にLineTerminatorを持つことなく、識別子や文を返すことなく、 continue 文や break
    文を明確にする為に修正されました。
</p>

<h4>12.14:</h4>

<p>
    　アルゴリズム1のステップ 3 とアルゴリズム3のステップ 2.a は、Bそれ自身ではなく、Bの値項目のように補正されます。
</p>

<h4>15.1.2.2:</h4>

<p>
    　アルゴリズムのステップ 2 では、 S が、カラの文字列となる場合があることを明確にします。
</p>

<h4>15.1.2.3:</h4>

<p>
    　アルゴリズムのステップ 2 では、 trimmedString が、カラの文字列となる場合があることを明確にします。
</p>

<h4>15.1.3:</h4>

<p>
    　追加した注釈は、新しい RFC 3986 ではなく、 RFC 2396 を基準としたECMAScriptのURI構文であることを明確にしています。
</p>

<p>
    　デコード(復号・復号化)におけるアルゴリズムについては、ステップでは、発生不可能な条件においてテストした為、現在のステップ 4.d.vii.10.a の直前部分が削除されました。
</p>

<h4>15.2.3.7:</h4>

<p>
    　アルゴリズムのステップ5と6にある変数 P の使用を訂正しました。
</p>

<h4>15.2.4.2:</h4>

<p>
    　 this 値として undefined と null の制御をする第5版は、既存の失敗するコードを基にしていました。
</p>

<p>
    　仕様は、このようなコードを伴う互換性を維持する為に部分修正しました。
</p>

<p>
    　新しいステップ 1 と 2 は、アルゴリズムに追加しました。
</p>

<h4>15.3.4.3:</h4>

<p>
    　第5版のアルゴリズムのステップ 5 と 7 は、一般的な配列風のオブジェクトの使用するもの以外を伴う一貫性のないargArrayの引数について要件を課せられた為、削除されています。
</p>

<h4>15.4.4.12:</h4>

<p>
    　ステップ 9.a では、 relativeStart への誤った参照が、actualStart への参照と置き換えられました。
</p>

<h4>15.4.4.15:</h4>

<p>
    　 fromIndex における既定値は、配列のマイナス1の大きさであるということを明確にしました。
</p>

<h4>15.4.4.18:</h4>

<p>
    　アルゴリズムのステップ 9 にある undefined は、現在、指定した戻り値とすることになっています。
</p>

<h4>15.4.4.22:</h4>

<p>
    　ステップ 9.c.ii では、内部メソッド[[Call]]への最初の引数が、 Array.prototype.reduce の定義に伴う整合性の為に undefined に変更されています。
</p>

<h4>15.4.5.1:</h4>

<p>
    　アルゴリズムのステップ 3.l.ii と 3.l.iii では、変数名が、誤った反転テストの中で反転した結果となっていました。
</p>

<h4>15.5.4.9:</h4>

<p>
    　正規の等価文字列に関する規範的な要件は、注釈 2 で推奨したように列挙される為、後続のアルゴリズムを段落から削除しました。
</p>

<h4>15.5.4.14:</h4>

<p>
    　 splitのアルゴリズムのステップ 11.a と 13.a では、 SplitMatch への引数の配置順が、実際の SplitMatch のパラメータ署名と一致するように補正されました。
</p>

<p>
    　ステップ 13.a.iii.7.d では、 lengthA を A.length に置き換えました。
</p>

<h4>15.5.5.2:</h4>

<p>
    　最初の段落では、"配列インデックス"の構文を持っていた個々の文字へのプロパティアクセスを含め、削除しました。
</p>

<p>
    　修正したアルゴリズムのステップ 3 と 5 は、そのような"配列インデックス"の要件を強制しません。
</p>

<h4>15.9.1.15:</h4>

<p>
    　それらに欠けていた項目における範囲に正規の値を指定しました。
</p>

<p>
    　"time-only"フォーマットを除去しました。
</p>

<p>
    　全てのオブション項目における既定値を指定しました。
</p>

<h4>15.10.2.2:</h4>

<p>
    　ステップ 2 によって生成した内部クロージャにおけるアルゴリズムのステップ数は、外部アルゴリズムのステップであった暗黙の方法で間違った番号付けがなされていました。
</p>

<h4>15.10.2.6:</h4>

<p>
    　抽象操作 IsWordChar について、ステップ 3 にあるリスト内の最初の文字は、 "A" ではなく、 "a" です。
</p>

<h4>15.10.2.8:</h4>

<p>
    　抽象操作 CharacterSetMatcher によって返されたクロージャにおけるアルゴリズムでは、ステップ 3 によって定義し、ステップ 4 で引数として渡した変数は、クロージャの正規のパラメータとの名称の衝突を回避する為、
    ch に改名されました。
</p>

<h4>15.10.6.2:</h4>

<p>
    　ステップ 9.e は、i の余分な増分を実行する為、削除されました。
</p>

<h4>15.11.1.1:</h4>

<p>
    　 message 自身のプロパティが、 message の引数が、undefinedである場合、カラの文字列に設定されるという要件を削除しました。
</p>

<h4>15.11.1.2:</h4>

<p>
    　 message 自身のプロパティが、 message の引数が、undefinedである場合、カラの文字列に設定されるという要件を削除しました。
</p>

<h4>15.11.4.4:</h4>

<p>
    　ステップ 6-10 は、欠落やカラの message プロパティ値を正常とする為に修正・追加されました。
</p>

<h4>15.11.1.2:　（？ダブり？章番号間違い？）</h4>

<p>
    　 message 自身のプロパティが、 message の引数が、undefinedである場合、カラの文字列に設定されるという要件を削除しました。
</p>

<h4>15.12.3:</h4>

<p>
    　内部制御 JA のステップ 10.b.iii では、連結する最後の要素は、"]" です。
</p>

<h4>B.2.1:</h4>

<p>
    　エンコード方式が、新しい RFC 3986 ではなく、 RFC 1738 を基準にするという注釈を追加しました。
</p>

<h4>付録 C:</h4>

<p>
    　任意のアイテムが、strictモードで FutureReservedWords について 7.6.12 と一致するということが追加されました。
</p>


</article>
<article>


    <h2>参考文献 / Bibliography </h2>


    <p>　訳の正確性を保証するものではありませんので必要に応じて原文である<a href="http://www.ecma-international.org/" title="Ecma International">Ecma
        International</a>の<a href="http://www.ecma-international.org/publications/standards/Ecma-262.htm"
                             title="Ecma International / ECMA-262">ECMA-262</a>にある ECMA-262.pdf ( ECMA-262 5.1 Edition
        )を参照下さい。</p>

    <p style="float: right;">訳:2012年04月 webzoit.net</p>

    <p style="float: left;"><a
            href="http://www.webzoit.net/hp/it/internet/homepage/script/ecmascript/ecma262_51/copyright/">ECMA-262 5.1
        Edition 著作権情報</a></p>
    <pre>
        EE Std 754-2008: IEEE Standard for Floating-Point Arithmetic.
    Institute of Electrical and Electronic Engineers, New York (2008)

    IEEE標準規格 754-2008: 浮動小数点数演算におけるIEEE標準規格
    IEEE / Institute of Electrical and Electronic Engineers, New York (2008)

    [2]
    The Unicode Consortium.
    The Unicode Standard, Version 3.0, defined by: The Unicode Standard, Version 3.0 (Reading, MA, Addison-Wesley,
    2000.ISBN 0-201-61633-5)

    Unicodeコンソーシアム
    書籍『The Unicode Standard, Version 3.0』(Reading, MA, Addison-Wesley, 2000.ISBN
    0-201-61633-5)によって定義したUnicode標準規格バージョン3.0

    [3]
    Unicode Inc. (2010), Unicode Technical Report #15: Unicode Normalization Forms

    Unicode Inc. (2010)発行のUnicodeテクニカルリポート #15：Unicode正規化の形式

    [4]
    ISO 8601:2004(E) Data elements and interchange formats -- Information interchange -- Representation of dates and
    times

    ISO規格 8601:2004(E) データ要素と書式変換 -- 情報変換 -- 日付と時刻の表現

    [5]
    RFC 1738 "Uniform Resource Locators (URL)", available at &lt;http://tools.ietf.org/html/rfc1738&gt;

    RFC 1738 <a href="http://tools.ietf.org/html/rfc1738">http://tools.ietf.org/html/rfc1738</a>で利用可能な"Uniform Resource
    Locators (URL)"

    [6]
    RFC 2396 "Uniform Resource Identifiers (URI): Generic Syntax", available at &lt;http://tools.ietf.org/html/rfc2396&gt;

    RFC 2396 <a href="http://tools.ietf.org/html/rfc2396">http://tools.ietf.org/html/rfc2396</a>で利用可能な"Uniform Resource
    Identifiers (URI): 一般的な構文"

    [7]
    RFC 3629 "UTF-8, a transformation format of ISO 10646", available at &lt;http://tools.ietf.org/html/rfc3629&gt;

    RFC 3629 <a href="http://tools.ietf.org/html/rfc3629">http://tools.ietf.org/html/rfc3629</a>で利用可能な"UTF-8 ISO 10646
    の変換書式"

    [8]
    RFC 4627 "The application/json Media Type for JavaScript Object Notation (JSON)" , available at &lt;http://tools.ietf.org/html/rfc4627&gt;

    RFC 4627 <a href="http://tools.ietf.org/html/rfc4627">http://tools.ietf.org/html/rfc4627</a>で利用可能な"JSON / JavaScript
    Object Notation におけるメディアタイプ application/json"
    </pre>
    </div>


</article>
</body>
</html>
