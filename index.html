<link rel="stylesheet" href="http://sindresorhus.com/github-markdown-css/github-markdown.css">
<style>
    body {
        min-width: 200px;
        max-width: 790px;
        margin: 0 auto;
        padding: 30px;
    }
</style>
<article class="markdown-body">
    <h2 id="-standard-ecma-262-5-1-edition">はじめに Standard ECMA-262 5.1 Edition</h2>
    <h3 id="-">はじめに</h3>
    <p>　このECMA標準規格は、中でも最もよく知られている JavaScript(Netscape)とJScript(マイクロソフト)といったいくつかの元になる技術に基づいています。 その言語は、Netscape社のBrendan Eich氏によって考案され、同社製ブラウザNavigator 2.0の中で最初に登場しました。 その後、Netscape社(のNavigator 2.0)とMicrosoft社のInternet Explorer 3.0から順次発表されるブラウザ全てに搭載されました。</p>
    <p>　この標準の開発が始まったのは1996年11月です。 このEcma標準規格の最初のエディションは1997年06月のEcmaの総会で採択されました。</p>
    <p>　そのEcma標準規格は、迅速な手続きの下に採択されるべくISO / IEC JTC 1に提出され、1998年04月に国際標準[ISO/IEC 16262]として承認されました。 1998年06月のEcmaの総会では、ISO / IEC16262に完全に適合したECMA-262の第2版(セカンドエディション)が承認されました。 第1版と第2版の間の変更は、本質的に編集されました。 標準規格の第3版は、強力な正規表現、より良い文字列操作、新たな制御文、try/catch例外操作、エラーの厳密な定義、数値出力における書式化、更には、今後の国際化要件や将来の言語の成長を見越したマイナーチェンジ(細やかな変更)が行われました。 ECMAScript標準規格の第3版は、1999年12月のEcmaの総会で採択され、2002年06月に[ISO/IEC 16262:2002]として発行されました。</p>
    <p>　第3版の発行以来、ECMAScriptは、基本的にすべてのWebブラウザでサポートされているプログラミング言語であり、ワールド・ワイド・ウェブと共に広く普及し(大規模な採用を実現し)ています。 重要な作業は、ECMAScriptの第4版を開発することでした。 しかしながら、作業は完遂できませんでしたし、ECMAScriptの第4版というものは1つも発行されていませんが、言語の継続的な進化を表明しています。 ([ECMA-262 5 edition]として発行された)ECMAScriptの第5版は、ブラウザ実装間の共通化を図り、言語仕様の事実上の解釈を成文化し、第3版の発行以来浮上している新機能の為のサポートを追加します。 このような機能には、アクセサプロパティ、オブジェクトの生成と検査への反映、プロパティの属性のプログラム操作、付加的な配列操作関数、JSONオブジェクトエンコード方式の書式サポート、強化されたエラーチェックとプログラムセキュリティを提供する厳格モード(strict mode)を含みます。</p>
    <p>　ECMAScriptの標準規格であるこの現行の5.1版は、国際標準規格[ISO/IEC 16262:2011]の第3版に完全に準拠しています。</p>
    <p>　ECMAScriptは、活気に満ちた言語であり、その言語の進化は留まるところを知りません。 重要な技術強化については、この仕様の将来の版によって継続されます。</p>
    <p>　このECMA標準規格は、2011年06月の総会によって採択されています。</p>
    <h4 id="-">[注釈]</h4>
    <p>　ECMAScript Edition 4としてEcma標準規格番号であるECMA-262 Edition 4は予約されていましたが、Ecma発行過程では使われていません。 その為、Ecmaの国際的な刊行物としてのECMA-262 Edition 4は存在しません。</p>
    <h2 id="1-scope-standard-ecma-262-5-1-edition">1 スコープ / Scope / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="1-">1 スコープ</h3>
    <p>　この標準規格はECMAScriptのスクリプティング言語を定義します。</p>
    <h2 id="2-conformance-standard-ecma-262-5-1-edition">2 準拠 / Conformance / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="2-">2 準拠・一致・適合</h3>
    <p>　ECMAScriptに準拠した実装は、この仕様に記述されている全ての型、値、オブジェクト、プロパティ、関数、プログラム構文、セマンティックス(意味論)を提供し、サポートしなければいけません。</p>
    <p>　この標準規格に準拠した実装は、Unicode標準規格のバージョン 3.0 を含む以降と一致する文字、実装レベル3からエンコード方式として採用されている UCS-2 や UTF-16 の何れかを伴う[ISO/IEC 10646-1]を構文解析するようにしましょう。 もし、採用した[ISO/IEC 10646-1]のサブセットが特に指定されていない場合は、それはBMP / Basic Multilingual Plane (基本多言語水準)のサブセット、コレクション300であるものと推定されます。 もし、ECMAScriptの採用したエンコード方式が特に指定されていない場合は、UTF-16エンコード方式であるものと推定されます。</p>
    <p>　ECMAScriptに準拠した実装は、この仕様に記述されている型、値、オブジェクト、プロパティと関数を追加して提供することを許可されます。 特にECMAScriptに準拠した実装は、この仕様書内で説明されているオブジェクトの為に、この仕様で説明しなかったプロパティとそれらプロパティの値を提供することも許可されます。</p>
    <p>　ECMAScriptに準拠した実装は、この仕様に記載されていないプログラムと正規表現構文をサポートすることが許可されます。 特にECMAScriptに準拠した実装は、この仕様の 7.6.1.2 で列挙されている“将来の(利用を想定した)予約語”を使用するプログラム構文をサポートすることが許可されます。</p>
    <h2 id="3-normative-references-standard-ecma-262-5-1-edition">3 引用規格・引用文書 / Normative references / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="3-">3 引用規格・引用文書</h3>
    <p>　次の参照文書は、この文書のアプリケーションにおいて必須です。 日付のある参照については、引用した版(エディション)でだけ適用します。 日付のない参照については、(いくつかの改訂を含む)参照文書の最新版が適用します。</p>
    <p>[ ISO/IEC 9899:1996 ] プログラミング言語 – C 及び改訂1、技術的正誤表1と2を含む</p>
    <p>[ ISO/IEC 10646-1:1993 ] 情報技術(IT) – UCS/Universal Multiple-Octet Coded Character Set 及びその改訂と正誤表を付加</p>
    <h2 id="4-overview-standard-ecma-262-5-1-edition">4 概要 / Overview / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="4-">4 概要</h3>
    <p>　このセクションには、ECMAScript言語の非標準の概要を含みます。</p>
    <p>　ECMAScriptは、ホスト環境内でオブジェクトの演算と操作を実行する為のオブジェクト指向のプログラミング言語です。 ここで定義したようなECMAScriptは、演算処理を自己完結することは意図されず、他方、外部データの入力や算出結果の出力については、この仕様内に規定は何もありません。 その代わり、ECMAScriptプログラムの演算環境が期待されることは、この仕様内で説明したオブジェクトと他の機能だけではなく、特定の環境仕様のホストオブジェクトは、ECMAScriptプログラムからアクセスされることが可能な特定のプロパティと(ECMAScriptプログラムから)呼ばれることが可能な関数を提供する場合があることを示すこと以外に、この仕様のスコープを超える説明と動作を持ちます。 スクリプティング言語は、既存システムの機能のカスタマイズや自動化といった操作をする為に利用されるプログラミング言語です。 このようなシステムにおいて便利な機能は、ユーザーインタフェースを通して既に利用可能であり、スクリプティング言語にはプログラム操作への機能性を公開する仕組みがあります。 こうした方法では、既存システムは、スクリプト言語の機能を完了するオブジェクトと要件をホスト環境に提供するといわれています。</p>
    <p>　スクリプティング言語は玄人と素人プログラマの両方によって使われることが意図されます。</p>
    <p>　ECMAScriptは、元々Webスクリプティング言語にする為に設計されており、ブラウザ上でWebページをにぎわす仕組みとWebベースのクライアントサーバ技術の一部としてサーバサイドの演算を実行する仕組みを提供します。 ECMAScriptは、ホスト環境の多様性における核となるコアなスクリプティング能力を提供することができ、それゆえにそのコアなスクリプティング言語は、あらゆる固有のホスト環境から離れてこの文書の中で記述されます。</p>
    <p>　ECMAScriptの機能のいくつかは、他のプログラミング言語の中で使われるそれに似ており、特に以下で説明しているようにJava(TM)、それ自身とスキーマが似ています。</p>
<pre><code>====================================================
    Gosling, James, Bill Joy and Guy Steele.
    The Java(TM) Language Specification.
    Addison Wesley Publishing Co., 1996.
    Ungar, David, and Smith, Randall B.
    Self: The Power of Simplicity.
    OOPSLA &#39;87 Conference Proceedings, pp.
    227-241, Orlando, FL, October 1987.
    IEEE Standard for the Scheme Programming Language.
    IEEE Std 1178-1990.
    ====================================================
</code></pre><h2 id="4-1-web-web-scripting-standard-ecma-262-5-1-edition">4.1 Webスクリプティング / Web Scripting / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="4-">4 概要</h3>
    <h3 id="4-1-web-">4.1 Webスクリプティング</h3>
    <p>　Webブラウザは、ウィンドウ、メニュー、ポップアップ、ダイアログボックス、テキスト領域、アンカー、フレーム、履歴、cookie、入出力を示すインスタンスやオブジェクトにおいて含まれているクライアントサイドの計算の為にECMAScriptのホスト環境を提供します。 更にそのホスト環境は、フォーカス変更、ページと画像のロード、アンロード、エラーと中断、選択、フォームの送信、マウス操作のようなイベントの為のコードをスクリプティングして(書いて)調整するという手段を提供します。 HTMLと表示ページ内に現れるスクリプティングコードは、ユーザーインタフェース要素と固定及び計算されたテキストと画像との組み合わせです。 スクリプティングコードは、ユーザーとの対話に関係するものであってメインプログラムの為に必要なものは何もありません。</p>
    <p>　ウェブサーバは、クライアントやファイルからのオブジェクト再表示要求を含むサーバサイド演算について異なるホスト環境を提供し、ロックし、データを共有する仕組みがあります。 ブラウザサイドとサーバサイドスクリプティングの両方を利用することによってWebベースのアプリケーションにおいてカスタマイズしたユーザーインタフェースを提供する間、クライアントサーバ間の演算を分離します。</p>
    <p>　各ウェブブラウザとウェブサーバは、ECMAScriptの実行環境を整えることでその自身のホスト環境を提供するECMAScriptをサポートします。</p>
    <h2 id="4-2-language-overview-standard-ecma-262-5-1-edition">4.2 言語の概要 / Language Overview / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="4-">4 概要</h3>
    <h3 id="4-2-">4.2 言語の概要</h3>
    <p>　次は、言語の全ての部分を説明しているわけではないのでECMAScriptの略式な概要となります。 (よって)この概要は、必ずしも標準的な正規の部分ではありません。</p>
    <p>　ECMAScriptは、オブジェクトベースであり、基本言語とホスト要件は、オブジェクト(物体・対象体・対象物)によって提供され、ECMAScriptプログラムは通信オブジェクトの塊まり・集合(クラスタ)です。 ECMAScriptのオブジェクトは、各プロパティ(特性・性質)が、どのように利用可能かを決めるゼロ以上のアトリビュート(属性)をそれぞれに持つプロパティの集合で、例えば、あるプロパティにおけるWritable(書き込み)属性が、falseにセットされている場合、プロパティの値を変更しようとするとそのECMAScriptコードの実行は失敗します。 プロパティは、プリミティブ(原始的)な値や関数といった他のオブジェクトを保持するコンテナ(入れ物・容器)です。 プリミティブな値は、次のビルトイン(組み込み)型である [ Undefined、Null、Boolean、Number、String ] の1つとして構成されるメンバでオブジェクトは、残りの他のビルトイン型であるオブジェクトのメンバ、関数は呼び出し可能なオブジェクトです。 プロパティ経由でオブジェクトと関連付けられた関数はメソッドです。</p>
    <p>　ECMAScriptは、ECMAScriptの実体(エンティティ)の定義を包括する組み込みオブジェクトの集合を定義します。 これらGlobalオブジェクトを含む組み込みオブジェクトは、Objectオブジェクト、Functionオブジェクト、Arrayオブジェクト、Stringオブジェクト、Booleanオブジェクト、Numberオブジェクト、Mathオブジェクト、Dateオブジェクト、RegExpオブジェクト、JSONオブジェクト、また、ErrorオブジェクトとしてErrorオブジェクト、EvalErrorオブジェクト、RangeErrorオブジェクト、ReferenceErrorオブジェクト、SyntaxErrorオブジェクト、TypeErrorオブジェクトとURIErrorオブジェクトです。</p>
    <p>　ECMAScriptは、組み込み演算子のセットも定義します。 ECMAScriptの演算子は、単項演算子、多項演算子、加算演算子、ビットシフト演算子、関係演算子、等価演算子、バイナリビット演算子、バイナリ論理演算子、代入演算子、カンマ演算子など様々な演算子を含みます。 ECMAScriptの構文は、意図的にJavaの構文に似せています。 ECMAScriptの構文は、利用が容易なスクリプティング言語として提供する為に柔軟になっています。 例えば、変数は、その型が宣言されたかどうか、型がプロパティと関連付けられたかどうかについて要求されませんし、定義した関数は、それらが呼ばれる前にテキストとして現れる宣言を持つ(ソースコード上、呼び出し位置より前に定義されている)ことを要求されません。</p>
    <h2 id="4-2-1-objects-standard-ecma-262-5-1-edition">4.2.1 オブジェクト / Objects / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="4-">4 概要</h3>
    <h3 id="4-2-">4.2 言語の概要</h3>
    <h3 id="4-2-1-">4.2.1 オブジェクト</h3>
    <p>　ECMAScriptは、C++、Smalltalk、Javaのようなクラスを利用しません。 その代わりにオブジェクトは、リテラル表記経由または、オブジェクトの生成とその後にそれらのプロパティに初期値を関連付けることによってそれらの全部または一部を初期化する実行コードを生成するコンストラクタ経由含む様々な方法で生成される場合があります。 各コンストラクタは、プロトタイプベースの継承プロパティと共有プロパティを実装する為に使用される“prototype”という名前のプロパティを持つ関数です。 オブジェクトは、new 式でコンストラクタを使用することによって生成されます。 例えば、new Date(2009,11) という式は、新たなDateオブジェクトを生成します。 new を使わないコンストラクタの呼び出しは、コンストラクタに依存する結果を持ちます。 例えば、Date() は、任意のオブジェクトではなく、現在日付時刻についての文字列表現を生成します。</p>
    <p>　各オブジェクトは、そのコンストラクタのprototypeプロパティ(呼んだ当該オブジェクトのプロトタイプ)の値への暗黙のリファレンスを持ちます。 更にprototypeは、そのプロトタイプ等々へのnullではない暗黙のリファレンスを持つ場合があり、これはプロトタイプチェーンと呼ばれます。 リファレンスが、オブジェクト内のプロパティに作成される場合、それはその名前のプロパティを含むプロトタイプチェーン内にある最初のオブジェクトにあるその名前のプロパティへのリファレンスです。 言い換えると、ちょっと前に言及した最初のオブジェクトは、そのようなプロパティについて検査されるということであり、もし、そのオブジェクトが名前付きプロパティを含む場合には、それは、リファレンスが参照するプロパティであることを指し、もし、オブジェクトが名前付きプロパティを含まない場合には、そのオブジェクトにおける次のプロパティが、検査され。。。といったようになります。</p>
    <p><img src="/hp/img/explain/ecma_fig2.gif" alt=""></p>
    <p>図1 オブジェクト／プロトタイプの関係</p>
    <p>　クラスベースのオブジェクト指向言語は、一般には、状態が、インスタンスによって引き継がれ、メソッドが、クラスによって引き継がれ、継承は、構造と動作についてのみなされます。 ECMAScriptでは、その状態とメソッドが、オブジェクトによって引き継がれ、構造、動作、状態が全て継承されます。</p>
    <p>　固有のプロパティに直に含まれない全てのオブジェクトは、それらのプロトタイプが、そのプロパティとその値の共有を含みます。 図 1 は、これを示しています。</p>
    <p>　CF は、任意のコンストラクタ(、または、任意のオブジェクト)です。 cf1, cf2, cf3, cf4, cf5の5つのオブジェクトは、new 式を使って生成されています。 これらのオブジェクトは、それぞれ q1 と q2 という名前のプロパティを含みます。 波線は、暗黙のプロトタイプ関係を表現しているので、例えば、cf3のプロパティは、CFp となります。 コンストラクタ CF は、それ自身に CFp, cf1, cf2, cf3, cf4, cf5には、(直接)見えない P1 と P2 という名称の2つのプロパティを持っています。 プロパティ CFp にある CFP1 という名のプロパティは、q1、q2 や CFP1 という名前ではない CFp の暗黙のプロトタイプチェーン内で見つかった何らかのプロパティであるものとして(、 CF によってではなく、) cf1, cf2, cf3, cf4, cf5 によって共有されます。 これらにおける注釈としては、 CF と CFp 間の(明示的なリンクはありますが、 CF と cf1, cf2, cf3, cf4, cf5 のそれぞれとの間に)暗黙のプロパティリンクは、存在しないということです。</p>
    <p>　クラスベースのオブジェクト言語とは異なり、プロパティは、それらに値を関連付けることによって動的にオブジェクトに追加されることが可能です。 それは、つまり、コンストラクタは、構築されたオブジェクトのプロパティの全て、または、一部に対し、名称や値の関連付けを要求しないということです。 上記のダイアグラムでは、CFp 内のプロパティに新たな値を関連付けることによって cf1, cf2, cf3, cf4, cf5に新たな共有プロパティを追加することができます。</p>
    <h2 id="4-2-2-ecmascript-variant-the-strict-variant-of-ecmascript-standard-ecma-262-5-1-edition">4.2.2 ECMAScriptの厳密なVariant型 / The Strict Variant of ECMAScript / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="4-">4 概要</h3>
    <h3 id="4-2-">4.2 言語の概要</h3>
    <h3 id="4-2-2-ecmascript-variant-">4.2.2 ECMAScriptの厳密なVariant型</h3>
    <p>　ECMAScript言語は、言語の利用者が、言語内で利用可能な一部の機能の利用を制限することがあるという可能性を認識しています。 それらは、エラーの発生しやすい機能であると考えるものを回避する為、強化したエラーチェック結果を得る為、もしくは彼らの選択肢の他の何らかの理由などセキュリティへの関心からその様にするかもしれません。 この可能性へのサポートとしては、ECMAScriptは、言語の厳格なvariant型(どんな型でも格納可能な型)を定義します。 言語の厳格なvariantは、通常のECMAScript言語の一部の構文とセマンティックの仕様と一部機能の詳細化したセマンティックスへの改訂を除外します。 その言語の厳格でない書式によってエラーとして指定されない状況において例外エラーを投げることによって報告されなければならない付加的なエラー条件も指定します。</p>
    <p>　ECMAScript言語の厳格なvariantは、言語の strict mode (厳格モード)として参照されるのが、一般的です。 厳格モードの選択とECMAScriptの構文とセマンティックをstrictモードとして利用することは、単独のECMAScriptのコードユニットのレベルで明示的に行われます。 なぜならstrictモードは、構文上のコードユニットのレベルにおいて選択され、strictモードは、唯一このようなコードユニット内でローカル効果を持つ制限を課すからです。 Strictモードは、複数のコードユニットを超えた構成を制御しなければならないECMAScriptのセマンティック上の一部の局面に対し、制約を設けたり、修正したりはしません。 ECMAScriptプログラム全体としては、厳格モードと厳格モードでないECMAScriptコードユニット双方で構成される場合があります。 このケースにおいてはstrictモードは唯一、実際に実行中のコードが、strictモードのコードユニット内で定義される際に適用されます。</p>
    <p>　この仕様への確認の為にECMAScriptの実装は、全く制限のないECMAScript言語とこの仕様によって定義したECMAScript言語のstrictモードのvariantの両方を実装しなければいけません。 加えて実装は、単一の複合プログラムについて制約がない場合とstrictモードのコードユニットとの組み合わせをサポートしなければいけません。</p>
    <h2 id="4-3-terms-and-definitions-standard-ecma-262-5-1-edition">4.3 用語と定義 / Terms and definitions / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="4-">4 概要</h3>
    <h3 id="4-3-">4.3 用語と定義</h3>
    <p>　この文書の目的においては、次の用語と定義が適用されます。</p>
    <h3 id="4-3-1-">4.3.1 『型』</h3>
    <p>　この仕様の<a href="/hp/it/internet/homepage/script/ecmascript/ecma262_51/contents/8/" title="8 型">第8項</a>内で定義したようなデータ値のセット</p>
    <h3 id="4-3-2-">4.3.2 『プリミティブ値』</h3>
    <p>　<a href="/hp/it/internet/homepage/script/ecmascript/ecma262_51/contents/8/" title="8 型">第8項</a>内で定義したようなUndefined型、Null型, Boolean型, Number型, String型の1つであるメンバ</p>
    <p>[注釈]</p>
    <p>　プリミティブな値とは、言語実装の最も低いレベルで表現されるまさに基準・原点です。</p>
    <h3 id="4-3-3-">4.3.3 『オブジェクト』</h3>
    <p>　Objectという型のメンバ</p>
    <p>[注釈]</p>
    <p>　オブジェクトとは、プロパティの集合と1つのプロトタイプオブジェクトを持ちます。 プロトタイプは、null値になる場合があります。</p>
    <p>(注：ちなみにここで言うプロトタイプオブジェクトとは、標準組み込みプロトタイプオブジェクトであり、<em>obj</em>.prototype といったGlobalオブジェクト以外の各オブジェクトが持つ prototype プロパティの事ではない、つまり、 prototype プロパティを持たないJSONやMathも「プロトタイプがnull値」であるオブジェクトという意味。)</p>
    <h3 id="4-3-4-">4.3.4 『コンストラクタ』</h3>
    <p>　オブジェクトを生成、初期化する関数オブジェクト</p>
    <p>[注釈]</p>
    <p>　コンストラクタのprototypeプロパティの値は、継承の実装と共有したプロパティに利用されるプロトタイプオブジェクトです。</p>
    <h3 id="4-3-5-">4.3.5 『プロトタイプ』</h3>
    <p>　他のオブジェクトに共有したプロパティを提供するオブジェクト</p>
    <p>[注釈]</p>
    <p>　コンストラクタが、任意のオブジェクトを生成する場合には、そのオブジェクトは、プロパティ参照を解決する目的においてコンストラクタの“prototype”プロパティを暗に参照します。 そのコンストラクタの“prototype”プロパティは、(注：任意のコンストラクタ名という意味であってconstructorプロパティのことではない)[ <em>constructor</em>.prototype ]というプログラム上の式によって参照されることが可能で、そのプロトタイプを共有している全てのオブジェクトによって継承を通して共有されます。 あるいは、任意の新たなオブジェクトは、[ Object.create ]という組み込み関数を使用することによって明示的に指定したプロトタイプを伴って生成される場合があります。</p>
    <h3 id="4-3-6-">4.3.6 『ネイティブオブジェクト』</h3>
    <p>　ホスト環境ではなく、この仕様によって完全に定義されるセマンティックを持つECMAScriptの実装にあるオブジェクト</p>
    <p>[注釈]</p>
    <p>　標準規格のネイティブオブジェクトはこの仕様の中で定義されます。 一部のネイティブオブジェクトは、組み込まれ、その他は、ECMAScriptプログラムの実行過程で構築される場合があります。</p>
    <h3 id="4-3-7-">4.3.7 『組み込みオブジェクト(ビルトインオブジェクト)』</h3>
    <p>　ECMAScriptプログラムの実行開始時点で現れるECMAScriptの実装によって提供されたホスト環境に依存しないオブジェクト</p>
    <p>[注釈]</p>
    <p>　標準組み込みオブジェクトはこの仕様内で定義され、ECMAScriptの実装については、ここで記載したり、他で定義したりする場合があります。 各組み込みオブジェクトは、ネイティブオブジェクトです。 組み込みコンストラクタとは、組み込みオブジェクトのことであり、コンストラクタのことでもあります。</p>
    <h3 id="4-3-8-">4.3.8 『ホストオブジェクト』</h3>
    <p>　完全なECMAScriptの実行環境をホスト環境によって提供したオブジェクト</p>
    <p>[注釈]</p>
    <p>　ネイティブでないなんらかのオブジェクトは、ホストオブジェクトです。</p>
    <h3 id="4-3-9-undefined-">4.3.9 『Undefined(未定義)値』</h3>
    <p>　変数が、値と関連付けられていない時に使用したプリミティブ値</p>
    <h3 id="4-3-10-undefined-">4.3.10 『Undefined(未定義)型』</h3>
    <p>　唯一の値がUndefined(未定義)値である型</p>
    <h3 id="4-3-11-null-">4.3.11 『null値』</h3>
    <p>　何らかのオブジェクトの意図的な欠如を表すプリミティブ値</p>
    <h3 id="4-3-12-null-">4.3.12 『Null型』</h3>
    <p>　唯一の値がnull値である型</p>
    <h3 id="4-3-13-boolean-">4.3.13 『Boolean値』</h3>
    <p>　Boolean型のメンバ</p>
    <p>[注釈]</p>
    <p>　Boolean値にはtrueとfalseの2つしかありません。</p>
    <h3 id="4-3-14-boolean-">4.3.14 『Boolean型』</h3>
    <p>　プリミティブ値 true/false で構成される型</p>
    <h3 id="4-3-15-boolean-">4.3.15 『Booleanオブジェクト』</h3>
    <p>　標準組み込みBooleanコンストラクタのインスタンスであるオブジェクト型のメンバ</p>
    <p>[注釈]</p>
    <p>　引数としてBoolean値を提供することによって new 式の中でBooleanコンストラクタを使って生成したBooleanオブジェクトです。 結果となるオブジェクトは、値がBoolean値である内部プロパティを持ちます。 Booleanオブジェクトは、Boolean値に強制変換することが可能です。</p>
    <h3 id="4-3-16-string-">4.3.16 『String値』</h3>
    <p>　ゼロ以上の16ビット符号なし整数の有限の序数並びであるプリミティブ値</p>
    <p>[注釈]</p>
    <p>　String値は、String型のメンバです。 通常、その並び(シーケンス)にある各整数値は、UTF-16テキストの任意の単一の16ビットユニットを表わします。 しかしながら、ECMAScriptは、16ビット符号なし整数にしなければならない場合を除き、その値におけるいかなる制限も要求もなされません。</p>
    <h3 id="4-3-17-string-">4.3.17 『String型』</h3>
    <p>　利用可能なString値全てのセット</p>
    <h3 id="4-3-18-string-">4.3.18 『Stringオブジェクト』</h3>
    <p>　標準組み込みStringコンストラクタのインスタンスであるObject型のメンバ</p>
    <p>[注釈]</p>
    <p>　任意のStringオブジェクトは、引数としてString値を提供することによって new 式の中でStringコンストラクタを使って生成されます。 結果となるオブジェクトは、値がString値である内部プロパティを持ちます。 Stringオブジェクトは、関数としてStringコンストラクタを呼ぶ(<a href="/hp/it/internet/homepage/script/ecmascript/ecma262_51/contents/15/15_5/15_5_1/" title="15.5.1 関数としてコールしたStringコンストラクタ">15.5.1</a>)ことによってString値に強制変換することが可能です。</p>
    <h3 id="4-3-19-number-">4.3.19 『Number値』</h3>
    <p>　倍精度64ビットバイナリ形式[ IEEE 754 ]の値と一致するプリミティブ値</p>
    <p>[注釈]</p>
    <p>　Number値は、Number型のメンバであり、数値における直接表現です。</p>
    <p>[注記]</p>
    <p>[ IEEE 754 ] / IEEE標準規格 754 『浮動小数点数演算』</p>
    <h3 id="4-3-20-number-">4.3.20 『Number型』</h3>
    <p>　特殊な[NaN / Not-a-Number]、正の無限大、負の無限大を含む全ての利用可能なNumber値のセット</p>
    <h3 id="4-3-21-number-">4.3.21 『Numberオブジェクト』</h3>
    <p>　標準組み込みNumberコンストラクタのインスタンスであるObject型のメンバ</p>
    <p>[注釈]</p>
    <p>　Numberオブジェクトは、引数としてNumber値を提供することによって new 式の中でNumberコンストラクタを使って生成されます。 結果となるオブジェクトは、値がNumber値である内部プロパティを持ちます。 Numberオブジェクトは、関数としてNumberコンストラクタを呼ぶ(15.7.1)ことによってNumber値に強制変換することが可能です。</p>
    <h3 id="4-3-22-">4.3.22 『無限大』</h3>
    <p>　正の無限大のNumber値である数値</p>
    <h3 id="4-3-23-nan-">4.3.23 『NaN』</h3>
    <p>　[IEEE 754]で定める[NaN / Not-a-Number]値である数値</p>
    <p>[ IEEE 754 ] / IEEE標準規格 754 『浮動小数点数演算』</p>
    <h3 id="4-3-24-">4.3.24 『関数』</h3>
    <p>　標準組み込みFunctionコンストラクタのインスタンスであり、サブルーチンとして実行される場合があるObject型のメンバ</p>
    <p>[注釈]</p>
    <p>　その名前付きプロパティについて追記すると任意の関数は、実行可能なコードと呼び出された場合にどのような挙動を取るかを決める状態を含みます。 関数のコードは、ECMAScriptで書かれたり、(他のコードで書かれECMAScriptでは)書かれなかったりします(、つまり、関数のコードは、必ずしもECMAScriptで書かれるとは限りません)。</p>
    <h3 id="4-3-25-">4.3.25 『組み込み関数』</h3>
    <p>　関数である組み込みオブジェクト</p>
    <p>[注釈]</p>
    <p>　 parseInt と Math.exp を含む組み込み関数の例など。 実装は、この仕様に記載されていない実装依存(独自拡張)の組み込み関数を提供する場合があります。</p>
    <h3 id="4-3-26-">4.3.26 『プロパティ』</h3>
    <p>　オブジェクトの一部となる名称と値の関連付け</p>
    <p>[注釈]</p>
    <p>　プロパティの形式に応じて値は、データ値(任意のプリミティブ値、任意のオブジェクト、任意の関数オブジェクト等)として直接、またはアクセサ関数のペアによって間接的に表現される場合があります。</p>
    <h3 id="4-3-27-">4.3.27 『メソッド』</h3>
    <p>　プロパティの値である関数</p>
    <p>[注釈]</p>
    <p>　関数が、オブジェクトのメソッドとして呼ばれる場合、そのオブジェクトは、 this 値として関数に渡されます。</p>
    <h3 id="4-3-28-">4.3.28 『組み込みメソッド』</h3>
    <p>　組み込み関数であるメソッド</p>
    <p>[注釈]</p>
    <p>　標準組み込みメソッドは、この仕様内で定義され、ECMAScriptの実装が、他の付加的な組み込みメソッドを指定したり、提供したりする場合もあります。</p>
    <h3 id="4-3-29-attribute-">4.3.29 『属性(attribute)』</h3>
    <p>　あるプロパティの任意の特性を定義する内部値</p>
    <h3 id="4-3-30-own-property-">4.3.30 『独自のプロパティ(own property)』</h3>
    <p>　そのオブジェクトで直(じか)に含まれるプロパティ</p>
    <h3 id="4-3-31-">4.3.31 『継承したプロパティ』</h3>
    <p>　独自のプロパティではなく、オブジェクトのプロトタイプの(それ自身または継承した何らかの)オブジェクトのプロパティ</p>
    <h2 id="5-notational-conventions-standard-ecma-262-5-1-edition">5 表記上の規則 / Notational Conventions / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="5-">5 表記上の規則</h3>
    <h2 id="5-1-syntactic-and-lexical-grammars-standard-ecma-262-5-1-edition">5.1 構文と語彙の文法 / Syntactic and Lexical Grammars / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="5-">5 表記上の規則</h3>
    <h3 id="5-1-">5.1 構文と語彙の文法</h3>
    <h3 id="5-1-1-">5.1.1 文脈自由な文法</h3>
    <p>　文脈自由な文法は、プロダクション(生成物)の番号で構成されます。 各プロダクションは、その左側にくるものとして非終端、ゼロ以上の非終端の並び(シーケンス)、その右側にくるものとして終端記号の並び(シーケンス)を呼ぶ抽象的な記号を持ちます。 各文法において終端記号は、指定したアルファベットで描かれます。</p>
    <p>　識別した非終端1つから成る文章の開始は、目標記号と呼ばれ、言語を指定する任意の文脈自由な文法、すなわち、左側にある非終端におけるプロダクションの右側にある並びの中で何らかの非終端を繰り返し置換することによって得ることができる終端記号の利用可能な並び(おそらく無限大)のセットを与えられます。</p>
    <h3 id="5-1-2-regexp-">5.1.2 語彙とRegExp(正規表現)の文法</h3>
    <p>　ECMAScriptにおける語彙の文法については第7項で示されます。 この文法は、その終端記号文字(Unicodeコードユニット)を持ち、それは、第6項で定義した SourceCharacter におけるルールと一致します。 それは、目標記号 InputElementDiv や InputElementRegExp から始まるプロダクションの集合を定義し、そうした文字の並びが、どのように入力要素の並びに翻訳されるのかを説明します。</p>
    <p>　ホワイトスペースとコメントではない入力要素は、ECMAScriptにおける構文上の文法の為の終端記号を形成すると共にECMAScriptのトークン(字句)と呼ばれます。 これらのトークンは、ECMAScript言語の予約語、識別子、リテラル、句読点記号です。 更に行終端は、トークンとして考慮されるわけではありませんが、入力要素のストリームの一部にもなり、セミコロン自動挿入(7.9)の処理を導きます。 単純なホワイトスペースと単一行コメントは廃棄され、構文上の文法における入力要素のストリーム内には現れません。 MultiLineComment(一行以上に渡るか否かに関わらず、書式 /* … */ のコメント)は、行終端がなければ、単に廃棄されたのと同様になりますが、 MultiLineCommentが、1つ以上の行終端を含む場合には、1つの行終端に置き換えられ、構文上の文法における入力要素のストリームの一部となります。</p>
    <p>　ECMAScriptにおけるRegExp文法については、15.10 の中で示されます。 この文法もまた、SourceCharacterによって定義されたのと同じ文字をその終端記号として持ちます。 目標記号 Pattern から始まるプロダクションの集合を定義し、文字の並びが、どのようにして正規表現パターンに翻訳されるかを説明します。</p>
    <p>　語彙とRegExp文法から成るプロダクションは、分割する句読点(セパレータ)として2つのコロン“::”を持つことによって識別されます。 語彙とRegExp文法は、複数のプロダクションを共有します。</p>
    <h3 id="5-1-3-">5.1.3 数値文字(数字)の文法</h3>
    <p>　その他の文法は、文字を数値に翻訳する為に利用されます。 この文法は、数値リテラルを伴って実行する為に持っている語彙文法の一部に似ており、その終端記号 SourceCharacter と同じものを持ちます。 この文法については、9.3.1 に出てきます。</p>
    <p>　数値文字列の文法のプロダクションは、句読点として3つのコロン“:::”を持つことによって識別されます。</p>
    <h3 id="5-1-4-">5.1.4 構文上の文法</h3>
    <p>　ECMAScriptにおける構文上の文法は、第11項、12項、13項、14項で示されます。 この文法は、その終端記号(5.1.2)として語彙的な文法によって定義したECMAScriptのトークン(字句)を持ちます。 目標記号 Program から始まるプロダクションの集合を定義し、どのようにしてトークンの並び(シーケンス)が、構文的に正しいECMAScriptプログラムを形成することができるのかを説明します。</p>
    <p>　文字のストリームが、ECMAScriptプログラムとして解析される為にある場合、それは、まず、繰り返した語彙的な文法のアプリケーションによって入力要素のストリームに変換され、その入力要素のストリームは、その後、任意の1つの構文上の文法のアプリケーションによって解析されます。 入力要素のストリーム内にあるトークンが、トークンが何もない目標非終端 Program の任意の1つのインスタンスとして解析できない場合、そのプログラムは、エラー内においては構文に沿っているといえます。</p>
    <p>　構文上の文法のプロダクションは、句読点としてまさに1つのコロン“:”を持つことによって識別されます。</p>
    <p>　第11項、12項、13項、14項で提示されているように構文上の文法は、実際には正しいECMAScriptプログラムとして許容されるトークンのシーケンス(字句の並び)の完全な説明(account)ではありません。 特定の追加の字句の並び、すなわち、(行終端文字の前の位置のように)確実な場所にあるシーケンス(並び)に追加された場合に限り、文法によって説明されるであろう字句の並びもまた、許容されます。 更にその文法によって説明される特定の字句の並びは、終端文字が、特定の「厄介な」場所などに現れる場合には、受け入れを考慮されません。</p>
    <h3 id="5-1-5-json-">5.1.5 JSONの文法</h3>
    <p>　JSONの文法は、実際のオブジェクトにECMAScriptのオブジェクトの集合を定義している任意の文字列を翻訳する為に利用されます。 JSONの文法は、15.12.1 に書かれています。</p>
    <p>　JSONの文法は、JSONの語彙的な文法と構文的な文法で構成されています。 JSONの語彙的な文法は、文字列をトークンに翻訳する為に利用され、それは、ECMAScriptの語彙的な文法の一部に似ています。 JSONの構文的な文法は、構文的に正しいJSONオブジェクト定義からどのようにJSONの語彙的な文法から成るトークンのシーケンスができるのかを定義します。</p>
    <p>　JSONの語彙的な文法から成るプロダクションは、分割句読点として2つのコロン“::”を持つことによって識別されます。 JSONの構文的な文法は、ECMAScriptの語彙的な文法から成る何らかのプロダクションを利用します。 JSONの構文的な文法は、ECMAScriptの構文的な文法の一部に似ています。 JSONの構文的な文法から成るプロダクションは、分割する句読点として1つのコロン“:”を使用することによって識別されます。</p>
    <h3 id="5-1-6-">5.1.6 文法表記</h3>
    <p>　語彙的な終端記号、RegExpの終端記号、数値文字の文法の終端記号、他の文法から成る終端記号の一部は、文法のプロダクションとそのような終端記号をテキストが直接参照するか否かについてのこの仕様を通して、その両方において固定幅フォントで表示されます。 これらは、書いた通りに正確にプログラム内に現れるようにする為にあります。 この方法で指定した全ての終端記号文字は、ASCIIの範囲から成る適切なUnicode文字であり、他のUnicode文字から成る似たような見た目の文字とは異なるものであると理解される為にあります。 　非終端記号はイタリック体で表示されます。 (webzoit.net内訳文においては、これを踏襲しない可能性があります。)</p>
    <p>　非終端の定義は1つ以上のコロンに続けて定義される非終端から成る名称によって始まります。 (コロンの数は、属する文法のプロダクションによって示されます。) 非終端について右辺に1つ以上の選択肢がある場合は、後続する行に続きます。 例えば、構文上の定義、</p>
<pre><code>WhileStatement：
    while ( Expression ) Statement
</code></pre><p>という非終端の WhileStatement という状態(state)は、トークン(字句) while 、トークン(字句) 左丸カッコ、Expression(式) 、トークン(字句) 右丸カッコ、Statement(文)が続くことを表します。 Expression (式)とStatement (文)の出現は、それら自身は、非終端となります。 他で例えるなら、構文上の定義、</p>
<pre><code>ArgumentList：
    AssignmentExpression
    ArgumentList , ArgumentExpression
</code></pre><p>は、 ArgumentList が、単一の AssignmentExpression か、または、カンマに続けて、 AssignmentExpression が続く何れか1つの状態を表す場合があります。 この ArgumentList の定義は、再帰的で、つまり、それ自身についての観点の中で定義されます。 その結果は、各引数の式が、 ArgumentExpression である場合、 ArgumentList が、カンマ区切りの正の数の引数を含む場合があるということです。 このような非終端の再帰定義は、一般的です。</p>
    <p>　添字の接尾辞“opt”が、終端や非終端の後に現れる場合、それはオプション記号を示します。 実際には、右辺に2つ指定するオプション記号を含む選択肢は、1つは省略可能なオプション要素、1つはそれ(省略したもの)を含みます。 この意味は、</p>
<pre><code>VariableDeclaration：
    Identifier Initialiseropt
</code></pre><p>は、</p>
<pre><code>VariableDeclaration：
    Identifier
    Identifier Initialiser
</code></pre><p>の便利な略記であり、</p>
    <p>　そしてまた、</p>
<pre><code>IterationStatement：
    for ( ExpressionNoInopt ; Expressionopt ; Expressionopt ) Statement
</code></pre><p>は、</p>
<pre><code>IterationStatement：
    for ( ; Expressionopt ; Expressionopt ) Statement
    for ( ExpressionNoIn ; Expressionopt ; Expressionopt ) Statement
</code></pre><p>の便利な省略形であり、それは、反復ステートメント</p>
<pre><code>IterationStatement：
    for ( ; ; Expressionopt ) Statement
    for ( ; Expression ; Expressionopt ) Statement
    for ( ExpressionNoIn ; ; Expressionopt ) Statement
    for ( ExpressionNoIn ; Expression ; Expressionopt ) Statement
</code></pre><p>の省略形であり、それは、</p>
<pre><code>IterationStatement：
    for ( ; ; ) Statement
    for ( ; ; Expression ) Statement
    for ( ; Expression ; ) Statement
    for ( ; Expression ; Expression ) Statement
    for ( ExpressionNoIn ; ; ) Statement
    for ( ExpressionNoIn ; ; Expression ) Statement
    for ( ExpressionNoIn ; Expression ; ) Statement
    for ( ExpressionNoIn ; Expression ; Expression ) Statement
</code></pre><p>の省略形なので、その非終端反復ステートメントは、実際には、右辺に8つの選択肢を持つということになります。</p>
    <p>　文法定義内でコロンに続く「下記の内の1つ」(、または、パターンのバリエーションを列挙後に「の内の1つ」)という単語がある場合、それらは、単一または複数行続く終端記号のそれぞれが、選択肢の定義であることを意味します。 例えば、プロダクションを含むECMAScriptにおけるその語彙的な文法は、</p>
<pre><code>NonZeroDigit::下記の内の1つ
    1 2 3 4 5 6 7 8 9
</code></pre><p>　これは、</p>
<pre><code>NonZeroDigit::
    1
    2
    3
    4
    5
    6
    7
    8
    9
</code></pre><p>における単に便利な省略形ですが、もし、[empty(カラ)]というフレーズがプロダクションの右辺として表れた場合、それは、プロダクションの右辺が、終端や非終端を何も含まないということを示しています。</p>
    <p>　もし、</p>
<pre><code>&quot;[lookahead ? set]&quot;
    (lookahead：前方参照設定／？は、∈の否定形／set)
</code></pre><p>というフレーズがプロダクションの右辺として現れる場合、それは、直後に続く入力トークンが与えられた set をメンバとする場合、そのプロダクションが、使用されない場合があるということを示します。 その set は、波カッコで括られた終端のリストとして書かれることが可能です。</p>
    <p>　利便性において、その set は、非終端が拡張可能な場合に全ての終端の集合を提示する場合においては、非終端として書かれることも可能です。 例えば、与えられる定義</p>
<pre><code>DecimalDigit::下記の内の1つ
    0 1 2 3 4 5 6 7 8 9

    DecimalDigits ::
    DecimalDigit
    DecimalDigits DecimalDigit
</code></pre><p>　その定義</p>
<pre><code>LookaheadExample::
    n [lookahead ？ {1, 3, 5, 7, 9}] DecimalDigits
    DecimalDigit [lookahead ？ DecimalDigit]
    (lookahead：前方参照設定／？は、∈の否定形)
</code></pre><p>は、偶数で始まる1つ以上の10進数値が続く文字 n 、または、その他の10進数値が続かない文字 n の何れかとマッチします。</p>
    <p>　もし、そのフレーズ“[no LineTerminator here(ここに行終端はない)]”が構文上の文法のプロダクションの右辺に現れる場合、それは、そのプロダクションが、制限付きプロダクションであるということを示し、それは、LineTerminator(行終端)が示した位置にある入力ストリーム内に現れる場合、使用されない可能性があるということです。 例えば、そのプロダクション</p>
<pre><code>ThrowStatement：
    throw [ここにLineTerminatorはない] Expression ;
</code></pre><p>は、仮にLineTerminator(行終端)が、プログラム上のトークン throw と Expression の間に現れる場合、そのプロダクションが使用されない可能性があるということを示しています。</p>
    <p>　LineTerminator(行終端)の存在が、制限付きのプロダクションによって禁じられる場合以外は、LineTerminator(行終端)の出現数が、そのプログラムの構文上の受容性に影響を与えることなく、入力要素のストリーム内で2つの連続したトークンの間に現れる場合があります。 語彙的な文法または数値文字の文法から成るプロダクション内の選択肢が複数文字のトークンとして現れる場合、それは、そのようなトークンを作りだすであろう文字の並びを表します。 任意のプロダクションの右辺は、そのフレーズ“but not(…ではなく、)”を使用することによって許可されない特定の拡張を指定する場合があり、その場合には、その拡張が除外されることを示します。 例えば、そのプロダクション</p>
<pre><code>Identifier ::
    ReservedWord ではない IdentifierName
</code></pre><p>は、&lt;span style=&quot;border-bottom:dashed 1pt;&quot;&gt;その非終端 Identifier は、ReservedWord と同一の文字の並びは、置き換えることができませんが、それ以外から成る任意の文字の並び IdentifierName によって置き換えられるという意味です。&lt;/span&gt; (下線部の原文、読解不能の為、意訳)</p>
    <p>　最後にいくつかの非終端記号は、選択肢全てを列挙することが実用的でない(非現実的である)場合においては、(フォント)タイプ sans-serif での説明フレーズによって説明されます。(webzoit.net内訳文においては、これを踏襲しない可能性があります。)</p>
<pre><code>SourceCharacter ::
    any Unicode code unit
    (何らかのUnicodeコードユニット)
</code></pre><h2 id="5-2-algorithm-conventions-standard-ecma-262-5-1-edition">5.2 アルゴリズムの規則・慣例 / Algorithm Conventions / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="5-">5 表記上の規則</h3>
    <h3 id="5-2-">5.2 アルゴリズムの規則・慣例</h3>
    <p>　その(アルゴリズムの)仕様は、よく、某アルゴリズム内で手順を指定する為に番号付きリストを使用します。 これらのアルゴリズムは、ECMAScript言語の構築の構文を要求する指定を明確にする為に使用されます。 そのアルゴリズムとは、任意の特定の実装技術の仕様の利用を暗に意図しているわけではありません。 実際には、与えられた機能を実装するために利用できる、より効率的なアルゴリズムがあるかもしれません。</p>
    <p>　この仕様の複数の部分での利用を促進する為に、抽象操作と呼ばれる何らかのアルゴリズムは、名前付けされ、他のアルゴリズム内から名称によって参照される場合がある為、パラメータ機能の形式で書かれます。</p>
    <p>　任意のアルゴリズムが、結果としての値を生成する為にある場合には、その指示 “return x” は、そのアルゴリズムの結果が x という値であり、そのアルゴリズムが終端とすべきであることを示す為に使用されます。 表記法 Result(n) は、「手順 n の結果」における略記として使用されます。</p>
    <p>　式の明確化の為、アルゴリズムの手順は、順序だった小手順(サブステップ)に細分化される場合があります。 サブステップが示され、さらにそれら自身がインデントしたサブステップの中で細分化される場合もあります。 番号付け規則の概要としては、まず、1番めのサブステップのレベルは、アルファベット小文字でラベルづけ、2番めのサブステップのレベルは小文字のローマ数字でラベルづけといったようにサブステップを識別する為に使用されます。 もし、3レベル以上が要求される場合、これらのルールは、数値ラベルを使って4番めのレベルでといった具合に繰り返します。</p>
<pre><code>[例]
    1. トップレベルステップ
    a. サブステップ
    b. サブステップ
    i. サブサブステップ
    ii. サブサブステップ
    1. サブサブサブステップ
    a サブサブサブサブステップ
    ...etc.
</code></pre><p>　あるステップやサブステップは、そのサブステップの条件である述部 “if” として書かれる場合があります。</p>
    <p>　このケースでは、サブステップは、述部が真である場合に限り適用されます。 もし、あるステップやサブステップが単語を伴って始まる場合には、もし、他にあれば、述部の否定である述部であり、更にもし、あれば、それは同一レベルにある述部ステップです。</p>
    <p>　あるステップは、そのサブステップの反復アプリケーションを指定する場合があります。</p>
    <p>　あるステップは、そのアルゴリズムの不変の条件をアサート(主張)する場合があります。 そのような主張は、明示的に不変条件のアルゴリズムを作る為に利用され、そうでなければ暗黙的に作られます。 そのような主張は、追加のセマンティック要件を追加しません、したがって、実装によってチェックされる必要はありません。 それらは単にアルゴリズムを明確にする為に利用されます。</p>
    <p>　加算、減算、否定、乗算、除算といったような数学的演算、更に、この項の中で後に定義する数学関数は、正のゼロとして認識される無限大と負のゼロを含まない数学的なリアルな値として数学的結果を正確に計算する際に常に理解されるべきです。 浮動小数点演算というモデルである標準的なアルゴリズムは、無限大、符号付きゼロ、丸め処理実行の為に必要に応じた明示的な手順を含みます。 もし、数学演算や関数が浮動小数点数を適用される場合には、それは、浮動小数点数を無限大にしなければならないとか、もし、+0とあれば、それは数学的には単に0と一致するというように浮動小数点数を適用されるものとして理解されなければいけません。</p>
    <p>　数学関数 abs(x) は、x の絶対値を得ることができ、x が(ゼロより小さい)負である場合は -x 、それ以外の場合には、その値は、x それ自身です。</p>
    <p>　数学関数 sign(x) は、 x が正なら1を生成し、負なら-1を生成します。 sign 関数は、x がゼロというケースにおいては、この標準では利用されません。</p>
    <p>　表記(moduloは剰余)</p>
<pre><code> x modulo y
</code></pre><p>(yは有限でゼロでなければならない)は、ある整数 q において</p>
<pre><code>abs(k) &lt; abs(y)
</code></pre><p>と</p>
<pre><code>x-k = q´y
</code></pre><p>のように y (または、ゼロ)として同一の符号の値 k を算出します。</p>
    <p>　数学関数 floor(x) は、x より大きくない(正の無限大に最も近い)最大の整数を返します。</p>
    <p>[注] floor(x) = x-(x modulo 1)</p>
    <p>　もし、あるアルゴリズムが例外を投げる(スローする)為に定義される場合には、アルゴリズムの実行が終端であり、返される結果はありません。 アルゴリズムを呼ぶこと自体もまた、アルゴリズムの手順が、「もし、例外が投げられ(スローされ)た場合…」というような専門用語を使うことによって例外として明示的に扱うようなところまで達しない限り、終端であるものとされています。 一度、そのような例外に遭遇してしまったアルゴリズムの手順は、もはや、そうした例外が現れていることすら考慮されなくなります。</p>
    <h2 id="6-source-text-standard-ecma-262-5-1-edition">6 ソーステキスト / Source Text / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="6-">6 ソーステキスト</h3>
    <p>　ECMAScriptのソーステキストは、バージョン 3.0 以降のUnicode文字のエンコード方式である文字列として表現されます。 そのテキストは、Unicodeテクニカルレポート #15に記述したように Unicode Normalization Form C (canonical composition) / Unicode正規化形式 C に正規化されていることが期待されます。 ECMAScriptの実装は、テキストの正規化を実行することやそれら自身のテキストの正規化を実行したことによる動作は要求されません。 ECMAScriptのソーステキストは、この仕様の目的において16ビットコードユニットのシーケンスであるものとみなされます。 このようにソーステキストは、有効な UTF-16 文字エンコード方式ではない16ビットコードユニットの並びを含む場合があります。 もし、実際のソーステキストが16ビットコードユニット以外の書式のエンコード方式である場合には、それは、まず最初にUTF-16への変換をしたかのように処理されなければいけません。</p>
<pre><code>【構文】
    SourceCharacter ::
    any Unicode code unit
    (何らかのUnicodeコードユニット)
</code></pre><p>　この文書の残りを通じて「コードユニット」( “code unit” / コード単位)というフレーズと「文字」( “character” )という単語は、テキストの任意の1つの16ビット単位を表す為に使用した16ビット符号なしの値を参照する為に使用されるでしょう。 「Unicode文字」( “Unicode character” )というフレーズは、単一のUnicodeスカラー値によって表された抽象的な言語や表記単位への参照のために利用されるでしょう。 (これは16ビットより長くなる場合や1コードユニット以上で表される場合があるということです。) 「コードユニット」( “code unit” )というフレーズは、このようなUnicodeスカラー値を参照します。 「Unicode文字」( “Unicode character” )は、単独のUnicodeスカラー値によって表されるエンティティ(実体)だけを参照し、結合した文字並びの構成(コンポーネント)は、ユーザーが単独の文字としての並び全体であるものと考えるような場合でさえ、それはまだ、個々の「Unicode文字」( “Unicode character” )です。</p>
    <p>　文字列リテラル、正規表現リテラル、識別子においては、ある文字(コードユニット)が、6文字で構成されるUnicodeのエスケープシーケンス、すなわち \u に加えて16進数文字が4つ続くものとして表されます。 コメント内では、このようなエスケープシーケンスは、コメントの一部として効果的に無視されます。 文字リテラルや正規表現リテラル内では、Unicodeのエスケープシーケンスは、リテラルの値1文字に寄与して(リテラルの値1文字として使用されて)います。 識別子内では、エスケープシーケンスは、識別子1文字に寄与して(として使用されて)います。</p>
    <p>[注釈：] この文書では時折、“string(文字列)”内の“character(文字)”間の“transformation(変換)”を参照し、その文字(character)のコードユニットである16ビット符号なし整数は、実際には、16ビット符号なしの値を使用して表現される“string”内の“character”なので、実際には変換するものはありません。</p>
    <p>　ECMAScriptは、Unicodeエスケープシーケンスの挙動についてプログラミング言語 Java を参考にしています。 Javaプログラムにおいては、もし、Unicodeエスケープシーケンス \u000A が、例えば、単一行コメント内に現れる場合には、それは、行終端(Unicode文字 000A は ラインフィード／改行／\n)として解釈されることになり、それゆえに次の文字はコメントの一部ではありません。 似たようなケースとして、もし、Unicodeエスケープシーケンス \u000A が、Javaプログラム内の文字リテラル内に現れる場合には、それは、同様に行終端として解釈され、文字リテラル内で受け入れられず、ラインフィードが文字列リテラルの文字列値の一部となってしまう要因にもなるので \u000A の代わりに \n にしなければいけません。 ECMAScriptプログラムでは、コメント内に現れるUnicodeエスケープシーケンスは、決して解釈されることはなく、それゆえにコメントの終端には寄与しません(として使用されません)。 似たようにECMAScriptプログラム内で文字リテラル内に現れるUnicodeエスケープシーケンスは常にリテラルのString値に寄与する(使われる)文字であり、それは、決して行終端や文字リテラルの終端と考えられるクォートマークとして解釈されることはありません。</p>
    <h2 id="7-lexical-conventions-standard-ecma-262-5-1-edition">7 語彙的な表記 / Lexical Conventions / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="7-">7 語彙的な表記</h3>
    <p>　ECMAScriptプログラムのソーステキストは、まず最初にトークン、行終端、コメントやホワイトスペースといった入力要素の並びに変換されます。 ソーステキストは、左から右へスキャンされ、反復的に次の入力要素として最も長い利用可能な文字の並びを取り出します。 語彙的な文法においては2つの目標記号があります。 InputElementDiv 記号は、先行する除算(/)演算子、除算代入(/=)演算子が許容される場合、それらの構文的な文法コンテキスト内で利用されます。 InputElementRegExp 記号は、他の構文的な文法コンテキスト内で利用されます。</p>
    <p>[注釈：]除算(/)や除算代入(/=)の両方が先行する場合、構文上の文法コンテキストは何もなく、先行する正規表現リテラル( RegularExpressionLiteral )が許容されます。</p>
    <p>　これは、例えば次の例においてセミコロン挿入(7.9項参照)による影響を受けないということです。</p>
<pre><code>a = b
    /hi/g.exec(c).map(d);
</code></pre><p>　LineTerminator(行終端)の直後にくる非ホワイトスペースや非コメント文字の先頭が、スラッシュ(/)である場合、その構文上のコンテキストは、除算や除算代入を許容し、LineTerminator(行終端)位置で挿入されるセミコロンはありません。</p>
    <p>　つまり、上記の例は、</p>
<pre><code>a = b / hi / g.exec(c).map(d);
</code></pre><p>(改行のない一行の文)と同じ様に解釈されるということです。</p>
<pre><code>【構文】
    InputElementDiv ::
    WhiteSpace
    LineTerminator
    Comment
    Token
    DivPunctuator

    InputElementRegExp ::
    WhiteSpace
    LineTerminator
    Comment
    Token
    RegularExpressionLiteral
</code></pre><h2 id="7-1-unicode-unicode-format-control-characters-standard-ecma-262-5-1-edition">7.1 Unicodeの書式制御文字 / Unicode Format-Control Characters / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="7-">7 語彙的な表記</h3>
    <h3 id="7-1-unicode-">7.1 Unicodeの書式制御文字</h3>
    <p>　Unicodeの書式制御文字(参考例としてカテゴリ内の文字、LEFT-TO-RIGHT マークや RIGHT-TO-LEFT マークのようなUnicode文字データベースにある Cf )は、(マークアップ言語のように)これにおけるより高度なプロトコル(手順・規約)がない中でテキストの範囲における書式を制御する為に利用する制御コードです。 それは、編集や表示を促す為のソーステキスト内にある書式制御文字を受け入れるのに便利です。</p>
    <p>　全ての書式制御文字は、コメント内、文字列リテラル内、正規表現リテラル内で利用されます。 \&lt;ZWNJ\&gt; と \&lt;ZWJ\&gt; は、特定の言語の単語やフレーズの形式を区別するのに必要とされ、利用される書式制御文字です。 ECMAScriptのソーステキスト \&lt;ZWNJ\&gt; と \&lt;ZWJ\&gt; は、最初の文字の後、識別子の中で利用される場合もあります。 \&lt;BOM\&gt; は、Unicodeとして解釈される為にテキストの先頭に配置され、優先的にテキストのエンコード方式とバイトオーダーの検出を許可する為に使われる書式制御文字です。 この目的において意図された連結するファイルの結果としてといった例などにおいて \&lt;BOM\&gt; 文字は、テキストの先頭の後に現れることもあり得ます。 \&lt;BOM\&gt; 文字は、ホワイトスペース文字として扱われます。(7.2項参照) コメントや文字リテラルの外側にある特定の書式制御文字と正規表現リテラルの特別な処理は、Table 1.で要約されています。</p>
<pre><code>Table 1. 書式制御文字のコードユニット値の利用方法
    ----------------------------------------------------------------------------------------
    コードユニット値    名称          正式名     使用方法
    ----------------------------------------------------------------------------------------
    \u200C          Zero width non-joiner   &lt;ZWNJ&gt;        識別子部分
    \u200D          Zero width joiner   &lt;ZWJ&gt;     識別子部分
    \uFEFF          Byte Order Mark     &lt;BOM&gt;     ホワイトスペース
    ----------------------------------------------------------------------------------------
</code></pre><h2 id="7-2-white-space-standard-ecma-262-5-1-edition">7.2 ホワイトスペース / White Space / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="7-">7 語彙的な表記</h3>
    <h3 id="7-2-">7.2 ホワイトスペース</h3>
    <p>　ホワイトスペース文字は、ソーステキストの可読性を向上させる為や(語彙的にそれ以上は分割できない)トークンを分割する為に利用されますが、それ以外にはそれほど重要ではありません。 ホワイトスペース文字は、一部2つのトークンの間、また入力の始まりや終わりに現れる場合があります。 ホワイトスペース文字は、リテラル値の一部を形成するのに重要な文字として想定される文字列リテラル(StringLiteral)内、正規表現リテラル(RegularExpressionLiteral)内やコメント内などに現れる場合もありますが、それ以外の他の種類において現れることはできません。</p>
    <p>　ECMAScriptのホワイトスペース文字は、Table 2 に列挙されます。</p>
<pre><code>Table 2 ホワイトスペース文字
    -----------------------------------------------------------------------------
    コードユニット値    名称                  公式記号名
    -----------------------------------------------------------------------------
    \u0009          Tab                 &lt;TAB&gt;
    \u000B          Vertical Tab                &lt;VT&gt;
    \u000C          Form Feed               &lt;FF&gt;
    \u0020          Space                   &lt;SP&gt;
    \u00A0          No-break space              &lt;NBSP&gt;
    \uFEFF          Byte Order Mark             &lt;BOM&gt;
    その他カテゴリ&quot;Zs&quot; 他の何らかの Unicode &quot;space separator&quot;    &lt;USP&gt;
    -----------------------------------------------------------------------------
</code></pre><p>　ECMAScriptの実装は、Unicode 3.0で定義されたホワイトスペース文字の全てを認識しなけばいけません。 Unicode標準規格の最新エディションは、他のホワイトスペース文字を定義する場合もあります。 ECMAScriptの実装によっては、Unicode標準規格の最新エディションにおけるホワイトスペース文字を認識する場合もあります。</p>
<pre><code>【構文】
    WhiteSpace ::
    &lt;TAB&gt;
    &lt;VT&gt;
    &lt;FF&gt;
    &lt;SP&gt;
    &lt;NBSP&gt;
    &lt;BOM&gt;
    &lt;USP&gt;
</code></pre><h2 id="7-3-line-terminators-standard-ecma-262-5-1-edition">7.3 行終端 / Line Terminators / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="7-">7 語彙的な表記</h3>
    <h3 id="7-3-">7.3 行終端</h3>
    <p>　ホワイトスペース文字のように行終端文字は、ソーステキストの可読性向上と相互に(単独の語彙単位に)字句を区切る為に利用されます。 しかしながら、ホワイトスペース文字とは異なり、行終端は、いくつかの構文上の文法の動作を超えた影響を持つ場合があります。 一般には、行終端は2つの軸の間に現れますが、一部、構文上の文法によって禁じられる場所に存在する場合もあります。 行終端はまた、自動セミコロン挿入(7.9)の過程に影響します。 行終端は、文字列リテラル(StringLiteral)を除くいかなる字句内にも現れることはできません。 行終端は、唯一、行継続(LineContinuation)の一部として文字列リテラル(StringLiteral)内に現れます。</p>
    <p>　1つの行終端は、MultiLineComment(複数行コメント) (7.4)内に現れることはできますが、単独行コメント(SingleLineComment)内に現れることはできません。</p>
    <p>　ホワイトスペース文字の集合内に含まれる行終端は、正規表現の中で\sクラスでマッチさせます。</p>
    <p>　ECMAScript行終端文字は、Table 3内で列挙されます。</p>
<pre><code>Table 3 行終端文字
    ----------------------------------------------------------
    コードユニット値    名称          正式名
    ----------------------------------------------------------
    \u000A          Line Feed       &lt;LF&gt;
    \u000D          Carriage Return     &lt;CR&gt;
    \u2028          Line separator      &lt;LS&gt;
    \u2029          Paragraph separator &lt;PS&gt;
    ----------------------------------------------------------
</code></pre><p>　Table 3にある文字に限っては、行終端として扱われます。 他の新しい行や行改行文字は、行終端としてではなくホワイトスペースとして扱われます。 \&lt;CR\&gt;\&lt;LF\&gt; が一般的である文字シーケンス(文字並び)は、行終端として利用します。 それは、行番号を報告する目的において単独の文字として認識されるべきです。</p>
<pre><code>【構文】
    LineTerminator(行終端) ::
    &lt;LF&gt;
    &lt;CR&gt;
    &lt;LS&gt;
    &lt;PS&gt;

    LineTerminatorSequence(行終端並び) ::
    &lt;LF&gt;
    &lt;CR&gt;
    [ 前方参照  ？ &lt;LF&gt; ](？は、∈ の否定形)
    &lt;LS&gt;
    &lt;PS&gt;
    &lt;CR&gt;&lt;LF&gt;
</code></pre><h2 id="7-4-comments-standard-ecma-262-5-1-edition">7.4 コメント / Comments / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="7-">7 語彙的な表記</h3>
    <h3 id="7-4-">7.4 コメント</h3>
    <p>　コメントは、単一行または複数行何れにすることもできます。 複数行コメントはネストできません。</p>
    <p>　なぜなら単一行コメントは、一部、LineTerminator(行終端)文字を含むことができますし、一般規則からして字句は常に同じ長さであり、単独行コメントは常に行の最後までを印付けする // (スラッシュ2つ)から始まり文字全てから成るからです。 しかしながら、行の最後にある行終端(LineTerminator)は、単一行コメントの一部となることは考慮されません。 それは語彙的な文法によって分けて認識され、構文上の文法における入力要素のストリームの一部になります。 この点は、自動セミコロン挿入の経過に影響しない単一行コメントの存在や欠如という意味でとても重要です。(7.9参照)</p>
    <p>　コメントは、ホワイトスペースのように振る舞い、それ以外は廃棄され、もし、複数行コメント(MultiLineComment)が行終端文字を含む場合には、入力コメントが構文上の文法によって構文解析する目的において行終端(LineTerminator)にすることが考慮されます。</p>
<pre><code>【構文】
    Comment (コメント) ::
    MultiLineComment (複数行コメント)
    SingleLineComment (単一行コメント)

    MultiLineComment (複数行コメント)::
    /* MultiLineCommentCharsopt */
    ( /* 複数行コメント文字[オプション] */ )

    MultiLineCommentChars ::
    (複数行コメント文字)
    MultiLineNotAsteriskChar MultiLineCommentCharsopt
    アスタリスクのない複数行文字 複数行コメント文字[オプション]

    * PostAsteriskCommentCharsopt
    (後置アスタリスクコメント文字[オプション])

    PostAsteriskCommentChars ::
    (後置アスタリスクコメント文字)
    MultiLineNotForwardSlashOrAsteriskChar MultiLineCommentCharsopt
    (先行するスラッシュやアスタリスクのない複数行文字 複数行コメント文字[オプション])

    * PostAsteriskCommentCharsopt
    (後置アスタリスクコメント文字[オプション])

    MultiLineNotAsteriskChar ::
    (アスタリスクのない複数行文字)
    アスタリスクではない SourceCharacter(ソース文字)

    MultiLineNotForwardSlashOrAsteriskChar ::
    (先行するスラッシュやアスタリスクのない複数行文字)
    SourceCharacter but not forward-slash / or asetrisk *
    (先行するスラッシュやアスタリスクのないソース文字)

    SingleLineComment (単独行コメント) ::
    // SingleLineCommentCharsopt
    (// 単独行コメント文字[オプション])

    SingleLineCommentChars (単一行コメント文字) ::
    SingleLineCommentChar SingleLineCommentCharsopt
    (単一行コメント文字 単一行コメント文字[オプション])

    SingleLineCommentChar (単一行コメント文字) ::
    LineTerminator ではない SourceCharacter
    (行終端ではないソース文字)
</code></pre><h2 id="7-5-tokens-standard-ecma-262-5-1-edition">7.5 字句(トークン) / Tokens / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="7-">7 語彙的な表記</h3>
    <h3 id="7-5-">7.5 字句(トークン)</h3>
<pre><code>構文
    Tokens (字句) ::
    IdentifierName (識別子名)
    Punctuator (句読点)
    NumericLiteral (数値リテラル)
    StringLiteral (文字列リテラル)
</code></pre><p>[注釈：]DivPunctuator(区分句読点)とRegularExpressionLiteral(正規表現リテラル)も字句を定義しますが、Tokenプロダクションには含まれません。</p>
    <h2 id="7-6-identifier-names-and-identifiers-standard-ecma-262-5-1-edition">7.6 識別子名と識別子 / Identifier Names and Identifiers / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="7-">7 語彙的な表記</h3>
    <h3 id="7-6-">7.6 識別子名と識別子</h3>
    <p>　字句である識別子名は、一部わずかな修飾子を伴うUnicode標準仕様の第5章の『Identifiers(識別子)』セクション(節)で与えられる文法によって解析されます。 あるIdentifierNameという、ある識別子( 7.6.1 参照)は、予約語(ReservedWord)ではありません。 Unicode識別子の文法は、Unicode標準仕様によって記述される非正規・正規の文字カテゴリ双方を基準にします。 Unicode標準仕様の第3版内のカテゴリに記述された中にある文字は、完全準拠するECMAScript実装によってそれらのカテゴリにあるものとして扱われます。</p>
    <p>　この標準仕様は、文字追加の仕様を記述します。 ダラー記号( $ )とアンダースコア( _ )は、IdentifierName(識別子名)内のどこにあっても解釈されます。</p>
    <p>　Unicodeエスケープシーケンスもまた、当該IdentifierName(識別子名)においてUnicodeEscapeSequence(Unicodeエスケープシーケンス)のCVによって算出される際に単独の文字に寄与するIdentifierName(識別子名)の中で解釈されます。( 7.8.4 参照) 先行するUnicodeEscapeSequence(Unicodeエスケープシーケンス) \ は、IdentifierName(識別子名)における文字に寄与し(使用され)ません。 Unicodeエスケープシーケンス(UnicodeEscapeSequence)は、不正ではないIdentifierName(識別子名)について文字を配置する為に利用されることはできません。 言い換えると、もし、UnicodeEscapeSequence(Unicodeエスケープシーケンス) \ が、当該UnicodeEscapeSequence(Unicodeエスケープシーケンス)のCVによって置き換えられる場合、その結果は、まだ元のIdentifierName(識別子名)と正確に同じ文字の並びを持つ有効なIdentifierName(識別子名)としなければいけません。 この仕様内の識別子についての全ての解釈は、一部の固有文字に寄与(使用)する為に利用されたエスケープシーケンスか否かに関わらず、それら実際の文字を基準にします。</p>
    <p>　Unicode標準仕様と一致するまさに等価である2つのIdentifierName(識別子名)であっても、厳密に同一のコード単位の並びによって表されない限り、イコールではありません。 (言い換えるとECMAScript実装はIdentifierName(識別子名)をビット単位で比較する為にだけ、唯一要求されます。) その意図は、コンパイラに到達する前に正規化形式 Cに変換されるソーステキストであるということです。</p>
    <p>　ECMAScript実装はUnicode標準仕様の最新版で定義した識別子文字を認識する場合があります。 もし、移植性が気になる場合には、プログラマはUnicode 3.0で定義した識別子文字だけを採用するべきです。</p>
<pre><code>【構文】
    識別子(Identifier) ::
    予約語(ReservedWord)ではない識別子(IdentifierName)

    識別子名(IdentifierName) ::
    識別子開始(IdentifierStart)
    識別子名 識別子部(IdentifierName IdentifierPart)

    識別子開始(IdentifierStart) ::
    Unicode文字(UnicodeLetter)
    $
    _
    \ Unicodeエスケープシーケンス(UnicodeEscapeSequence)

    IdentifierPart (識別子部分) ::
    IdentifierStart (識別子の開始)
    UnicodeCombiningMark (Unicode結合マーク)
    UnicodeDigit (Unicode数字)
    UnicodeConnectorPunctuation (Unicode接続句読点)
    &lt;ZWNJ&gt;
    &lt;ZWJ&gt;

    UnicodeLetter(Unicode文字) ::
    &quot;Uppercase letter (Lu)&quot;、&quot;Lowercase letter (Ll)&quot;、&quot;Titlecase letter (Lt)&quot;、&quot;Modifier letter (Lm)&quot;、&quot;Other letter (Lo)&quot;や&quot;Letter number (Nl)&quot;といったUnicodeカテゴリにある一部の文字
    (&quot;大文字 (Lu)&quot;、&quot;小文字 (Ll)&quot;、&quot;タイトル大文字 (Lt)&quot;、&quot;修飾文字 (Lm)&quot;、&quot;その他文字 (Lo)&quot;や&quot;文字番号 (Nl)&quot;といったUnicodeカテゴリにある一部の文字)

    UnicodeCombiningMark(Unicode結合マーク) ::
    &quot;Non-spacing mark (Mn)&quot;や&quot;Combining spacing mark (Mc)&quot;といったUnicodeカテゴリにある一部の文字
    (&quot;非スペースマーク (Mn)&quot;や&quot;結合スペースマーク (Mc))&quot;といったUnicodeカテゴリにある一部の文字)

    UnicodeDigit(Unicode数字) ::
    &quot;Decimal number (Nd)(十進数 (Nd))&quot;といったUnicodeカテゴリにある一部の文字

    UnicodeConnectorPunctuation(Unicode接続句読点) ::
    &quot;Connector punctuation (Pc)(接続句読点 (Pc))&quot;といったUnicodeカテゴリにある一部の文字
</code></pre><p>非終端のUnicodeエスケープシーケンス(UnicodeEscapeSequence)の定義は、 7.8.4 でなされます。</p>
    <h3 id="7-6-1-">7.6.1 予約語</h3>
    <p>　予約語は、識別子として使うことができないIdentifierName(識別子名)です。</p>
<pre><code>【構文】
    ReservedWord (予約語) ::
    Keyword (キーワード)
    FutureReservedWord (将来の予約語)
    NullLiteral (Nullリテラル)
    BooleanLiteral (Booleanリテラル)
</code></pre><h3 id="7-6-1-1-">7.6.1.1 キーワード</h3>
    <p>　次に続く字句は、ECMAScriptのキーワードであり、一部は、ECMAScriptのプログラム内で識別子として使われない場合もあります。</p>
<pre><code>【構文】
    Keyword (キーワード)::
    break
    do
    instanceof
    typeof
    case
    else
    new
    var
    catch
    finally
    return
    void
    continue
    for
    switch
    while
    debugger
    function
    this
    with
    default
    if
    throw
    delete
    in
    try
</code></pre><p>の何れか1つ</p>
    <h3 id="7-6-1-2-">7.6.1.2 将来の予約語</h3>
    <p>　次に続く単語は、推奨する拡張子内のキーワードとして使われるので、それら拡張子が将来採用される可能性を受け入れる為に予約されます。</p>
<pre><code>【構文】
    FutureReservedWord (将来の予約語) ::
    class
    enum
    extends
    super
    const
    export
    import
</code></pre><p>の何れか1つ</p>
    <p>　次に続く字句は、厳密モード(strict mode)のコード内に現れる場合にFutureReservedWord(将来の予約語)にすることが考慮されます。( 10.1.1 参照) エラーを生成するであろうFutureReservedWord(将来の予約語)の出現のある文脈内においてstrictモード内にあるこれらの字句の一部の出現は、評価エラーをも生成しなければいけません。</p>
<pre><code>    implements
    let
    private
    public
    yield
    interface
    package
    protected
    static
</code></pre><h2 id="7-7-punctuators-standard-ecma-262-5-1-edition">7.7 句読点・句読文字 / Punctuators / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="7-">7 語彙的な表記</h3>
    <h3 id="7-7-">7.7 句読点・句読文字</h3>
<pre><code>Syntax Punctuator(構文上の句読文字) ::
    {
    }
    (
    )
    [
    ]
    .
    ;
    ,
    &lt;
    &gt;
    &lt;=&gt;=
    ==
    !=
    ===
    !==
    +
    -
    *
    %
    ++
    --
    &lt;&lt;
    &gt;&gt;
    &gt;&gt;&gt;
    &amp;
    |
    ^
    !
    ~
    &amp;&amp;
    ||
    ?
    :
    =
    +=
    -=
    *=
    %=
    &lt;&lt;=&gt;&gt;=
    &gt;&gt;&gt;=
    &amp;=
    |=
    ^=
</code></pre><p>の何れか1つ</p>
<pre><code>DivPunctuator(区分句読文字) ::
    /
    /=
</code></pre><p>の何れか1つ</p>
    <h2 id="7-8-literals-standard-ecma-262-5-1-edition">7.8 リテラル / Literals / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="7-">7 語彙的な表記</h3>
    <h3 id="7-8-">7.8 リテラル</h3>
<pre><code>【構文】
    Literal ::
    NullLiteral
    BooleanLiteral
    NumericLiteral
    StringLiteral
    RegularExpressionLiteral
</code></pre><h3 id="7-8-1-null-nullliteral-">7.8.1 Nullリテラル(NullLiteral)</h3>
<pre><code>【構文】
    Null Literal ::
    null
</code></pre><p>【セマンティクス(意味論・統語論)】</p>
    <p>nullリテラルnullという値は、唯一のNullタイプという値、すなわちnullです。</p>
    <h3 id="7-8-2-boolean-booleanliteral-">7.8.2 Booleanリテラル(BooleanLiteral)</h3>
<pre><code>【構文】
    BooleanLiteral ::
    true
    false
</code></pre><p>【セマンティクス(意味論・統語論)】</p>
    <p>Booleanリテラルtrueという値は、Booleanタイプの値、すなわちtrueです。</p>
    <p>Booleanリテラルfalseという値は、Booleanタイプの値、すなわちfalseです。</p>
    <h3 id="7-8-3-numericliteral-">7.8.3 数値リテラル(NumericLiteral)</h3>
<pre><code>【構文】

    数値リテラル(NumericLiteral) ::
    10進リテラル(DecimalLiteral)
    16進整数リテラル(HexIntegerLiteral)

    10進リテラル(DecimalLiteral) ::
    10進整数リテラル . 10進数字[オプション] 指数部[オプション]
    (DecimalIntegerLiteral . DecimalDigitsopt ExponentPartopt)
    . 10進数字[オプション] 指数部[オプション]
    ( . DecimalDigitsopt ExponentPartopt)
    10進整数リテラル 指数部[オプション]
    (DecimalIntegerLiteral ExponentPartopt)


    10進整数リテラル(DecimalIntegerLiteral) ::
    0
    非ゼロ数字 10進数字[オプション]
    (NonZeroDigit DecimalDigitsopt)


    10進数字 (DecimalDigits) ::
    DecimalDigit
    DecimalDigits DecimalDigit


    10進数字 (DecimalDigit) ::
    0 1 2 3 4 5 6 7 8 9
    の何れか1つ

    非ゼロ数字 (NonZeroDigit) ::
    1 2 3 4 5 6 7 8 9
    の何れか1つ

    指数部 (ExponentPart) ::
    指数指標 符号付き整数
    (ExponentIndicator SignedInteger)

    指数指標 (ExponentIndicator) ::
    e   E
    の何れか1つ

    符号付き整数 (SignedInteger) ::
    10進数字 (DecimalDigits)
    + 10進数字 (+ DecimalDigits)
    - 10進数字 (- DecimalDigits)

    16進整数リテラル (HexIntegerLiteral) ::
    0x 16進数字(0x HexDigit)
    0X 16進数字(0X HexDigit)
    16進整数リテラル 16進数字(HexIntegerLiteral HexDigit)

    16進数字(HexDigit) ::
    0 1 2 3 4 5 6 7 8 9 a b c d e f A B C D E F
    の何れか1つ
</code></pre><p>　数値リテラル(NumericLiteral)のすぐ後に続くソース文字は、識別子の開始(IdentifierStart)または10進数字(DecimalDigit)にしてはいけません。</p>
    <p>[注釈]</p>
<pre><code>例)  3in
</code></pre><p>　3in というのはエラーであり、“3”と“in”という2つの入力要素ではありません(とはみなされません)。</p>
    <p>【セマンティクス】</p>
    <p>　ある数値リテラルは数字タイプの値に当てはまります。 この値は2つの段階を経て決められます。 まず最初に、1つの数学的な値(Mathematical Value / MV)は、リテラルから派生します。 次にこの数学的な値は以下に記述するように丸められます(丸め処理が行われます)。</p>
<pre><code>・NumericLiteral(数値リテラル)から成るMV :: [ 10進リテラル(DecimalLiteral) ]は、10進リテラル(DecimalLiteral)から成るMV.
    ・NumericLiteral(数値リテラル)から成るMV :: [ 16進整数リテラル(HexIntegerLiteral) ]は、16進整数リテラル(HexIntegerLiteral)から成るMV.
    ・DecimalLiteral(10進リテラル)から成るMV :: [ 10進整数リテラル(DecimalIntegerLiteral) .  ]は、10進整数リテラル(DecimalIntegerLiteral)から成るMV.
    ・DecimalLiteral(10進リテラル)から成るMV :: [ 10進整数リテラル(DecimalIntegerLiteral) . 10進数字(DecimalDigit) ]は、10進整数リテラル(DecimalIntegerLiteral)から成るMV plus (10進数字(DecimalDigit)から成るMVs の [ 10^-n ]倍(10のマイナスn乗))、[ n ]は、10進数字(DecimalDigits)... にある文字の数.
    ・DecimalLiteral(10進リテラル)から成るMV :: [ 10進整数リテラル(DecimalIntegerLiteral) . 指数部(ExponentPart) ]は、10進整数リテラル(DecimalIntegerLiteral)から成るMV の[ 10e ]倍、[ e ]は、指数部(ExponentPart)から成るMV.
    ・DecimalLiteral(10進リテラル)から成るMV :: [ 10進整数リテラル(DecimalIntegerLiteral) . 10進数字(DecimalDigits)... 指数部(ExponentPart) ]は、(10進整数リテラル(DecimalIntegerLiteral)から成るMV プラス (10進数字(DecimalDigit)から成るMVs の [ 10^-n ]倍(10のマイナスn乗))) [ 10e倍 ]、[ n ]は、10進数字(DecimalDigits)... にある文字の数、[ e ]は、指数部(ExponentPart)から成るMV.
    ・DecimalLiteral(10進リテラル)から成るMV :: [ . 10進数字(DecimalDigit) ]は、10進数字(DecimalDigit)から成るMVs の [ 10^-n ]倍(10のマイナスn乗)、[ n ]は、10進数字(DecimalDigits)... にある文字の数.
    ・DecimalLiteral(10進リテラル)から成るMV :: [ . 10進数字(DecimalDigits)... 指数部(ExponentPart) ]は、10進数字(DecimalDigit)から成るMVs の [ 10^-n ]倍(10のマイナスn乗)、[ n ]は、10進数字(DecimalDigits)... にある文字の数、[ e ]は、指数部(ExponentPart)から成るMV.
    ・DecimalLiteral(10進リテラル)から成るMV :: [ 10進整数リテラル(DecimalIntegerLiteral) ]は、10進整数リテラル(DecimalIntegerLiteral)から成るMV.
    ・DecimalLiteral(10進リテラル)から成るMV :: [ 10進整数リテラル(DecimalIntegerLiteral) 指数部(ExponentPart) ]は、10進整数リテラル(DecimalIntegerLiteral)から成るMV の[ 10e ]倍、[ e ]は、指数部(ExponentPart)から成るMV.
    ・DecimalIntegerLiteral(10進整数リテラル)から成るMV :: [ 0 ] は、 0.
    ・DecimalIntegerLiteral(10進整数リテラル)から成るMV :: [ 非ゼロ数字(NonZeroDigit) ]は、 非ゼロ数字(NonZeroDigit)から成るMV.
    ・DecimalIntegerLiteral(10進整数リテラル)から成るMV :: [ 非ゼロ数字(NonZeroDigit) 10進数字(DecimalDigit) ]は、[ (非ゼロ数字(NonZeroDigit)から成るMV の[ 10^n ]倍(10のn乗)) プラス 10進数字(DecimalDigit)から成るMVs ]、[ n ]は、10進数字(DecimalDigits)... にある文字の数.
    ・DecimalDigit(10進数字)から成るMVs :: [ 10進数字(DecimalDigit) ]は、10進数字(DecimalDigit)から成るMV.
    ・DecimalDigit(10進数字)から成るMVs :: [ 10進数字(DecimalDigits)... 10進数字(DecimalDigit) ]は、[ (10進数字(DecimalDigit)から成るMVsの[ 10 ]倍) プラス 10進数字(DecimalDigit)から成るMV ].
    ・ExponentPart(指数部)から成るMV :: [ 指数指標(ExponentIndicator) 符号付き整数(SignedInteger) ]は、符号付き整数(SignedInteger)から成るMV.
    ・SignedInteger(符号付き整数)から成るMV :: [ 10進数字(DecimalDigit) ]は、10進数字(DecimalDigit)から成るMVs.
    ・SignedInteger(符号付き整数)から成るMV :: [ + 10進数字(DecimalDigit) ]は、10進数字(DecimalDigit)から成るMVs.
    ・SignedInteger(符号付き整数)から成るMV :: [ - 10進数字(DecimalDigit) ]は、10進数字(DecimalDigit)から成るMVsの負の値.
    ・DecimalDigit(10進数字)から成るMV :: [ 0 ] または、16進数字から成る :: [ 0 ]は、 0.
    ・DecimalDigit(10進数字)から成るMV :: [ 1 ] または、NonZeroDigit(非ゼロ数字)から成る :: [ 1 ] または、16進数字から成る :: [ 1 ]は、 1.
    ・DecimalDigit(10進数字)から成るMV :: [ 2 ] または、NonZeroDigit(非ゼロ数字)から成る :: [ 2 ] または、16進数字から成る :: [ 2 ]は、 2.
    ・DecimalDigit(10進数字)から成るMV :: [ 3 ] または、NonZeroDigit(非ゼロ数字)から成る :: [ 3 ] または、16進数字から成る :: [ 3 ]は、 3.
    ・DecimalDigit(10進数字)から成るMV :: [ 4 ] または、NonZeroDigit(非ゼロ数字)から成る :: [ 4 ] または、16進数字から成る :: [ 4 ]は、 4.
    ・DecimalDigit(10進数字)から成るMV :: [ 5 ] または、NonZeroDigit(非ゼロ数字)から成る :: [ 5 ] または、16進数字から成る :: [ 5 ]は、 5.
    ・DecimalDigit(10進数字)から成るMV :: [ 6 ] または、NonZeroDigit(非ゼロ数字)から成る :: [ 6 ] または、16進数字から成る :: [ 6 ]は、 6.
    ・DecimalDigit(10進数字)から成るMV :: [ 7 ] または、NonZeroDigit(非ゼロ数字)から成る :: [ 7 ] または、16進数字から成る :: [ 7 ]は、 7.
    ・DecimalDigit(10進数字)から成るMV :: [ 8 ] または、NonZeroDigit(非ゼロ数字)から成る :: [ 8 ] または、16進数字から成る :: [ 8 ]は、 8.
    ・DecimalDigit(10進数字)から成るMV :: [ 9 ] または、NonZeroDigit(非ゼロ数字)から成る :: [ 9 ] または、16進数字から成る :: [ 9 ]は、 9.
    ・HexDigit(16進数字) :: [ a ] または、16進数字から成る :: [ A ]は、 10.
    ・16進数字(HexDigit) :: [ b ] または、16進数字から成る :: [ B ]は、 11.
    ・16進数字(HexDigit) :: [ c ] または、16進数字から成る :: [ C ]は、 12.
    ・16進数字(HexDigit) :: [ d ] または、16進数字から成る :: [ D ]は、 13.
    ・16進数字(HexDigit) :: [ e ] または、16進数字から成る :: [ E ]は、 14.
    ・16進数字(HexDigit) :: [ f ] または、16進数字から成る :: [ F ]は、 15.
    ・16進整数リテラル(HexIntegerLiteral)から成るMV :: [ 0x 16進数字(DecimalDigit) ]は、16進数字(HexDigit).
    ・16進整数リテラル(HexIntegerLiteral)から成るMV :: [ 0X 16進数字(DecimalDigit) ]は、16進数字(HexDigit).
    ・16進整数リテラル(HexIntegerLiteral)から成るMV :: [ 16進整数リテラル(HexIntegerLiteral) 16進数字(HexDigit) ]は、[ (16進整数リテラル(HexIntegerLiteral)から成るMVの16倍) プラス 16進数字(HexDigit) ].
</code></pre><p>　一度、数値リテラルにおける正確なMVが決められると、それはNumber型の値に丸められます。 もし、MVが0だった場合、その丸め値は、[ +0 ]であり、そうでなければ、リテラルが10進リテラル(DecimalLiteral)であり、そのリテラルが20以上である有効な数字を持ち、Number(型の)値が、20番めの数字以降の有効な数字ごとに置き換えられることによって生成されたリテラルから成るMVにおけるNumber(型の)値、または数字0を伴う20番め以降の有効な数字ごとに置き換えられることによって生成されるリテラルから成るMVにおけるNumber(型の)値であり、そしてまた有効な数字の位置である20番めにリテラルを増分する場合でない限り、丸め値は、(8.5 に書いたように)MVにおけるNumber(型の)値にしなければいけません。 1つの数字は、もし、それが指数部の一部でない場合で且つ</p>
    <ul>
        <li>それが0ではない、または</li>
        <li>その左側が非ゼロ数字で、その右側に指数部内にない非ゼロ数字がある</li>
    </ul>
    <p>という場合、かなり重要です。 準拠する実装は、strictモードのコードを処理する際( 10.1.1 参照)には、B.1.1 で説明したように8進数値リテラル(OctalIntegerLiteral)を含む為に数値リテラル(NumericLiteral)の構文を拡張してはいけません。</p>
    <h3 id="7-8-4-string-literals-">7.8.4 文字列リテラル(String Literals)</h3>
    <p>　文字列リテラルは、シングルクォートやダブルクォートで括られるゼロ個以上の文字です。 各文字は、エスケープシーケンスによって表現される場合もあります。 全ての文字は、書いた文字の通り、または、閉じるクォート、バックスラッシュ、キャリッジリターン、行セパレータ、段落セパレータ、ラインフィードを除く、文字列リテラル内に現れる場合があります。 一部の文字は、エスケープシーケンスから成る書式内に現れる場合もあります。</p>
<pre><code>【構文】
    StringLiteral ::
    &quot; DoubleStringCharactersopt &quot; &#39; SingleStringCharactersopt &#39;

    DoubleStringCharacters ::
    DoubleStringCharacter DoubleStringCharactersopt

    SingleStringCharacters ::
    SingleStringCharacter SingleStringCharactersopt

    DoubleStringCharacter ::
    SourceCharacter but not one of &quot; or \ or LineTerminator \ EscapeSequence LineContinuation

    SingleStringCharacter ::
    SourceCharacter but not one of &#39; or \ or LineTerminator \ EscapeSequence LineContinuation

    LineContinuation ::
    \ LineTerminatorSequence

    EscapeSequence ::
    CharacterEscapeSequence 0 [lookahead ? DecimalDigit] HexEscapeSequence UnicodeEscapeSequence

    CharacterEscapeSequence ::
    SingleEscapeCharacter NonEscapeCharacter

    SingleEscapeCharacter ::
    one of &#39; &quot; \ b f n r t v

    NonEscapeCharacter ::
    SourceCharacter but not one of EscapeCharacter or LineTerminator

    EscapeCharacter ::
    SingleEscapeCharacter
    DecimalDigit
    x
    u

    HexEscapeSequence ::
    x HexDigit HexDigit

    UnicodeEscapeSequence ::
    u HexDigit HexDigit HexDigit HexDigit
</code></pre><p>　非終端の16進数字(HexDigit)の定義は、7.8.3 にあります。</p>
    <p>　ソース文字(SourceCharacter)は、第6項で定義されます。</p>
    <p>【セマンティクス】</p>
    <p>　文字列リテラルはString型の値に当てはめられます。 リテラルから成るString値(String value / SV)は、文字列リテラルの様々な部分に寄与する文字値(character values / CV)の為に説明されます。 このプロセスの一部として、文字列リテラル内の一部の文字は、次や7.8.3 で説明したように数学的な値(mathematical value / MV)を持つものとして解釈されます。</p>
<pre><code>・文字列リテラル(StringLiteral)のSV :: &quot;&quot; は、カラ(空／empty)文字シーケンス.
    ・文字列リテラル(StringLiteral)のSV :: &#39;&#39; は、カラ(空／empty)文字シーケンス.
    ・文字列リテラル(StringLiteral)のSV :: &quot; ダブルString文字...(DoubleStringCharacters) &quot; は、ダブルString文字(DoubleStringCharacters)のSV.
    ・文字列リテラル(StringLiteral)のSV :: &#39; シングルString文字...(SingleStringCharacters) &#39; は、シングルString文字(SingleStringCharacters)のSV.
    ・ダブルString文字(DoubleStringCharacters)のSV :: ダブルString文字(DoubleStringCharacter)は、一文字のシーケンス(並び)、ダブルString文字(DoubleStringCharacter)のCV.
    ・ダブルString文字(DoubleStringCharacters)のSV :: ダブルString文字(DoubleStringCharacter) ダブルString文字...(DoubleStringCharacters)は、指示内のダブルString文字(DoubleStringCharacters)のSVにある全ての文字に続くダブルString文字(DoubleStringCharacter)のCVのシーケンス(並び).
    ・シングルString文字(SingleStringCharacters)のSV :: シングルString文字(SingleStringCharacter)は、一文字のシーケンス(並び)、シングルString文字(SingleStringCharacter)のCV.
    ・シングルString文字(SingleStringCharacters)のSV :: シングルString文字(SingleStringCharacter シングルString文字...(SingleStringCharacters)は、指示内のシングルString文字(SingleStringCharacters)のSVにある全ての文字に続くシングルString文字(SingleStringCharacter)のCVのシーケンス(並び).
    ・行継続(LineContinuation)のSV :: \ 行終端シーケンス(LineTerminatorSequence) は、カラ(空／empty)文字シーケンス.
    ・ダブルString文字(DoubleStringCharacter)のCV :: &quot; や \ や行終端(LineTerminator)の1つではないソース文字(SourceCharacter)は、その文字自身がソース文字(SourceCharacter).
    ・ダブルString文字(DoubleStringCharacter)のCV :: \ エスケープシーケンス(EscapeSequence)は、エスケープシーケンス(EscapeSequence)のCV.
    ・ダブルString文字(DoubleStringCharacter)のCV :: LineContinuation は、カラ(空／empty)文字シーケンス.
    ・シングルString文字(SingleStringCharacter)のCV :: &#39; や \ や行終端(LineTerminator)の1つではないソース文字(SourceCharacter)は、その文字自身がソース文字(SourceCharacter).
    ・シングルString文字(SingleStringCharacter)のCV :: \ エスケープシーケンス(EscapeSequence)は、エスケープシーケンス(EscapeSequence)のCV.
    ・シングルString文字(SingleStringCharacter)のCV :: LineContinuation は、カラ(空／empty)文字シーケンス.
    ・エスケープシーケンス(EscapeSequence)のCV :: 文字エスケープシーケンス(CharacterEscapeSequence)は、文字エスケープシーケンス(CharacterEscapeSequence)のCV.
    ・エスケープシーケンス(EscapeSequence)のCV :: 0 [lookahead ? DecimalDigit] は、 &lt;NUL&gt; 文字 (Unicode値 0000).
    ・エスケープシーケンス(EscapeSequence)のCV :: 16進エスケープシーケンス(HexEscapeSequence)は、 16進エスケープシーケンス(HexEscapeSequence)のCV.
    ・エスケープシーケンス(EscapeSequence)のCV :: Unicodeエスケープシーケンス(UnicodeEscapeSequence)は、 Unicodeエスケープシーケンス(UnicodeEscapeSequence)のCV.
    ・文字エスケープシーケンス(CharacterEscapeSequence)のCV :: シングルエスケープ文字(SingleEscapeCharacter)は、 Table 4と一致するシングルエスケープ文字(SingleEscapeCharacter)であるコードユニット値である文字：
</code></pre><table>
    <thead>
    <tr>
        <th>エスケープシーケンス</th>
        <th>コードユニット値</th>
        <th>名称</th>
        <th>記号</th>
    </tr>
    </thead>
    <tbody>
    <tr>
        <td>\b</td>
        <td>\u0008</td>
        <td>backspace</td>
        <td>\&lt;BS\&gt;</td>
    </tr>
    <tr>
        <td>\t</td>
        <td>\u0009</td>
        <td>horizontal tab</td>
        <td>\&lt;HT\&gt;</td>
    </tr>
    <tr>
        <td>\n</td>
        <td>\u000A</td>
        <td>line feed (new line)</td>
        <td>\&lt;LF\&gt;</td>
    </tr>
    <tr>
        <td>\v</td>
        <td>\u000B</td>
        <td>vertical tab</td>
        <td>\&lt;VT\&gt;</td>
    </tr>
    <tr>
        <td>\f</td>
        <td>\u000C</td>
        <td>form feed</td>
        <td>\&lt;FF\&gt;</td>
    </tr>
    <tr>
        <td>\r</td>
        <td>\u000D</td>
        <td>carriage return</td>
        <td>\&lt;CR\&gt;</td>
    </tr>
    <tr>
        <td>\&quot;</td>
        <td>\u0022</td>
        <td>double quote</td>
        <td>&quot;</td>
    </tr>
    <tr>
        <td>\’</td>
        <td>\u0027</td>
        <td>single quote</td>
        <td>’</td>
    </tr>
    <tr>
        <td>\\</td>
        <td>\u005C</td>
        <td>backslash</td>
        <td>\</td>
    </tr>
    </tbody>
</table>
<pre><code>・文字エスケープシーケンス(CharacterEscapeSequence)のCV ::
    　非エスケープ文字(NonEscapeCharacter)は、非エスケープ文字(NonEscapeCharacter)のCV

    ・非エスケープ文字(NonEscapeCharacter)のCV ::
    　エスケープ文字(EscapeCharacter)や行終端ではないソース文字(SourceCharacter)は、ソース文字(SourceCharacter)自体がその文字自身

    ・16進エスケープシーケンス(HexEscapeSequence)のCV ::
    　x 16進数字 16進数字( x HexDigit HexDigit)は、
    　コードユニット値が(最初の16進数字の MV 16通り) プラス 2番めの16進数字の MV である文字

    ・Unicodeエスケープシーケンス(UnicodeEscapeSequence)のCV ::
    　u 16進数字 16進数字 16進数字 16進数字( u HexDigit HexDigit HexDigit HexDigit)は、
    　コードユニット値が(最初の16進数字の MV 4,096通り) プラス (2番めの16進数字の MV 256通り) プラス (3番めの16進数字16通り) プラス 4番めの16進数字の MV である文字
</code></pre><p>　準拠する実装は、strictモードのコードを処理する際には、B.1.2で説明したように8進エスケープシーケンスを含む為にエスケープシーケンス(EscapeSequence)の構文を拡張しない場合があります。</p>
    <p>[注釈]</p>
    <p>　ある1つの行終端文字は、カラ文字シーケンスを生成する為の行継続の一部である場合を除き、文字列リテラル内に現れることはできません。 文字列リテラルのString値の一部とする為の行終端文字による修正方法は、\n や \u000A のようなエスケープシーケンスを利用することです。</p>
    <h3 id="7-8-5-regular-expression-literals-">7.8.5 正規表現リテラル(Regular Expression Literals)</h3>
    <p>　正規表現リテラルは、リテラルが評価されるたびにRegExpオブジェクト(15.10 参照)に変換される入力要素です。 正規表現オブジェクトを評価するプログラム内にある2つの正規表現リテラルは、リテラルの内容が識別される場合でさえ、それぞれが === として比較されることはありません。 RegExpオブジェクトは、新たなRegExp(15.10.4 参照)や関数(15.10.3)の場合にはRegExpコンストラクタを呼ぶことによって実行時に生成される場合もあります。 生成される結果は、続く正規表現リテラルにおけるシンタックスを説明し、正規表現リテラルの終わりまで探す為の入力要素の走査によって使われます。 正規表現本体(RegularExpressionBody)と正規表現フラグ(RegularExpressionFlags)を構成する複数文字の文字列は、正規表現コンストラクタとして解釈されずに渡され、独自の、より厳格な文法に従ってそれらを解釈します。 実装は、正規表現コンストラクタの文法を拡張する場合がありますが、これらのプロダクションで使用した正規表現本体(RegularExpressionBody)と正規表現フラグ(RegularExpressionFlags)、または、そのプロダクションを拡張してはいけません。</p>
<pre><code>【構文】

    RegularExpressionLiteral ::
    / RegularExpressionBody / RegularExpressionFlags

    RegularExpressionBody ::
    RegularExpressionFirstChar RegularExpressionChars

    RegularExpressionChars ::
    [empty] RegularExpressionChars RegularExpressionChar

    RegularExpressionFirstChar ::
    RegularExpressionNonTerminator but not one of * or \ or / or [ RegularExpressionBackslashSequence RegularExpressionClass

    RegularExpressionChar ::
    RegularExpressionNonTerminator but not one of \ or / or [ RegularExpressionBackslashSequence RegularExpressionClass

    RegularExpressionBackslashSequence ::
    \ RegularExpressionNonTerminator

    RegularExpressionNonTerminator ::
    SourceCharacter but not LineTerminator

    RegularExpressionClass ::
    [ RegularExpressionClassChars ]

    RegularExpressionClassChars ::
    [empty] RegularExpressionClassChars RegularExpressionClassChar

    RegularExpressionClassChar ::
    RegularExpressionNonTerminator but not one of ] or \ RegularExpressionBackslashSequence

    RegularExpressionFlags ::
    [empty] RegularExpressionFlags IdentifierPart
</code></pre><p>[注釈]</p>
    <p>　正規表現リテラルは、カラにならない場合もあります。 正規表現リテラルが、カラにならない場合、カラの正規表現リテラルを表現する代わりに文字</p>
<pre><code>//
</code></pre><p>(スラッシュ2つ)で始まる単一行コメントを使用します。 カラの正規表現を書くには、</p>
<pre><code>/(?:)/
</code></pre><p>を使用します。</p>
    <p>【セマンティクス】</p>
    <p>　正規表現リテラルは、標準組み込みコンストラクタRegExpのインスタンスであるObject型の値を評価します。 この値は、2つの段階を経て決められます。 まず、正規表現の正規表現本体(RegularExpressionBody)と正規表現フラグ(RegularExpressionFlags)の拡張を構成する複数文字は、それぞれ2つの文字列パターンとフラグについて解釈されずに収集されます。 その時、そのリテラルが評価されるごとに、その名前を持つ標準組み込みコンストラクタRegExpをまるで新たなRegExp(Pattern, Flags)という式によって生成されるかのように新たなオブジェクトが生成されます。 新たに構築されるオブジェクトは、正規表現リテラル(RegularExpressionLiteral)の値になります。 もし、new RegExp をコールすると 15.10.4.1 に書いたようなエラーを生成する場合、そのエラーは、初期エラー(第16項)として扱われなければいけません。</p>
    <h2 id="7-9-automatic-semicolon-insertion-standard-ecma-262-5-1-edition">7.9 自動セミコロン挿入 / Automatic Semicolon Insertion / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="7-">7 語彙的な表記</h3>
    <h3 id="7-9-">7.9 自動セミコロン挿入</h3>
    <p>　厳密なECMAScriptステートメント(emptyステートメント、variableステートメント、expressionステートメント、do-whileステートメント、continueステートメント、breakステートメント、returnステートメント、throwステートメント)は、セミコロンを伴った終端にしなければいけません。 そのようなセミコロンは、常にソーステキスト内に明示的に現れる場合があります。 利便性の為ではありますが、そのようなセミコロンが、特定の状況下ではソーステキストから省略される場合もあります。 これらの状況は、それらの状況におけるソースコード字句(トークン)ストリームにセミコロンが自動的に挿入されると言うことによって説明されます。</p>
    <h3 id="7-9-1-">7.9.1 自動セミコロン挿入のルール／規則</h3>
    <p>　セミコロン挿入の基本ルールは3つあります。</p>
    <p>左から右に実行されるプログラムである場合、字句(対象となる字句)が、その文法から成る一部の生成結果によって受け入れられないという状況に遭遇した場合には、1つ以上の真である条件に続く対象の字句である場合、その字句の前にセミコロンが自動的に挿入されます。</p>
    <ul>
        <li>対象となる文字が、最低1つの行終端(LineTerminator)によって字句の前方から分割される場合</li>
        <li>対象となる文字が、 } (右波カッコ)である場合</li>
    </ul>
    <p>左から右に実行されるプログラムである場合、字句の入力ストリームの終わりが、単独で完了したECMAScriptプログラムのようにパーサーが入力字句ストリームを解析できないという状況に遭遇した場合には、セミコロンが、入力ストリームの終わりに自動的に挿入されます。</p>
    <p>左から右に実行されるプログラムである場合、字句は、その文法から成る一部の生成される結果によって受け入れられるという状況に遭遇したものの、その生成結果が制限付きの生成結果で、字句が、(そしてそれゆえにそのような字句は制限付き字句と呼ばれる)その制限付き生成結果内にある注釈[no LineTerminator here(ここに行終端はない)]の直後に続く終端または非終端における最初の字句であり、その制限付き字句が、少なくとも1つの行終端(LineTerminator)によって前方の字句から分割される場合には、セミコロンが制限付き字句の前に自動的に挿入されます。</p>
    <p>　しかしながら、それらは先行するルールにおける付加的な上書き条件です。 もし、そのセミコロンが、その際にカラのステートメントとして解析されたり、そのセミコロンがステートメント(12.6.3 for 文 参照)におけるヘッダ内にある2つのセミコロンの内の1つになる場合には、セミコロンが、自動的に挿入されることはありません。</p>
    <p>[注釈]</p>
    <p>次の内容は当該文法内で制限付き生成結果に限定されます。</p>
<pre><code>PostfixExpression :
    LeftHandSideExpression [no LineTerminator here] ++
    LeftHandSideExpression [no LineTerminator here] --

    (
    後置式 :
    左側の式 [ここに行終端はない] ++
    左側の式 [ここに行終端はない] --
    )

    ContinueStatement :
    continue [no LineTerminator here] Identifier ;

    (
    continue 文 :
    continue [ここに行終端はない] 識別子(ラベル) ;
    )

    BreakStatement :
    break [no LineTerminator here] Identifier ;

    (
    break 文 :
    break [ここに行終端はない] 識別子(ラベル) ;
    )

    ReturnStatement :
    return [no LineTerminator here] Expression ;

    (
    return 文 :
    return [ここに行終端はない] 式 ;
    )

    ThrowStatement :
    throw [no LineTerminator here] Expression ;

    (
    throw 文 :
    throw [ここに行終端はない] 式 ;
    )
</code></pre><p>　これら制限付き生成結果の実用的な効果は、次のようなものです。 ++ や – という字句が現れる場合、パーサーは、後置演算子、つまり先行する字句と ++ や – という字句の間に少なくとも1つの行終端(LineTerminator)が現れる場合には、 ++ や – という字句の前にセミコロンが自動的に挿入されてしまいます。 continue/break/return/throwといった字句が現れ、行終端(LineTerminator)が、次の字句の前に現れる場合には、セミコロンは、continue/break/return/throwといった字句の後に自動的に挿入されてしまいます。</p>
    <p>　(よって)ECMAScriptプログラマへの結果的且つ実用的なアドバイスとしては、後置 ++ や – 演算子は、そのオペランドと同一行に現れるべきです。 returnやthrowステートメント内の式は、returnやthrow字句と同一行で始まるべきです。 breakやcontinueステートメント内の識別子は、breakやcontinue字句と同一行にあるべきです。</p>
    <h3 id="7-9-2-">7.9.2 自動セミコロン挿入の例</h3>
    <p>ソース</p>
<pre><code>{ 1 2 } 3
</code></pre><p>は、ECMAScript文法上、セミコロン自動挿入ルール上も有効な文ではありません。</p>
    <p>対照的なソース</p>
<pre><code>{ 1
    2 } 3
</code></pre><p>もまた、有効なECMAScript文ではありませんが、自動セミコロン挿入によって次のように変換されます。</p>
<pre><code>{ 1
    ;2 ;} 3;
</code></pre><p>は、有効なECMAScript文です。</p>
    <p>ソース</p>
<pre><code>for (a; b
    )
</code></pre><p>は、有効なECMAScript文ではなく、文として構成するヘッダとしてセミコロンが必要とされる為、自動セミコロン挿入によって変更されません。 自動セミコロン挿入は、文として構成するヘッダ内にある2つのセミコロンの内1つだけ挿入するということはありません。</p>
    <p>ソース</p>
<pre><code>return
    a + b
</code></pre><p>は、自動セミコロン挿入によって次のように変換されます。</p>
<pre><code>return;
    a + b;
</code></pre><p>[注釈]</p>
    <p>　式 a + b は、行終端(LineTerminator)が字句returnからそれを分割する為、return文によって返却される値として扱われることはありません。</p>
    <p>ソース</p>
<pre><code>a = b
    ++c
</code></pre><p>は、自動セミコロン挿入によって次のように変換されます。</p>
<pre><code>a = b;
    ++c;
</code></pre><p>[注釈]</p>
    <p>　字句 ++ は、行終端(LineTerminator)が、b と ++ 間に現れる為、変数bに適用される後置演算子としては扱われません。</p>
    <p>ソース</p>
<pre><code>if (a &gt; b)
    else c = d
</code></pre><p>は、有効なECMAScript文ではなく、自動的に挿入したセミコロンは、その際に空文として解釈される為、その時点において適用する文法のプロダクションであったとしても他の字句の前に自動セミコロン挿入によって変更されることはありません。</p>
    <p>ソース</p>
<pre><code>a = b + c
    (d + e).print()
</code></pre><p>は、2行めから始まるカッコで括られた式が関数呼び出し(ファンクションコール)における引数リストとして解釈されることが可能である為、自動セミコロン挿入によって変換されることはありません。</p>
<pre><code>a = b + c(d + e).print()
</code></pre><p>　左カッコで始まらなければならない文に関連する状況では、それは自動挿入セミコロンに頼ることなく先行する文の末尾に明示的にセミコロンを置くことはプログラマとして良い考えです。</p>
    <h2 id="8-types-standard-ecma-262-5-1-edition">8 タイプ・型 / Types / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="8-">8 タイプ・型</h3>
    <p>　この仕様内のアルゴリズムは、関連した型を持つ、それぞれの値を操作します。 利用可能な値の型は、まさにこの項で定義されるものです。 型は、もっと言えば、ECMAScript言語の型と仕様の型に分類されます。</p>
    <p>　ECMAScript言語の型は、ECMAScript言語を使うECMAScriptプログラマによって直接操作される値と一致します。 ECMAScript言語の型は、Undefined、Null、Boolean、String、Number、Objectです。</p>
    <p>　仕様の型は、ECMAScript言語の構造とECMAScript言語の型のセマンティクスを説明するアルゴリズム内で利用されるメタデータ値(meta-values)と一致します。 仕様の型は、Reference、List、Completion、Property Descriptor、Property Identifier、Lexical Environment、Environment Recordです。 仕様型の値は、ECMAScript実装の中で記述する一部の実体(entity/エンティティ)と一致する必要のない人為的に作られた(artefacts/アーティファクト)仕様です。 仕様型の値は、ECMAScript式の評価の中間結果を説明する為に利用される場合がありますが、そのような値は、オブジェクトのプロパティやECMAScript言語の変数の値として保持することはできません。</p>
    <p>　この仕様内では、表記法“Type(x)”は、この項で定義したECMAScript言語の型と仕様の型を参照する“型”である“xの型”における略記として使用されます。</p>
    <h2 id="8-1-undefined-the-undefined-type-standard-ecma-262-5-1-edition">8.1 Undefined型 / The Undefined Type / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="8-">8 タイプ・型</h3>
    <h3 id="8-1-undefined-">8.1 Undefined型</h3>
    <p>　Undefined(未定義)型は、まさにUndefinedと呼ばれる1つの値を持ちます。 ある1つの値に関連付けられていない一部の変数は、未定義の値を持ちます。</p>
    <h2 id="8-2-null-the-null-type-standard-ecma-262-5-1-edition">8.2 Null型 / The Null Type / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="8-">8 タイプ・型</h3>
    <h3 id="8-2-null-">8.2 Null型</h3>
    <p>　Null型は、まさにnullと呼ばれる1つの値を持ちます。</p>
    <h2 id="8-3-boolean-the-boolean-type-standard-ecma-262-5-1-edition">8.3 Boolean型 / The Boolean Type / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="8-">8 タイプ・型</h3>
    <h3 id="8-3-boolean-">8.3 Boolean型</h3>
    <p>　Boolean型は、trueとfalseと呼ばれる2つの値を持つ論理的な実体(論理エンティティ)を表します。</p>
    <h2 id="8-4-string-the-string-type-standard-ecma-262-5-1-edition">8.4 String型 / The String Type / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="8-">8 タイプ・型</h3>
    <h3 id="8-4-string-">8.4 String型</h3>
    <p>　String(文字列)型は、その全てがゼロ以上の16ビット符号付き整数値から成る序数並びで終わる集合(“elements”／エレメント・要素)です。 String型は、コードユニット値(第6項参照)として扱われるStringの中でも各要素ごとにECMAScriptプログラム実行時にテキストのデータを表現する為に使用されるのが一般的です。 各要素は、その並びの中である位置を占有するものとしてみなされます。 これらの位置は非負の整数を伴って索引付け(インデックス)されます。 (もしあれば)最初の要素は、位置が0、(もしあれば)次の要素の位置は1。。。等々といった感じです。</p>
    <p>　Stringの長さは、その中にある要素(例えば16ビット値の)数です。 空のStringは、長さゼロであり、それゆえに要素は1つも含みません。 Stringが実際のテキストデータを含む場合、各要素は、単独のUTF-16コードユニットとして認識されます。 これは、Stringの実際の保存形式がどうであったとしてもString内の文字並びは、UTF-16を使って表現されたものであるかのように要素位置にそれらの初期コードユニットによって番号付けされます。 (他の状態にある場合を除き)Strings上の全ての演算子は、未分化状態の16ビット符号なし整数としてそれらを扱います。 それらは、結果となるStringが言語依存の結果を確保するか否かに関わらず、正規形であるということを保証しません。</p>
    <p>[注釈]</p>
    <p>　この設計の背景にある論理的根拠は、同じように単純かつ高速処理可能であるStringsの実装を保持するという事です。 その意図は、外部からの実行環境によるテキストデータ(例えば、ユーザー入力やファイルから読み込んだテキスト、ネットワーク越しに受け取ったテキスト等々)は、実行中プログラムがそれと遭遇する前に“Unicode Normalised Form C”に変換されているということです。</p>
    <p>[追記]</p>
<pre><code>&quot;Unicode Normalised Form C&quot;とは、Unicodeによる[ Unicode Normalization Forms ]で定められた書式であり、
    [ http://unicode.org/reports/tr15/#Norm_Forms ]
    内の
    [ http://unicode.org/reports/tr15/#Normalization_Forms_Table ]
    にある下記4つの正規化の内の1つ。
    ------------------------------------------------------------------
    Normalization Form D (NFD)  ：正規の名詞
    Normalization Form C (NFC)  ：正規の構成に続く正規の名詞
    Normalization Form KD (NFKD)    ：互換性のある名詞
    Normalization Form KC (NFKC)    ：正規の構成に続く互換性のある名詞
    ------------------------------------------------------------------
</code></pre><p>Table 1. Normalization Forms / 正規化の形式</p>
    <table>
        <thead>
        <tr>
            <th>形式</th>
            <th>説明</th>
        </tr>
        </thead>
        <tbody>
        <tr>
            <td>Normalization Form D (NFD)</td>
            <td>Canonical Decomposition           </td>
        </tr>
        </tbody>
    </table>
<pre><code>                            正規分解                           |
</code></pre><p>| Normalization Form C (NFC)   | Canonical Decomposition,<br>                                followed by Canonical Composition<br>                                正規構成が続く正規分解             |
    | Normalization Form KD (NFKD) | Compatibility Decomposition<br>                                互換分解                           |
    | Normalization Form KC (NFKC) | Compatibility Decomposition,<br>                                followed by Canonical Composition<br>                                正規構成が続く互換分解             |</p>
    <p>　通常、これは、Unicodeにその元の文字符号化方式から変換され(、追加のオーバーヘッドなく課され)ると同時に入ってくるテキストに現れます。 ECMAScriptのソースコードが“Normalised Form C”の中にあることが推奨されていることから文字列リテラルは、(もし、ソーステキストが正規形であると保証される場合には、)いかなるUnicodeエスケープシーケンスをも含まないのと同じ長さに正規化されることが保証されます。</p>
    <h2 id="8-5-number-the-number-type-standard-ecma-262-5-1-edition">8.5 Number型 / The Number Type / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="8-">8 タイプ・型</h3>
    <h3 id="8-5-number-">8.5 Number型</h3>
    <p>　Number型は、単一の特殊な NaN 値としてECMAScript内で表現されるIEEE標準規格の値である“Not-a-Number”とは異なる 9007199254740990 (2の53乗 - 2 )を除き、2進浮動小数点演算におけるIEEE標準規格で記述したように倍精度64ビットフォーマット IEEE 754 の値を表現する、まさに 18437736874454810627 ( 2の64乗 - 2の53乗 + 3 )という値を持ちます。 (注釈：当該 NaN 値は、プログラム式 NaN によって生成される値です。) 同じ実装内では、外部コードが様々な Not-a-Number 値間で異なるものとして検出することができる場合もあるかもしれませんが、そのような動作は実装依存であり、(本来、)ECMAScriptコードにおいては、全ての NaN 値は、他のものと見分けがつかないものです。</p>
    <p>　他に正の無限大と負の無限大と呼ばれる2つの特殊な値があります。 簡潔に言うと、それらの値は、それぞれ +∞ 、 -∞ という記号によって解説目的において参照される場合もあります。 (注釈：これら2つの無限大Number値は、+Infinity(または単にInfinity)と-Infinityといったようにプログラム式によって生成されます。)</p>
    <p>　他方、18437736874454810624 ( 2の64乗 - 2の53乗 ) という値は、有限数値と呼ばれます。 これらの半分は正の数値であり、半分は負の数値です。 有限の正のNumber値においてそれは、同じ大きさを持つ負の値と一致します。</p>
    <p>　追記するとそれらは、正のゼロと負のゼロの両方があるということです。</p>
    <p>　簡潔に言えば、これらの値は、それぞれ +0 と -0 という記号によって解説目的において参照される場合もあります。 (追記するとこれら2つの異なるゼロというNumber値は、 +0 (または単に 0 )と -0 といったようにプログラム式によって生成されます。)</p>
    <p>　18437736874454810622 ( 2の64乗 - 2の53乗 + 2 )という有限の非ゼロ値には2つの種類があります。 それらの内、18428729675200069632 ( 2の64乗 - 2の54乗 ) は、s が +1 または -1 、m が 2の52乗以上で且つ 2の53乗より小さい正の整数、 e が -1074 から 971 を含む範囲の整数である</p>
<pre><code>s * m * 2e ( 2^e 2のe乗 )
</code></pre><p>という書式を持っています。</p>
    <p>　残りの 9007199254740990 ( 2の53乗 - 2 )という値は、非正規形であり、s が +1 または -1 、m が 2の52乗より小さい正の整数、 e が -1074 である</p>
<pre><code>s * m * 2e ( 2^e 2のe乗 )
</code></pre><p>という書式を持っています。</p>
    <p>　追記すると大きさが2の53乗より大きいものはない全ての正と負の整数は、Number型で表現されます(他方、整数 0 は、 +0 と -0 という2つの表現を持ちます)。</p>
    <p>　有限の数は、それが、非ゼロで且つ、整数 m を(上記で示した2つの書式の対の1つの中で)それを表す為に使用した場合には、奇数の仮数を持ち、他方は、偶数の仮数を持ちます。</p>
    <p>　この仕様内では、&quot; x における Number値“というフレーズ、つまり x は、次の方法で選択したNumber値を意味する(πのような不合理な数値になる場合でさえ)実際の数学的な量であるまさに非ゼロを表します。 -0を取り除き、Number型で表さない、それに加算した2つの加算値、すなわち 2の1024乗 ( +1 * 2の53乗 * 2の971乗 )と -2の1024乗 ( -1 * 2の53乗 * 2の971乗 )を伴うNumber型の有限の値全ての集合を考えてみましょう。 xの値に最も近いこのセットのメンバーを選択しましょう。 もし、セットの内、2つの値が等しければ、偶数の仮数を伴う一方が選択されます。 この目的において2つの外部値 2の1024乗 と -2の1024乗 は偶数の仮数を持つことが考慮されます。 最後にもし、2の1024乗 が選択され、+∞ を伴うそれを置換する場合、もし、-2の1024乗が選択され、-∞を伴うそれを置換する場合、もし、+0 が選択され、x がゼロより小さい場合にのみ -0を伴うそれを置換する場合には、他の選択値は変更されずに使われます。 その結果は、x におけるNumber値です。 (このプロシージャは、IEEE 754 の ”近似値丸め“(”round to nearest&quot;)モードの動作と正確に一致します。)</p>
    <p>　一部のECMAScript演算子は、-2の31乗から 2の31乗-1 を含む、または、0 から -2の32乗-1 を含む範囲内にある整数を伴う場合に限って扱います。 これらの演算子は、一部のNumber型の値を許容しますが、最初は、2の32乗という整数値の1つをこのような値にそれぞれ変換します。 9.5 と 9.6 にある ToInt32 と ToUint32 演算子の説明を参照しましょう。</p>
    <h2 id="8-6-object-the-object-type-standard-ecma-262-5-1-edition">8.6 Object型 / The Object Type / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="8-">8 タイプ・型</h3>
    <h3 id="8-6-object-">8.6 Object型</h3>
    <p>　Objectは、プロパティの集合です。 各プロパティは、それぞれ名前付きデータプロパティ、名前付きアクセサプロパティ、内部プロパティ等です。</p>
    <ul>
        <li>名前付きデータプロパティは、ECMAScript言語の値とBoolean属性のセットを持つ名称と関連付けします。</li>
        <li>名前付きアクセサプロパティは、1つまたは2つのアクセサ関数を持つ名称とBoolean属性のセットと関連付けします。 アクセサ関数は、プロパティと関連付けられるECMAScript言語の値を保存または検索する為に使われます。</li>
        <li>内部プロパティは、名称を持たず、ECMAScript言語の演算子経由で直接アクセスされることはありません。 内部プロパティは、純粋に(単に)仕様記述目的の為に存在します。</li>
    </ul>
    <p>　名前付き(非内部)プロパティにおけるアクセスの種類には、get と put の2つがあり、それぞれ検索と関連付けに一致します。</p>
    <h3 id="8-6-1-property-attributes">8.6.1 プロパティの属性 / Property Attributes</h3>
    <p>　属性(アトリビュート)は、名前付きプロパティの状態を定義し、説明する為にこの仕様内で使われます。 名前付きデータプロパティは、Table 5で列挙した属性を持つ名称と関連付けます。</p>
<pre><code>Table 5 名前付きデータプロパティの属性
    ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    属性名         値領域             説明
    ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    [[Value]]       任意のECMAScript言語の型   値はプロパティを読むことによって取得されます。
    [[Writable]]        Boolean             もし、falseなら、実行中の[[Put]]を使って当該プロパティの[[Value]]属性を変更する為にECMAScriptコードによって試行しても成功しないでしょう。
    [[Enumerable]]      Boolean             もし、trueなら、プロパティは、for-in 文( 12.6.4 参照)によって評価されます。
    そうでない場合には、プロパティはnon-enumerable(列挙不可)であると言われます。
    [[Configurable]]    Boolean             もし、falseなら、プロパティを削除しようとしたり、アクセサプロパティにする為にプロパティを変更したり、その([[Value]]ではない)属性を変更しようとしたりすると失敗するでしょう。
    ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
</code></pre><p>　名前付きアクセサプロパティは、Table 6で列挙した属性を持つ名称と関連付けます。</p>
<pre><code>Table 6 名前付きアクセサプロパティの属性
    -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    属性名         値領域             説明
    -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    [[Get]]         Object または Undefined        もし、その値が、Objectなら、それは関数Objectにしなければいけません。
    その関数の内部メソッド[[Call]]( 8.6.2 )は、そのプロパティのgetアクセスが実行されるごとに当該プロパティ値を返す為に空の引数リストを伴って呼び出されます。
    [[Set]]         Object または Undefined        もし、その値が、Objectなら、それは関数Objectにしなければいけません。
    その関数の内部メソッド[[Call]]( 8.6.2 )は、そのプロパティのsetアクセスが実行されるごとに、その全ての引数として関連付けた値を含んだ引数リストを伴って呼び出されます。
    任意のプロパティの内部メソッド[[Set]]の効果は、要求はされないものの、当該プロパティの[[Get]]内部メソッドを順次呼び出すことによって返した値について効果を持ちます。
    [[Enumerable]]      Boolean             もし、trueなら、そのプロパティは、 for-in文( 12.6.4 参照)によって評価されます。
    そうでない場合には、そのプロパティは、non-enumerable(列挙不可)であると言われます。
    [[Configurable]]    Boolean             もし、falseなら、そのプロパティを削除しようとしたり、任意のデータプロパティにする為に当該プロパティを変更しようとしたり、その属性を変更しようとすると失敗するでしょう。
    -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
</code></pre><p>　もし、属性の値が、名前付きプロパティにおけるこの仕様によって明示的に書かれていない場合には、既定値は、Table 7 で定義したものが使用されます。</p>
<pre><code>Table 7 既定の属性値
    ----------------------------------
    属性名         既定値
    ----------------------------------
    [[Value]]       undefined
    [[Get]]         undefined
    [[Set]]         undefined
    [[Writable]]        false
    [[Enumerable]]      false
    [[Configurable]]    false
    ----------------------------------
</code></pre><h3 id="8-6-2-">8.6.2 オブジェクト内部プロパティと内部メソッド</h3>
    <p>　この仕様は、オブジェクトの値のセマンティクスを定義する為に様々な内部プロパティを使います。 これらの内部プロパティは、ECMAScript言語の一部ではありません。 それらは、単に解説目的の為に、この仕様によって定義されているだけです。 ECMAScriptの実装は、ここで書かれた方法の中で内部プロパティを生成、操作するかのようにふるまわなければいけません。 内部プロパティの名称は、二重角ブラケット[[ ]]で括られます。 アルゴリズムがオブジェクトの内部プロパティを利用し、当該オブジェクトが内部プロパティを示す実装をしない場合には、TypeErrorという例外が投げられ(スローされ)ます。</p>
    <p>　内部プロパティの要約である Table 8 は、全てのECMAScriptオブジェクトに適用されるこの仕様によって使われます。 内部プロパティの要約である Table 9 は、一部のECMAScriptオブジェクトに適用される場合に限り、この仕様によって使われます。 これらの表にある説明は、ネイティブなECMAScriptオブジェクトの特定の種類においてこの文書内で特に述べない限りは、ネイティブなECMAScriptオブジェクトにおけるこれらの動作を示します。 ホストオブジェクトは、この文書内で述べた指定するホストオブジェクトの制約を伴う構成と同じである限り、任意の実装依存の振る舞いを伴うこれらの内部プロパティをサポートする場合があります。</p>
    <p>　次の表の“値の型領域 / Value Type Domain”という列は、内部プロパティ付きで関連付けた値の型を定義します。 型名は、次に付加される名称によって第8項の中で定義した型を参照します。 “any”は、任意のECMAScript言語の型になる場合がある値を意味します。 “primitive”は、Undefined、Null、Boolean、String、Number(という型)を意味します。 “SpecOp”は、内部プロパティが、内部メソッドであり、抽象操作仕様によって先行定義した実装であることを意味します。 “SpecOp”は、パラメータ名を説明したリストによって続けられます。 もし、パラメータ名が型名と同じである場合には、名称はパラメータの型として説明されます。</p>
    <p>　もし、“SpecOp”が、値を返す場合には、そのパラメータリストは、記号“→”によって返した値の型が続けられます。</p>
<pre><code>Table 8 全てのオブジェクトに共通する内部プロパティ
    ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    内部プロパティ         値の型領域／Value Type Domain                 概要
    ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    [[Prototype]]           Object または、 Null                        当該オブジェクトにおけるプロパティ
    [[Class]]           String                              String値が示す仕様はオブジェクトという分類で定義しました。
    [[Extensible]]          Boolean                             もし、trueなら、そのプロパティ自身がオブジェクトに追加される場合があります。
    [[Get]]             SpecOp (propertyName) → any                 名前付きプロパティの値を返します。
    [[GetOwnProperty]]      SpecOp (propertyName) →Undefined or Property Descriptor 当該オブジェクトのプロパティ自体に名前を付けるプロパティ記述子(Property Descriptor)、もし、なければ未定義(undefined)を返します。
    [[GetProperty]]         SpecOp (propertyName) →Undefined or Property Descriptor 当該オブジェクトの名前付きプロパティの完全形のプロパティ記述子(Property Descriptor)、もし、なければ未定義(undefined)を返します。
    [[Put]]             SpecOp (propertyName, any, Boolean)             2番めのパラメータの値に記述済み名前付きプロパティを設定します。
    フラグは、エラー処理を制御します。
    [[CanPut]]          SpecOp (propertyName) → Boolean             実行可能なプロパティ名(PropertyName)を伴う[[Put]]操作か否かを示すBoolean値を返します。
    [[HasProperty]]         SpecOp (propertyName) → Boolean             与えられた名称のプロパティを既に持っているオブジェクトか否かを示すBoolean値を返します。
    [[Delete]]          SpecOp (propertyName, Boolean) → Boolean            当該オブジェクトから記述済みの名前付きの自身のプロパティを削除します。
    フラグはエラー処理を制御します。
    [[DefaultValue]]        SpecOp (Hint) → primitive                   Hintは文字列です。当該オブジェクトにおける既定値を返します。
    [[DefineOwnProperty]]       SpecOp (propertyName, PropertyDescriptor, Boolean) → Boolean    プロパティ記述子(Property Descriptor)によって説明した状態を持つ名前付きプロパティそれ自体を生成、または変更します。
    フラグはエラー処理を制御します。
    ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
</code></pre><p>　(ホストオブジェクトを含む)各オブジェクトは、Table 8に列挙された内部プロパティの全てを実装しなければいけません。 しかしながら、[[DefaultValue]]内部メソッドは、一部のオブジェクトにおいては、単にTypeError例外を投げる(スローする)だけという場合もあります。</p>
    <p>　全てのオブジェクトは、[[Prototype]]と呼ばれる内部プロパティを持ちます。 このプロパティの値は、nullだったり、オブジェクトだったりし、実装している継承において使用されます。 ネイティブオブジェクトか否かに関わらず、その実装に依存する[[Prototype]]としてホストオブジェクトを持つことが可能です。 各[[Prototype]]チェーンは、有限の長さにしなければいけません。 (あるオブジェクトから始まるということは、最終的にはnull値に先行しなければいけない[[Prototype]]内部プロパティに再帰的にアクセスするという事です。) [[Prototype]]オブジェクトの名前付きデータプロパティは、putアクセスではなく、getアクセスの目的において(子オブジェクトのプロパティとして表示され、)継承されます。 名前付きアクセサプロパティは、getアクセスとputアクセスの両方において継承されます。</p>
    <p>　各ECMAScriptオブジェクトは、オブジェクトに追加される場合がある名前付きプロパティか否かを操作するBoolean値である[[Extensible]]内部プロパティを持ちます。 もし、[[Extensible]]内部プロパティの値が、falseである場合には、オプションの名前付きプロパティは、当該オブジェクトに追加されない場合があります。 追記すると、もし、[[Extensible]]が、falseである場合には、当該オブジェクトの[[Class]]と[[Prototype]]内部プロパティの値が、修正されない場合があります。 一度[[Extensible]]内部プロパティの値が、falseに設定されたらtrueに変更されることはないかもしれません。</p>
    <p>[注釈]</p>
    <p>　この仕様が定義するオブジェクトの[[Class]]や[[Prototype]]内部プロパティを修正する為のプログラムや、[[Extensible]]の値をfalseからtrueに変更する為のプログラムを許可するECMAScript言語の演算子や組み込み関数は、一切ありません。 [[Class]]、[[Prototype]]、[[Extensible]]を修正する実装仕様拡張は、先行する段落内に定義した不変条件に反してはいけません。</p>
    <p>　[[Class]]内部プロパティの値は、組み込みオブジェクトの種類ごとにこの仕様によって定義されます。 ホストオブジェクトの[[Class]]内部プロパティの値は、</p>
<pre><code>Arguments
    Array
    Boolean
    Date
    Error
    Function
    JSON
    Math
    Number
    Object
    RegExp
    String
</code></pre><p>であるものを除く一部の文字列値になる場合があります。 [[Class]]内部プロパティの値は、異なるオブジェクトの種類を識別する為に内部的に使用されます。</p>
    <p>　注釈としては、この仕様は、 Object.prototype.toString ( 15.2.4.2 参照)を通す場合を除いて値にアクセスする為のプログラムにとって意味あるものは何も提供しません。</p>
    <p>　特記のない限り、ネイティブなECMAScriptオブジェクトの一般的な内部メソッドは、8.12 で説明したように振る舞います。 Array(配列)オブジェクトは、[[DefineOwnProperty]]内部メソッド( 15.4.5.1 参照)の実装と多少異なっており、Stringオブジェクトは、[[GetOwnProperty]]内部メソッド( 15.5.5.2参照)の実装と多少異なっています。 Argumentsオブジェクト(10.6)は、[[Get]]、[[GetOwnProperty]]、[[DefineOwnProperty]]、[[Delete]]の異なる実装を持ちます。 Functionオブジェクト(15.3)は、[[Get]]の実装と異なります。</p>
    <p>　ホストオブジェクトは、他に特段の記述がない限り、任意の方法でこれら内部メソッドを実装する場合があります。 例えば、一つの可能性としては、特定のホストオブジェクトにおける[[Get]]と[[Put]]は、まさにフェッチをし、常にfalseを生成する[[HasProperty]]ではなく、(その都度)プロパティ値を保存します。 しかしながら、ホストオブジェクトの内部プロパティの操作を記述した場合には、実装によってサポートされず、操作は、試行した際にTypeErrorを投げなければいけません。</p>
    <p>　ホストオブジェクトの[[GetOwnProperty]]内部メソッドは、ホストオブジェクトのプロパティごとに続く不変式と一致しなければいけません。</p>
    <ul>
        <li>もし、プロパティが、データプロパティとして説明され、回を重ねるごとに異なる値を返す場合には、他の内部メソッド経由で現れた値を変更する為の仕組みがない場合でさえ[[Writable]]と[[Configurable]]属性の一方または両方をtrueにしなければいけません。</li>
        <li>もし、プロパティが、データプロパティとして説明され、その[[Writable]]と[[Configurable]]が両方ともfalseである場合には、（ 9.12 と一致する）SameValue (同じ値)は、[[GetOwnProperty]]を呼ぶ全ての場合に当該プロパティの[[Value]]属性の為に返されなければいけません。</li>
        <li>もし、[[Writable]]ではない属性が、毎回変更する場合や当該プロパティが現れない場合には、[[Configurable]]属性は、trueにしなければいけません。</li>
        <li>もし、[[Writable]]属性が、falseからtrueに変更する場合には、[[Configurable]]属性は、trueにしなければいけません。</li>
        <li>もし、ホストオブジェクトの[[Extensible]]内部プロパティの値が、ECMAScriptコードによってfalseになるように監視している場合には、何も存在しない(non-existent)ものとしてプロパティを説明する[[GetOwnProperty]]を呼ぶ場合、全ての順次呼び出しもまた何も存在しない(non-existent)ようにプロパティを記述しなければいけません。</li>
    </ul>
    <p>　ホストオブジェクトの[[DefineOwnProperty]]内部メソッドは、もし、そのホストオブジェクトの[[Extensible]]内部プロパティが、falseになるようにECMAScriptコードによって監視されている場合には、ホストオブジェクトに新しいプロパティを追加することを許可してはいけません。</p>
    <p>　もし、そのホストオブジェクトの[[Extensible]]内部プロパティが、falseになるようにECMAScriptコードによって監視されている場合には、その後trueにしていはいけません。</p>
<pre><code>Table 9 一部のオブジェクト定義用の内部プロパティ
    ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    内部プロパティ         値型領域                        説明
    ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    [[PrimitiveValue]]      primitive                       当該オブジェクトに紐づく内部状態情報。
    標準組み込みECMAScriptオブジェクトとしてBoolean、Date、Number、String オブジェクトだけが[[PrimitiveValue]]を実装。
    [[Construct]]           SpecOp(a List of any) → Object              オブジェクトを生成。
    新しい演算子経由で実行。
    SpecOpへの引数は、新しい演算子の為に渡した引数。
    オブジェクトはコンストラクタと呼ばれる当該内部メソッドを実装。
    [[Call]]            SpecOp(any, a List of any) → any or Reference       当該オブジェクトと紐づく実行コード。
    関数呼び出し式(ファンクションコール)経由で実行。
    SpecOpへの引数は、当該オブジェクトと関数呼び出し式の為に渡した引数を含むリスト。
    当該内部メソッドを実装するオブジェクトは呼び出し可能。
    ホストオブジェクトであるオブジェクトに限っては参照値を返す場合がある。
    [[HasInstance]]         SpecOp(any) → Boolean                   this オブジェクトによって構築されたObjectであるかのような引数か否かを示すBoolean値を返す。
    標準組み込みECMAScriptオブジェクトとしてFunctionオブジェクトのみ[[HasInstance]]を実装。
    [[Scope]]           Lexical Environment                 Functionオブジェクト内で環境を定義する語彙的な環境が実行される。
    標準組み込みECMAScriptオブジェクトとしてFunctionオブジェクトのみ[[Scope]]を実装。
    [[FormalParameters]]        List of Strings                     Functionの正規のパラメータリスト(FormalParameterList)であると識別する文字列を含む空の可能性もあるリスト。
    標準組み込みECMAScriptオブジェクトとしてFunctionオブジェクトのみ[[FormalParameterList]]を実装。
    [[Code]]            ECMAScript code                     関数のECMAScriptコード。
    標準組み込みECMAScriptオブジェクトとして唯一Functionオブジェクトのみ[[Code]]を実装。
    [[TargetFunction]]      Object                          標準組み込みFunction.prototype.bindメソッドを利用することによって生成した関数オブジェクトとしての対象関数。
    Function.prototype.bindを使用して生成したECMAScriptオブジェクトに限っては、[[TargetFunction]]内部プロパティを持つ。
    [[BoundThis]]           any                         標準組み込みFunction.prototype.bindメソッドを使って生成した関数オブジェクトの当該値を事前に関連付け(バインド)。
    Function.prototype.bindを使用して生成したECMAScriptオブジェクトに限っては、[[BoundThis]]内部プロパティを持つ。
    [[BoundArguments]]      List of any                     標準組み込みFunction.prototype.bindメソッドを使って生成した関数オブジェクトの引数の値を事前に関連付け(バインド)。
    Function.prototype.bindを使用して生成したECMAScriptオブジェクトに限っては、[[BoundArguments]]内部プロパティを持つ。
    [[Match]]           SpecOp(String, index) → MatchResult         正規表現マッチについてテストし、MatchResult値( 15.10.2.1 参照)を返す。
    標準組み込みECMAScriptオブジェクトとしてRegExpオブジェクトのみ[[Match]]を実装。
    [[ParameterMap]]        Object                          引数オブジェクト( 10.6 参照)のプロパティと関連付けした関数の正規のパラメータ間におけるマッピングを提供。
    引数オブジェクトであるECMAScriptオブジェクトのみ[[ParameterMap]]内部プロパティを持つ。
    ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
</code></pre><h2 id="8-7-the-reference-specification-type-standard-ecma-262-5-1-edition">8.7 リファレンス仕様型 / The Reference Specification Type / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="8-">8 タイプ・型</h3>
    <h3 id="8-7-">8.7 リファレンス仕様型(仕様書説明上の型)</h3>
    <p>　リファレンス(参照)の型は、delete、typeof、代入(assignment)演算子( = , op= )のような演算子としての振る舞いを説明する為に使用されます。 例えば、assignmentの左辺のオペランドは、リファレンスを生成することが期待されます。 assignmentの動作は、代わりにassignment演算子の左辺のオペランドを構成する構文上の書式におけるケース解析という目的において全て説明されますが、ただ1つだけ困難なのは、関数呼び出しが、リファレンスを返す為に実行されることです。 この可能性は、単にホストオブジェクトの為に認められています。 リファレンスを返す当該仕様によって定義した非組み込みECMAScript関数とリファレンスを返す為のユーザー定義関数についての規定はありません。 (長くて不恰好である構文上のケース解析を利用しない他の理由としては、当該仕様の多くの部分に影響を与えるからです。)</p>
    <p>　リファレンスは名称の関連付けにより解決されます。 リファレンスは、 base (基準)値、リファレンス名、Boolean値である strict reference (厳格リファレンス)フラグという3つのコンポーネントから構成されます。 基準値は、undefined、Object、Boolean、String、Numberか、または環境レコード(environment record ( 10.2.1 ) )の何れかです。 undefined(未定義)という基準値は、関連付けを解決されることができないリファレンスを示します。 リファレンス名は、文字列です。</p>
    <p>　次の抽象操作は、リファレンスを構成するコンポーネントにアクセスする為に当該仕様内で使用されます。</p>
    <ul>
        <li>GetBase(V)：リファレンス V の基準値のコンポーネントを返す</li>
        <li>GetReferencedName(V)：リファレンス V を参照した名称コンポーネントを返す</li>
        <li>IsStrictReference(V)：リファレンス V を参照したstrict参照コンポーネントを返す</li>
        <li>HasPrimitiveBase(V)：基準値がBoolean、String、またはNumberである場合、trueを返す</li>
        <li>IsPropertyReference(V)：基準値がオブジェクトまたはHasPrimitiveBase(V)がtrueの何れかの場合、trueを返し、そうでなければfalseを返す</li>
        <li>IsUnresolvableReference(V)：基準値がundefinedとfalse以外であればtrueを返す</li>
    </ul>
    <p>　次の抽象操作は、リファレンスにおける操作について当該仕様内で使用されます。</p>
    <h3 id="8-7-1-getvalue-v-">8.7.1 GetValue (V)</h3>
<pre><code>1. Type(V)がReferenceでない場合に V を返す
    2. base は、GetBase(V)を呼んだ結果とする
    3. IsUnresolvableReference(V)が真である場合、ReferenceError (参照エラー)例外を投げる(スローする)
    4. IsPropertyReference(V)が真である場合、
    a.  HasPrimitiveBase(V)が、false である場合、get は、 base の内部メソッド[[Get]]とし、それ以外の場合、get は、以下に定義した特殊な[[Get]]内部メソッドとする
    b. その this 値として base を使用、引数にGetReferencedName(V)を渡すことによって内部メソッド get を呼んだ結果を返す
    5.その他の場合には、 base は環境レコード(environment record)にしなければならない。
    a. 引数としてGetReferencedName(V) と IsStrictReference(V)を渡して base の具体的なメソッドである GetBindingValue ( 10.2.1 参照)を呼んだ結果を返す。
</code></pre><p>　次の[[Get]]内部メソッドは、 V がプリミティブ(原始的)な基準値を伴うプロパティ参照である場合にGetValueによって使用されます。 その引数としてプロパティPを伴う、その this 値としての base を使用することで呼ばれます。 次のステップが取られます。</p>
<pre><code>1. O は、ToObject(base)とする
    2. desc は、プロパティ名 P を伴う O の内部メソッド[[GetProperty]]を呼んだ結果とする
    3. desc が、undefined(未定義)である場合、undefinedを返す
    4. IsDataDescriptor(desc) が、trueである場合、desc.[[Value]]を返す。
    5. それ以外の場合、IsAccessorDescriptor(desc) は、trueにしなければならない為、getter(取得メソッド)は、desc.[[Get]] とする( 8.10 参照)
    6. getter が、undefined(未定義)である場合、undefinedを返す
    7. this 値として base を提供し、提供する引数が何もない getter の[[Call]]内部メソッドを呼んだ結果を返す
</code></pre><p>[注釈]</p>
    <p>　ステップ1で生成される可能性のあるオブジェクトは、上記メソッドの外からアクセスすることはできません。 実装は、当該オブジェクトの実際の生成を回避する選択をする場合もあります。 視覚的な効果を与えることが可能なこの内部メソッドを使う実際のプロパティアクセスのような限定的な状況というのは、アクセサ関数を呼び出す時です。</p>
    <h3 id="8-7-2-putvalue-v-w-">8.7.2 PutValue (V, W)</h3>
<pre><code>1. Type(V)がReferenceでない場合、ReferenceError(参照エラー)例外を投げる(スローする)
    2. base は、GetBase(V)を呼んだ結果とする
    3. IsUnresolvableReference(V)が真である場合、
    a. IsStrictReference(V) が true である場合
    i. ReferenceError(参照エラー)例外を投げる(スローする)
    b. プロパティ名として GetReferencedName(V) 、値として W 、Throwフラグとして false を渡すことによってグローバルオブジェクトとして[[Put]]内部メソッドを呼ぶ
    4. IsPropertyReference(V)が真である場合、
    a. HasPrimitiveBase(V)が、falseである場合、put は、base の内部メソッド[[Put]]とし、それ以外の場合、put は、以下に定義した特殊な内部メソッド[[Put]]とする
    b. その this 値 として base を使用し、プロパティ名としてGetReferencedName(V)、値として W 、Throwフラグとして IsStrictReference(V)を渡すことによって内部メソッド put を呼ぶ
    5. 何れでもない場合には、base は、基準が環境レコード(environment record)であるリファレンスにしなければならない為、
    a. GetReferencedName(V)、(値は) W 、引数としてIsStrictReference(V)を渡すことによって base の具体的なメソッドであるSetMutableBinding( 10.2.1 )を呼ぶ
    6. Return
</code></pre><p>　次の[[Put]]内部メソッドは、V が、プリミティブ(原始的)な基準値を伴うプロパティのリファレンスである場合にPutValueによって使用されます。 引数としてプロパティ P、値 W 、Booleanフラグ Throw を伴う、その this 値としての base を使って呼ばれます。 次のステップが取られます。</p>
<pre><code>1. O は、ToObject(base)とする
    2. 引数 P を伴う O の内部メソッド[[CanPut]]を呼んだ結果が、false である場合、
    a. Throwが、trueである場合、TypeError例外を投げる(スローする)
    b. それ以外の場合、return
    3. ownDescは、引数 P を伴う O の内部メソッド[[GetOwnProperty]]を呼んだ結果とする
    4. IsDataDescriptor(ownDesc)が、trueである場合、
    a. Throwが、trueである場合、TypeError例外を投げる(スローする)
    b. それ以外の場合、return
    5. descは、引数 P を伴う O の内部メソッド[[GetOwnProperty]]を呼んだ結果とする。これは、それ自身、継承したアクセサプロパティ、または、継承したデータプロパティ記述子の何れかとなる場合があります。
    6. IsAccessorDescriptor(desc)が、trueである場合、
    a. setter(設定メソッド)は、undefinedにすることができないdesc.[[Set]] ( 8.10 参照) とする
    b.  this 値として base と W のみを含んだ引数リストを提供する setter の内部メソッド[[Call]]を呼ぶ
    7. それ以外の場合、一時的なオブジェクト O について自身のプロパティを生成する為に要求される
    a. Throwが、trueである場合、TypeError例外を投げる(スローする)
    8. Return
</code></pre><p>[注釈]</p>
    <p>　ステップ1で生成される場合があるオブジェクトは、上記メソッドの外からアクセスすることはできません。 実装は、一時的なオブジェクトとしての実際の生成を回避する選択をする可能性があります。 視覚的な効果を与えることが可能なこの内部メソッドを使う実際のプロパティの関連付けのような限定的な状況というのは、アクセサ関数を呼び出す時か、または、任意のエラーチェックを含意した Throw の違反であるかの何れかです。 Throwがtrueである場合には、一時的なオブジェクトについて新たなプロパティを生成するであろういかなるプロパティの関連付けについてもエラーを投げ(スローし)ます。</p>
    <h2 id="8-8-list-the-list-specification-type-standard-ecma-262-5-1-edition">8.8 List仕様型 / The List Specification Type / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="8-">8 タイプ・型</h3>
    <h3 id="8-8-list-">8.8 List仕様型(仕様書説明上の型)</h3>
    <p>　List型は、新たな式の中、関数呼び出しの中、必要とされる値の単純なリストにおける他のアルゴリズム内にある引数リストの評価( 11.2.4 参照)を説明する為に使用されます。 List型の値は、単に値の序数並びです。 これらの並びは色々な長さになることがあります。</p>
    <h2 id="8-9-completion-the-completion-specification-type-standard-ecma-262-5-1-edition">8.9 Completion 仕様型 / The Completion Specification Type / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="8-">8 タイプ・型</h3>
    <h3 id="8-9-completion-">8.9 Completion 仕様型(仕様書説明上の型)</h3>
    <p>　Completion型は、制御における非ローカル転送を実行するステートメント／文(break、continue、return、throw)の動作を説明する為に使用されます。 Completion型の値は、書式(type、value、target)から成る3種類で、typeは、normal、break、continue、return、throwであり、valueは一部のECMAScript言語の値または、空(カラ)、targetは、ECMAScript識別子または、空(カラ)です。 もし、cv が完全な値である場合には、cv.type、cv.value、cv.targetは、その構成値を直接参照する為に使用される場合があります。 “abrupt completion”(中途完了)の目的は、normal でないtypeを伴う一部のcompletionを参照することです。</p>
    <h2 id="8-10-the-property-descriptor-and-property-identifier-specification-types-standard-ecma-262-5-1-edition">8.10 プロパティ記述子仕様型とプロパティ識別子仕様型 / The Property Descriptor and Property Identifier Specification Types / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="8-">8 タイプ・型</h3>
    <h3 id="8-10-property-descriptor-property-identifier-">8.10 Property Descriptor と Property Identifier仕様型(仕様書説明上の型)</h3>
    <p>　Property Descriptor(プロパティ記述子)の型は、名前付きプロパティ属性の操作と具体化を説明する為に使用されます。 Property Descriptor(プロパティ記述子)の型の値は、8.6.1 で記述したように各項目名が属性名である名前付き項目とそれと一致する属性値である当該値から成る複雑なレコードです。 追記すると一部の項目は、存在したり、しなかったりする場合があります。</p>
    <p>　Property Descriptor(プロパティ記述子)の値は、存在や厳密な項目の利用に基づくデータプロパティ記述子とアクセサプロパティ記述子として更に分類される場合もあります。 データプロパティ記述子は、[[Value]] や [[Writable]] 何れかの名称の任意の項目を含むものです。 アクセサプロパティ記述子は、[[Get]] や [[Set]] の何れかの名称の任意の項目を含むものです。 任意のプロパティ記述子は、[[Enumerable]] と [[Configurable]]という名称の項目を持ちます。 任意のプロパティ記述子の値は、データプロパティ記述子、アクセサプロパティ記述子の何れにもしない場合もありますが、何れかにする場合もあります。 一般的なプロパティ記述子は、データプロパティ記述子、アクセサプロパティ記述子の何れでもないプロパティ記述子の値です。 全て実装したプロパティ記述子は、アクセサプロパティ記述子とデータプロパティ記述子の何れか一方と 8.6.1 の Table 5 や Table 6 の何れかで定義したプロパティ属性と一致する項目の全てを持ちます。</p>
    <p>　この仕様書内での表記上の利便性においてオブジェクトリテラル風の構文は、プロパティ記述子の値を定義する為に使用されることが可能です。 例えば、プロパティ記述子</p>
<pre><code>{[[Value]]: 42, [[Writable]]: false, [[Configurable]]: true}
</code></pre><p>は、データプロパティ記述子を定義します。 項目名の順序は重要です。 明示的に列挙されない一部の項目は、欠如したものと考慮されます。 仕様上のテキストとアルゴリズムにおいては、ドット記法は、プロパティ記述子を記述する項目を参照する為に使用される場合があります。 例えば、もし、D がプロパティ記述子であれば、D.[[Value]]は、Dと名づけられた[[Value]]という項目における略記です。</p>
    <p>　プロパティ識別子の型は、プロパティ記述子を伴うプロパティ名との関連付けの為に使用されます。 プロパティ識別子の型の値は、(name、descriptor)から成るペアで、nameは、文字列、descriptorは、プロパティ記述子の値です。</p>
    <p>　次の抽象操作(8.10.1～8.10.5)は、プロパティ記述子の値を操作する為に当該仕様内で使用されます。</p>
    <h3 id="8-10-1-isaccessordescriptor-desc-">8.10.1 IsAccessorDescriptor ( Desc )</h3>
    <p>　抽象操作IsAccessorDescriptorがプロパティ記述子Descを伴って呼ばれる場合には、次のような段階を踏みます。</p>
<pre><code>1.Descが未定義である場合、falseを返す
    2.Desc.[[Get]] と Desc.[[Set]] が何れも存在しない場合には、falseを返す
    3.trueを返す
</code></pre><h3 id="8-10-2-isdatadescriptor-desc-">8.10.2 IsDataDescriptor ( Desc )</h3>
    <p>　抽象操作IsDataDescriptorがプロパティ記述子Descを伴って呼ばれる場合には、次のような段階を踏みます。</p>
<pre><code>1.Descが未定義である場合、falseを返す
    2.Desc.[[Value]] と Desc.[[Writable]] が何れも存在しない場合には、falseを返す
    3.trueを返す
</code></pre><h3 id="8-10-3-isgenericdescriptor-desc-">8.10.3 IsGenericDescriptor ( Desc )</h3>
    <p>　抽象操作IsGenericDescriptorがプロパティ記述子Descを伴って呼ばれる場合には、次のような段階を踏みます。</p>
<pre><code>1.Descが未定義である場合、falseを返す
    2.IsAccessorDescriptor(Desc) と IsDataDescriptor(Desc) が何れもfalseである場合には、trueを返す
    3.trueを返す
</code></pre><h3 id="8-10-4-frompropertydescriptor-desc-">8.10.4 FromPropertyDescriptor ( Desc )</h3>
    <p>　抽象操作FromPropertyDescriptorがプロパティ記述子Descを伴って呼ばれる場合には、次のような段階を踏みます。</p>
<pre><code>1.Descが未定義である場合、undefinedを返す
    2.objは、その名を持つ標準組み込みコンストラクタであるObjectにおいて new Object() という式によるかのように生成した新たなオブジェクトを結果とする
    3.IsDataDescriptor(Desc)がtrueである場合、
    a.引数&quot;value&quot;、プロパティ記述子 {[[Value]]: Desc.[[Value]], [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}、 falseを伴うobjの[[DefineOwnProperty]]内部メソッドを呼ぶ
    b.引数&quot;writable&quot;、プロパティ記述子 {[[Value]]: Desc.[[Writable]], [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}、 falseを伴うobjの[[DefineOwnProperty]]内部メソッドを呼ぶ
    4.1～3の何れでもなければ、IsAccessorDescriptor(Desc)は、trueにしなければならず、よって
    a.引数&quot;get&quot;、プロパティ記述子 {[[Value]]: Desc.[[Get]], [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}、 falseを伴うobjの[[DefineOwnProperty]]内部メソッドを呼ぶ
    b.引数&quot;set&quot;、プロパティ記述子 {[[Value]]: Desc.[[Set]], [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}、 falseを伴うobjの[[DefineOwnProperty]]内部メソッドを呼ぶ
    5.引数&quot;enumerable&quot;、プロパティ記述子 {[[Value]]: Desc.[[Enumerable]], [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}、 falseを伴うobjの[[DefineOwnProperty]]内部メソッドを呼ぶ
    6.引数&quot;configurable&quot;、プロパティ記述子 {[[Value]]: Desc.[[Configurable]], [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}、 falseを伴うobjの[[DefineOwnProperty]]内部メソッドを呼ぶ
    7.objを返す
</code></pre><h3 id="8-10-5-topropertydescriptor-obj-">8.10.5 ToPropertyDescriptor ( Obj )</h3>
    <p>　抽象操作ToPropertyDescriptorがオブジェクトObjを伴って呼ばれる場合には、次のような段階を踏みます。</p>
<pre><code>1. Type(Obj) がObjectでなければ、TypeError例外を投げる(スローする)
    2. desc は、生成する初期の項目を何も持たない新しいプロパティ記述子を結果とする
    3.引数&quot;enumerable&quot;を持つObjの[[HasProperty]]内部メソッドを呼んだ結果がtrueである場合、
    a.enumは、引数&quot;enumerable&quot;を持つObjの[[Get]]内部メソッドを呼び、それを結果とする
    b.ToBoolean(enum)に desc の[[Enumerable]]項目を設定
    4.引数&quot;configurable&quot;を持つObjの [[HasProperty]]内部メソッドを呼んだ結果がtrueである場合、
    a.confは、引数&quot;configurable&quot;を持つObjの[[Get]]内部メソッドを呼び、それを結果とする
    b.ToBoolean(conf)に desc の[[Configurable]]項目を設定
    5.引数&quot;value&quot;を持つObjの[[HasProperty]]内部メソッドを呼んだ結果がtrueである場合、
    a.valueは、引数&quot;value&quot;を持つObjの[[Get]]内部メソッドを呼び、それを結果とする
    b.値に desc の[[Value]]項目を設定
    6.引数&quot;writable&quot;を持つObjの[[HasProperty]]内部メソッドを呼んだ結果がtrueである場合、
    a.writableは、引数&quot;writable&quot;を持つObjの[[Get]]内部メソッドを呼び、それを結果とする
    b. desc の[[Writable]]項目にToBoolean(writable)を設定
    7.引数&quot;get&quot;を持つObjの[[HasProperty]]内部メソッドを呼んだ結果がtrueである場合、
    a.getterは、引数&quot;get&quot;を持つObjの[[Get]]内部メソッドを呼び、それを結果とする
    b.IsCallable(getter)がfalseでgetterがundefinedではない場合、TypeError例外を投げる(スローする)
    c. desc の[[Get]]項目にgetterを設定
    8.引数&quot;set&quot;を持つObjの[[HasProperty]]内部メソッドを呼んだ結果がtrueである場合、
    a.setterは、引数&quot;set&quot;を持つObjの[[Get]]内部メソッドを呼び、それを結果とする
    b.IsCallable(setter)がfalseでsetterがundefinedではない場合、TypeError例外を投げる(スローする)
    c.desc の[[Set]]項目にsetterを設定
    9.desc.[[Get]] や desc.[[Set]]が、何れも存在する場合、
    a.desc.[[Value]] や desc.[[Writable]]が共に存在する場合には、TypeError例外を投げる(スローする)
    10.descを返す
</code></pre><h2 id="lexical-environment-environment-record-the-lexical-environment-and-environment-record-specification-types-standard-ecma-262-5-1-edition">Lexical Environment と Environment Record 仕様型 / The Lexical Environment and Environment Record Specification Types / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="8-">8 タイプ・型</h3>
    <h3 id="8-11-lexical-environment-environment-record-">8.11 Lexical Environment と Environment Record 仕様型(仕様書説明上の型)</h3>
    <p>　Lexical Environment(語彙的環境)とEnvironment Record(環境レコード)仕様型は、ネストする関数とブロック内で名称解決の動作を説明する為に使用されます。 これらの種類と操作は、第10項で定義される内容に基づきます。</p>
    <h2 id="8-12-algorithms-for-object-internal-methods-standard-ecma-262-5-1-edition">8.12 オブジェクトの内部メソッドにおけるアルゴリズム / Algorithms for Object Internal Methods / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="8-">8 タイプ・型</h3>
    <h3 id="8-12-">8.12 オブジェクトの内部メソッドにおけるアルゴリズム</h3>
    <p>　次のアルゴリズム説明では、assume O はネイティブなECMAScriptオブジェクト、P はString、Desc はプロパティ記述子レコード、Throw は、Booleanフラグです。</p>
    <h3 id="8-12-1-getownproperty-p-">8.12.1 [[GetOwnProperty]] (P)</h3>
    <p>　O の[[GetOwnProperty]]内部メソッドが、プロパティ名 P として呼ばれる場合、次のような段階を踏みます。</p>
<pre><code>1. O が名称 P を持つプロパティそれ自身を持たない場合、undefined(未定義)を返す
    2. D は、何も項目を持たないプロパティ記述子を新たに生成させる
    3. X は、O 自身の名称 P というプロパティにする
    4. X が、データプロパティである場合、
    a. X の[[Value]]属性の値に D.[[Value]] を設定
    b. X の[[Writable]]属性の値に D.[[Writable]] を設定
    5.それ以外の場合、 X はアクセサプロパティなので
    a. X の[[Get]]属性の値に D.[[Get]] を設定
    b. X の[[Set]]属性の値に D.[[Set]] を設定
    6. X の[[Enumerable]]属性の値に D.[[Enumerable]] を設定
    7. X の[[Configurable]]属性の値に D.[[Configurable]] を設定
    8. D を返す
</code></pre><p>　しかしながら、もし、 O がStringオブジェクトである場合、それは、15.5.5.2 で定義した、より精巧な[[GetOwnProperty]]内部メソッドを持ちます。</p>
    <h3 id="8-12-2-getproperty-p-">8.12.2 [[GetProperty]] (P)</h3>
    <p>　O の[[GetProperty]]内部メソッドが、プロパティ名 P として呼ばれる場合、次のような段階を踏みます。</p>
<pre><code>1.prop は、プロパティ名が P である O の[[GetOwnProperty]]内部メソッドを呼び、それを結果とする
    2.prop が、undefined(未定義)でない場合には、prop を返す
    3.proto は、O の[[Prototype]]内部メソッドの値とする
    4.proto が nullであれば、undefinedを返す
    5.引数 P を持つ proto の[[GetProperty]]内部メソッドを呼んだ結果を返す
</code></pre><h3 id="8-12-3-get-p-">8.12.3 [[Get]] (P)</h3>
    <p>　O の[[Get]]内部メソッドが、プロパティ名 P として呼ばれる場合、次のような段階を踏みます。</p>
<pre><code>1.desc は、プロパティ名 P である O の[[GetProperty]]内部メソッドを呼び、それを結果とする
    2.desc が、undefined(未定義)であれば、undefinedを返す
    3.IsDataDescriptor(desc)が、trueであれば、desc.[[Value]]を返す
    4.それ以外の場合には、IsAccessorDescriptor(desc)はtrueにしなければならない為、getterは、desc.[[Get]]とする
    5.getterが、undefined(未定義)であれば、undefinedを返す
    6. this 値及び引数なしであるものとして O を提供する getter の[[Call]]内部メソッドを呼んだ結果を返す
</code></pre><h3 id="8-12-4-canput-p-">8.12.4 [[CanPut]] (P)</h3>
    <p>　O の[[CanPut]]内部メソッドが、プロパティ名 P として呼ばれる場合、次のような段階を踏みます。</p>
<pre><code>1.desc は、引数 P を伴う O の[[GetOwnProperty]]内部メソッドを呼び、それを結果とする
    2.desc がundefined(未定義)でない場合には、
    a.IsAccessorDescriptor(desc)がtrueであれば
    i.desc.[[Set]]が、undefinedであれば、falseを返す
    ii.そうでなければtrueを返す
    b.それ(a.)以外の場合には、descは、DataDescriptor(データ記述子)にしなければならない為、desc.[[Writable]]という値を返す
    3.  proto は、O の[[Prototype]]内部メソッドとする
    4.  proto がnullである場合、O の [[Extensible]]内部プロパティの値を返す
    5. inherited は、プロパティ名 P であるprotoの[[Extensible]]内部メソッドを呼び、それを結果とする
    6. inherited が、undefinedであれば、O の [[Extensible]]内部プロパティの値を返す
    7.IsAccessorDescriptor(inherited) が、trueであれば、
    a.inherited.[[Set]]がundefinedであれば、falseを返す
    b.そうでなければtrueを返す
    8.それ以外の場合、inheritedは、DataDescriptor(データ記述子)にしなければならない
    a. O の[[Extensible]]内部プロパティがfalseであればfalseを返す
    b.そうではない場合、inherited.[[Writable]]の値を返す
</code></pre><p>　ホストオブジェクトは、[[Put]]演算子に基づく付加的な制約を定義する場合があります。 もし、可能であれば、ホストオブジェクトは、falseを返す[[CanPut]]の当該定義がある状況において[[Put]]演算子を許容すべきではありません。</p>
    <h3 id="8-12-5-put-p-v-throw-">8.12.5 [[Put]] ( P, V, Throw )</h3>
    <p>　O の[[Put]]内部メソッドが、プロパティ名 P 、 値 V 、 BooleanフラグがThrowとして呼ばれる場合、次のような段階を踏みます。</p>
<pre><code>1.プロパティ名 P である O の[[CanPut]]内部メソッドを呼んだ結果がfalseである場合、
    a.Throwがtrueであれば、TypeError例外を投げる(スローする)
    b.そうでなければ、単にreturn
    2.ownDescは、プロパティ名 P である O の[[GetOwnProperty]]内部メソッドを呼び、それを結果とする
    3.IsDataDescriptor(ownDesc) が trueであれば、
    a.valueDescは、プロパティ記述子 {[[Value]]: V} とする
    b.引数である P 、 valueDesc 、Throw を渡すことによって O の[[DefineOwnProperty]]内部メソッドを呼ぶ
    c.Return
    4.descは、引数 P を持つ O の[[GetProperty]]内部メソッドを呼び、それを結果とする。これは、それ自身または継承したアクセサプロパティ記述子や継承したデータプロパティ記述子の何れかになる場合がある。
    5.IsAccessorDescriptor(desc) が trueである場合、
    a. setter は、undefinedにすることができないdesc.[[Set]]とする
    b. this 値として O を提供し、唯一の引数として V を提供する setter の[[Call]]内部メソッドを呼ぶ
    6.何れでもない場合には、次のようなオブジェクト O について P と名付けられた名前付きデータプロパティを生成する
    a.newDescは、プロパティ記述子 {[[Value]]: V, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true} とする
    b.引数である P 、 newDesc 、Throw を渡すことによって O の[[DefineOwnProperty]]内部メソッドを呼ぶ
    7.Return
</code></pre><h3 id="8-12-6-hasproperty-p-">8.12.6 [[HasProperty]] (P)</h3>
    <p>　O の[[Put]]内部メソッドが、プロパティ名 P として呼ばれる場合、 O の [[HasProperty]]内部メソッドは、次のような段階を踏みます。</p>
<pre><code>1.descは、プロパティ名 P である O の[[GetProperty]]内部メソッドを呼び、それを結果とする
    2.descが、undefinedである場合、falseを返す
    3.そうでなければtrueを返す
</code></pre><h3 id="8-12-7-delete-p-throw-">8.12.7 [[Delete]] (P, Throw)</h3>
    <p>　O の[[Delete]]内部メソッドが、プロパティ名 P 、 BooleanフラグがThrowとして呼ばれる場合、次のような段階を踏みます。</p>
<pre><code>1.descは、プロパティ名 PであるO の[[GetOwnProperty]]内部メソッドを呼び、それを結果とする
    2.descが、undefinedである場合、trueを返す
    3.desc.[[Configurable]] が trueである場合、
    a. O から 名前 P を持つプロパティそれ自身を削除する
    b.trueを返す
    4.何れでもなくThrowが真である場合、TypeError例外を投げる(スローする)
    5.falseを返す
</code></pre><h3 id="8-12-8-defaultvalue-hint-">8.12.8 [[DefaultValue]] (hint)</h3>
    <p>　O の[[DefaultValue]]内部メソッドが、hint という文字列を伴って呼ばれる場合には、次のような段階を踏みます。</p>
<pre><code>1.toStringは、引数&quot;toString&quot;を伴う オブジェクト O の[[Get]]内部メソッドを呼び、それを結果とする
    2.IsCallable(toString) が trueである場合、
    a.str は、この値とカラの引数リストとして O を伴う toStringの[[Call]]内部メソッドを呼び、それを結果とする
    b.str がプリミティブ(原始的な)値である場合、strを返す
    3.valueOfは、引数&quot;valueOf&quot;を持つオブジェクト O の[[Get]]内部メソッドを呼び、それを結果とする
    4.IsCallable(valueOf) が true である場合、
    a.val は、この値とカラの引数リストとして O を持つvalueOfの[[Call]]内部メソッドを呼び、それを結果とする
    b.val が、プリミティブ(原始的な)値である場合、valを返す
    5.TypeError例外を投げる(スローする)
</code></pre><p>　O の[[DefaultValue]]内部メソッドが、hint という数値を伴って呼ばれる場合には、次のような段階を踏みます。</p>
<pre><code>1.valueOfは、引数&quot;valueOf&quot;を持つオブジェクト O の[[Get]]内部メソッドを呼び、それを結果とする
    2.IsCallable(valueOf) が trueである場合、
    a.val は、この値とカラの引数リストとして O を持つvalueOfの[[Call]]内部メソッドを呼び、それを結果とする
    b.val が、プリミティブ(原始的な)値である場合、valを返す
    3.toStringは、引数&quot;toString&quot;を伴うオブジェクト O の[[Get]]内部メソッドを呼び、それを結果とする
    4.IsCallable(toString) が trueである場合、
    a.str は、この値とカラの引数リストとして O を持つtoStringの[[Call]]内部メソッドを呼び、それを結果とする
    b.str が、プリミティブ(原始的な)値である場合、valを返す
    5.TypeError例外を投げる(スローする)
</code></pre><p>　O の[[DefaultValue]]内部メソッドが、hint を持たずに呼ばれる場合、O が Dateオブジェクト( 15.9.6 参照)でない限り、hintが文字列であったかのように振る舞うケースについても hint が、数値であったものとして振る舞います。 ネイティブなオブジェクトにおける[[DefaultValue]]の上記仕様は、プリミティブ(原始的な)値だけを返すことが可能です。 もし、ホストオブジェクトが、それ自身の[[DefaultValue]]内部メソッドを実装する場合、それは、その[[DefaultValue]]内部メソッドがプリミティブ(原始的な)値だけを返すことができることを保証しなければいけません。</p>
    <h3 id="8-12-9-defineownproperty-p-desc-throw-">8.12.9 [[DefineOwnProperty]] (P, Desc, Throw)</h3>
    <p>　次のアルゴリズムにある用語“Reject”は、</p>
    <p>「もし、Throwがtrueである場合、TypeError例外を投げ、そうでなければ、falseを返す」</p>
    <p>という意味です。 そのアルゴリズムは、様々な仕様値におけるProperty Descriptor(プロパティ記述子) Desc という項目をテストするステップを含みます。 このマナーの中でテストされる項目は、実際にDesc内に存在する必要はありません。 もし、項目がない場合には、その値は、falseであるものとして考慮されます。</p>
    <p>　O の[[DefineOwnProperty]]内部メソッドが、プロパティ名 P 、プロパティ記述子 Desc、Booleanフラグ Throwとして呼ばれる場合、次のような段階を踏みます。</p>
<pre><code>1.current は、プロパティ名 Pである O の[[GetOwnProperty]]内部メソッドを呼び、それを結果とする
    2.extensible は、O の[[Extensible]]内部プロパティの値とする
    3.current がundefinedで且つ、extensibleがfalseである場合、Reject
    4.current がundefinedで且つ、extensibleがtrueである場合、
    a.IsGenericDescriptor(Desc) や IsDataDescriptor(Desc) が trueである場合、
    i. Desc によって説明される[[Value]]、[[Writable]]、[[Enumerable]]、[[Configurable]]属性値を持つオブジェクト O の P というデータプロパティ自身を生成。もし、Descの属性項目の値が存在しない場合には、新たに生成したプロパティの属性がデフォルト(既定)値としてセットされる
    b.それ以外の場合、Descは、accessor Property Descriptor(アクセサプロパティ記述子)にしなければいけないので
    i. Desc によって説明される[[Get]], [[Set]], [[Enumerable]] and [[Configurable]]属性値を持つオブジェクト O という P というアクセサプロパティ自身を生成。もし、Descの属性項目の値が存在しない場合には、新たに生成したプロパティの属性が、そのデフォルト(既定)値としてセットされる
    c.trueを返す
    5.Desc内の全ての項目がカラである場合、trueを返す
    6.Descにある全ての項目が、SameValue アルゴリズム (9.12)を使って比較した場合にcurrentに現れたり、currentにある項目とDescにある各項目の値が一致した同じ値である場合には、trueを返す
    7.currentの[[Configurable]]項目がfalseである場合、
    a.Descの[[Configurable]]項目がtrueである場合、Reject
    b.Descの[[Enumerable]]項目が存在し、currentの[[Enumerable]]項目とDescが相互に否定するBoolean型である場合、Reject
    8.IsGenericDescriptor(Desc) が trueである場合、それ以上の妥当性検証は要求されることはない
    9.それ以外の場合、IsDataDescriptor(current) と IsDataDescriptor(Desc)が異なる結果を持つ場合、
    a.currentの[[Configurable]]項目がfalseである場合、Reject
    b.IsDataDescriptor(current) が trueである場合、
    i.データプロパティからアクセサプロパティにオブジェクト O の P というプロパティを変換。変換したプロパティの[[Configurable]] と [[Enumerable]]属性に存在する値を保存し、残りのプロパティの属性には、それらの既定値を設定
    c.それ以外の場合、
    i.アクセサプロパティからデータプロパティにオブジェクト O の P というプロパティを変換。変換したプロパティの[[Configurable]] と [[Enumerable]]属性に存在する値を保存し、残りのプロパティの属性には、それらの既定値を設定
    10.それ以外の場合でIsDataDescriptor(current) と IsDataDescriptor(Desc) が共に trueである場合、
    a.currentの[[Configurable]]項目がfalseである場合、
    i.currentの[[Writable]]項目がfalseで且つ、Descの[[Writable]]項目がtrueである場合、Reject
    ii.currentの[[Writable]]項目がfalseである場合、
    1.Descの[[Value]]項目がpresentで且つ、SameValue(Desc.[[Value]], current.[[Value]]) が falseである場合、Reject
    b.それ以外の場合、currentの[[Configurable]]項目がtrueになるので一部変更が可能となる
    11.それ以外の場合、IsAccessorDescriptor(current) と IsAccessorDescriptor(Desc) が共に true となるので
    a.currentの[[Configurable]]項目がfalseである場合、
    i.Descの[[Set]]項目が存在し、SameValue(Desc.[[Set]]、current.[[Set]]) が falseである場合、Reject
    ii.Desc が presentである[[Get]]項目とSameValue(Desc.[[Get]]、 current.[[Get]])がfalseである場合、Reject
    12.Desc が presentである各属性項目について、それに応じた項目の値にオブジェクト O の P というプロパティの名前付き属性を設定
    13.trueを返す
</code></pre><p>　しかしながら、もし、 O がArrayオブジェクトである場合には、15.4.5.1 で定義した、より精巧な[[DefineOwnProperty]]内部メソッドを持ちます。</p>
    <p>[注釈]</p>
    <p>　ステップ(段階) 10.b は、currentの[[Configurable]]項目がtrueである場合、currentの一致する項目とは異なるものである一部のDescの項目を許容します。 これは、[[Writable]]属性がfalseであるプロパティの[[Value]]の変更さえも可能にします。 これは、trueである[[Configurable]]属性が、[[Writable]]が、初めにtrueに設定され、新たに[[Value]]が設定される際に[[Writable]]がfalseに設定される場合に呼んだシーケンスと同等であることを許可する為、許容されます。</p>
    <h2 id="9-type-conversion-and-testing-standard-ecma-262-5-1-edition">9 型変換とテスト / Type Conversion and Testing / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="9-">9 型変換とテスト</h3>
    <p>　ECMAScriptランタイムシステムは必要都度、自動的に型変換を実行します。 特定の構造を明確にするセマンティクスは、変換抽象操作の設定を定義するのに便利です。 これら抽象操作は、言語の一部ではありません。 それらは、言語のセマンティクスの仕様を補完する為にここで定義されます。 変換抽象操作は、ポリモーフィック(多様／多形／多型)的な部分があります。 つまり、仕様の型だけではなく、何らかのECMAScript言語の型の値をも許容することができるということです。</p>
    <h3 id="9-1-toprimitive">9.1 ToPrimitive</h3>
    <p>　抽象操作ToPrimitiveは、引数と付加的な引数PreferredTypeをその入力として取ります。 抽象操作ToPrimitiveは、その入力される引数を非Object型に変換します。 もし、オブジェクトが1つ以上の原始的(プリミティブ)な型に変換することができる場合には、それは、その型を補完する付加的なヒント PreferredType を使用する場合があります。 変換は、Table 10によって発生します。</p>
<pre><code>Table 10 -- ToPrimitive変換
    ---------------------------------------------------------------------------------------------------------------------------------------------------------
    入力タイプ   結果
    ---------------------------------------------------------------------------------------------------------------------------------------------------------
    Undefined   結果は入力となる引数と同等(変換なし)
    Null        結果は入力となる引数と同等(変換なし)
    Boolean     結果は入力となる引数と同等(変換なし)
    Number      結果は入力となる引数と同等(変換なし)
    String      結果は入力となる引数と同等(変換なし)
    Object      Objectにおける既定値を返す
    オブジェクトの既定値は、付加的なヒントであるPreferredTypeを渡して当該オブジェクトの[[DefaultValue]]内部プロパティを呼ぶことによって取得
    [[DefaultValue]]内部プロパティの動作については、8.12.8.で全てのネイティブECMAScriptオブジェクトについてこの仕様によって定義される
    ---------------------------------------------------------------------------------------------------------------------------------------------------------
</code></pre><h3 id="9-2-toboolean">9.2 ToBoolean</h3>
    <p>　抽象操作ToBooleanは、Table 11 によって、その引数をBoolean型の値に変換します。</p>
<pre><code>Table 11 -- ToBoolean変換
    ------------------------------------------------------------------------------------------------------
    引数の型    結果
    ------------------------------------------------------------------------------------------------------
    Undefined   false
    Null        false
    Boolean     結果は入力となる引数と同等(変換なし)
    Number      引数が+0、-0、NaN (Not a Number)の場合、false、それ以外の場合、その結果はtrue
    String      引数が(その長さがゼロの)カラの文字列である場合、false、それ以外の場合、その結果はtrue
    Object      true
    ------------------------------------------------------------------------------------------------------
</code></pre><h3 id="9-3-tonumber">9.3 ToNumber</h3>
    <p>　抽象操作ToNumberは、Table 12 によって、その引数をNumber型の値に変換します。</p>
<pre><code>Table 12 ToNumber変換
    --------------------------------------------------------------------------------
    引数の型    結果
    --------------------------------------------------------------------------------
    Undefined   NaN (Not a Number)
    Null        +0
    Boolean     引数がtrueの場合、結果は1
    引数がfalseの場合、その結果は+0
    Number      結果は入力となる引数と同等(変換なし)
    String      文法と以降の注釈参照
    Object      次のステップで適用
    1. primValue は、ToPrimitive(input argument, hint Number) とする
    2. ToNumber(primValue)を返す
    --------------------------------------------------------------------------------
</code></pre><h3 id="9-3-1-string-tonumber">9.3.1 String型に適用される ToNumber</h3>
    <p>　文字列(Strings)に適用したToNumberは、String型をその入力とする為に次の文法を適用します。 文法が、StringNumericLiteralの拡張としてString型を解釈できない場合には、ToNumberの結果は、NaNになります。</p>
<pre><code>【構文】

    StringNumericLiteral :::
    StrWhiteSpaceopt
    StrWhiteSpaceopt StrNumericLiteral StrWhiteSpaceopt

    StrWhiteSpace :::
    StrWhiteSpaceChar StrWhiteSpaceopt

    StrWhiteSpaceChar :::
    WhiteSpace
    LineTerminator

    StrNumericLiteral :::
    StrDecimalLiteral
    HexIntegerLiteral

    StrDecimalLiteral :::
    StrUnsignedDecimalLiteral
    + StrUnsignedDecimalLiteral
    - StrUnsignedDecimalLiteral

    StrUnsignedDecimalLiteral :::
    Infinity
    DecimalDigits . DecimalDigitsopt ExponentPartopt
    . DecimalDigits ExponentPartopt
    DecimalDigits ExponentPartopt

    DecimalDigits :::
    DecimalDigit
    DecimalDigits DecimalDigit

    DecimalDigit ::: 0 1 2 3 4 5 6 7 8 9 の何れか1つ

    ExponentPart :::
    ExponentIndicator SignedInteger

    ExponentIndicator :::
    e E
    の何れか

    SignedInteger :::
    DecimalDigits
    + DecimalDigits
    - DecimalDigits

    HexIntegerLiteral :::
    0x HexDigit
    0X HexDigit
    HexIntegerLiteral HexDigit

    HexDigit ::: 0 1 2 3 4 5 6 7 8 9 a b c d e f A B C D E F の何れか1つ
</code></pre><p>　一部異なるのは、StringNumericLiteral と NumericLiteral ( 7.8.3 参照)の構文の間で留意されるべきであるということです。</p>
    <ul>
        <li>StringNumericLiteral は、ホワイトスペースや行終端、または両方によって先行されたり、続いたり、または両方になる場合がある</li>
        <li>小数であるStringNumericLiteralは、先行する0の桁の数値を持つ(0埋めされる)場合がある</li>
        <li>小数であるStringNumericLiteralは、その符号を示す + や - によって先行される(符号が付く)場合がある</li>
        <li>カラまたはホワイトスペースだけを含むStringNumericLiteralは、+0に変換される</li>
    </ul>
    <p>　StringからNumberの値に変換することは、全体的には、数値リテラルにおけるNumber値の決定( 7.8.3 参照)に似ており、一部詳細は異なるものの、String数値リテラルからNumber型への変換におけるプロセスは、ここで全て与えられます。 この値は、2つのステップで決定されます。 まず、数学的な値 (MV) は、文字列の数値リテラルから継承され、次にこの数学的な値は、次で説明したように丸められ(丸め処理が行われ)ます。</p>
<pre><code>・StringNumericLiteral の MV ::: [empty] は 0
    ・StringNumericLiteral の MV ::: StrWhiteSpace は 0
    ・StringNumericLiteral の MV ::: StrWhiteSpaceopt StrNumericLiteral StrWhiteSpaceopt は ホワイトスペースの有無に関わらず、StrNumericLiteral の MV
    ・StringNumericLiteral の MV ::: StrDecimalLiteral は StrDecimalLiteral の MV
    ・StringNumericLiteral の MV ::: HexIntegerLiteral は HexIntegerLiteral の MV
    ・StringNumericLiteral の MV ::: StrUnsignedDecimalLiteral は StrUnsignedDecimalLiteral の MV
    ・StringNumericLiteral の MV ::: + StrUnsignedDecimalLiteral は StrUnsignedDecimalLiteral の MV
    ・StringNumericLiteral の MV ::: - StrUnsignedDecimalLiteral は StrUnsignedDecimalLiteral の MV (注釈としては、StrUnsignedDecimalLiteralのMVが0である場合、このMVの負数もまた0。以下で説明する丸め(処理)規則は、この符号なしの数学的なゼロの適切な値として浮動小数点 +0 や -0 への変換を操作。)

    * StringNumericLiteral / 文字列数値リテラル

    ・StrUnsignedDecimalLiteral の MV ::: Infinity(無限)は10の10000乗(値が大きすぎる為、おそらくそれは+∞に丸められる。)
    ・StrUnsignedDecimalLiteral の MV ::: DecimalDigits. は DecimalDigits の MV
    ・StrUnsignedDecimalLiteral の MV ::: DecimalDigits . DecimalDigits は、 n が2つめのDecimalDigitsにある文字数であり、(2つめのDecimalDigitsの MVは10のマイナスn乗倍)を加えた1つめのDecimalDigitsの MV
    ・StrUnsignedDecimalLiteral の MV ::: DecimalDigits. ExponentPart は、eがExponentPartのMVでDecimalDigits掛ける10e倍の MV
    ・StrUnsignedDecimalLiteral の MV ::: DecimalDigits. DecimalDigits ExponentPart は、2つめのDecimalDigitsにある文字数、eはExponentPartのMVであり、((2つめのDecimalDigits掛ける10マイナスn乗倍のMV)を加えた1つめのDecimalDigitsのMVで)10e倍
    ・StrUnsignedDecimalLiteral の MV ::: . DecimalDigits は、10のマイナスn乗倍のMVであり、n はDecimalDigitsにある文字数
    ・StrUnsignedDecimalLiteral の MV ::: . DecimalDigits ExponentPart は、10のe-n乗倍のMVであり、n は、DecimalDigitsにある文字数であり、eはExponentPartのMV
    ・StrUnsignedDecimalLiteral の MV ::: DecimalDigits は、DecimalDigitsのMV
    ・StrUnsignedDecimalLiteral の MV ::: DecimalDigits ExponentPart は、DecimalDigits掛ける10のe乗倍のMVであり、eは、ExponentPartのMV

    * StrUnsignedDecimalLiteral / 文字列符号なし10進リテラル

    ・DecimalDigits の MV ::: DecimalDigitはDecimalDigitのMV
    ・DecimalDigits の MV ::: DecimalDigits DecimalDigit は、DecimalDigitのMVを加えたもの(DecimalDigits掛ける10のMV)

    * DecimalDigits / 10進数・10進数値の並び

    ・ExponentPart の MV ::: ExponentIndicator SignedInteger は、SignedIntegerのMV

    * ExponentPart / 指数部

    ・SignedInteger の MV  ::: DecimalDigits は、DecimalDigitsのMV
    ・SignedInteger の MV ::: + DecimalDigits は、DecimalDigitsのMV
    ・SignedInteger の MV ::: - DecimalDigits は、DecimalDigitsのMVの負の値

    * SignedInteger / 符号付き整数

    ・DecimalDigit の MV ::: 0や16進数の0 ::: 0 は 0
    ・DecimalDigit の MV ::: 1や16進数の1 ::: 1 は 1
    ・DecimalDigit の MV ::: 2や16進数の2 ::: 2 は 2
    ・DecimalDigit の MV ::: 3や16進数の3 ::: 3 は 3
    ・DecimalDigit の MV ::: 4や16進数の4 ::: 4 は 4
    ・DecimalDigit の MV ::: 5や16進数の5 ::: 5 は 5
    ・DecimalDigit の MV ::: 6や16進数の6 ::: 6 は 6
    ・DecimalDigit の MV ::: 7や16進数の7 ::: 7 は 7
    ・DecimalDigit の MV ::: 8や16進数の8 ::: 8 は 8
    ・DecimalDigit の MV ::: 9や16進数の9 ::: 9 は 9
    ・DecimalDigit の MV ::: aや16進数のa ::: A は 10
    ・DecimalDigit の MV ::: bや16進数のb ::: B は 11
    ・DecimalDigit の MV ::: cや16進数のc ::: C は 12
    ・DecimalDigit の MV ::: dや16進数のd ::: D は 13
    ・DecimalDigit の MV ::: eや16進数のe ::: E は 14
    ・DecimalDigit の MV ::: fや16進数のf ::: F は 15

    * DecimalDigit / 単一の10進数・10進数値

    ・HexIntegerLiteral の MV ::: 0x HexDigit は、HexDigitのMV
    ・HexIntegerLiteral の MV ::: 0x HexDigit は、HexDigitのMV
    ・HexIntegerLiteral の MV ::: HexIntegerLiteral HexDigit は、HexDigitのMVを加えたもの(HexIntegerLiteral掛ける16のMV)

    * HexIntegerLiteral / 16進整数リテラル
</code></pre><p>　一度、String数値リテラルにおける正確なMVが決定されるとNumber型の値に丸められます。 MVが0である場合、丸められた値が-0というケースにおけるString数値リテラルにある最初の非ホワイトスペース文字が’-’(マイナス)でない限り、丸められた値は+0です。 それ以外の場合には、StrUnsignedDecimalLiteralと桁0を伴う20番め以降の有効な桁ごとに置換することによって、そしてその際に20番めの桁位置でリテラルを増分することによって生成した桁0を伴う20番め以降の有効な桁、または、リテラルのMVにおけるNumber値ごとに置換することによって生成したリテラルのMVにおけるNumber値の何れかになる場合があるNumber値というケースにおける必要な桁数が20桁以上であるリテラルでない限り、丸めた値は(8.5で定義された意味合いで)MVにおけるNumber値にしなければいけません。 ExponentPartの一部でない場合で且つ、</p>
    <ul>
        <li>それが0ではない場合</li>
        <li>その左に非ゼロの桁があり、その右側にExponentPart内ではないところに非ゼロの桁がある場合</li>
    </ul>
    <p>には、桁は有効です。</p>
    <h3 id="9-4-tointeger">9.4 ToInteger</h3>
    <p>　抽象操作ToIntegerは、その引数を整数の値に変換します。 この抽象操作は、次のように機能します。</p>
<pre><code>1.numberは入力となる引数についてToNumberを呼んだ結果とする
    2.numberがNaNである場合には、+0を返す
    3.numberが+0、-0、+∞、-∞である場合には、numberを返す
    4.sign(number) * floor(abs(number)) の算出値を結果として返す
</code></pre><h3 id="9-5-toint32-32-">9.5 ToInt32: (符号付き 32 ビット整数)</h3>
    <p>　抽象操作ToInt32は、その引数を-2の31乗から2の31乗-1の範囲を含むそこにある2の32乗の1つである整数値に変換します。 この抽象操作は、次のように機能します。</p>
<pre><code>1.numberは、入力となる引数についてToNumberを呼ぶことによって結果とする
    2.numberがNaN、+0、-0、+∞、-∞である場合には、+0を返す
    3.posIntは、sign(number) * floor(abs(number)) とする
    4.int32bitは、posInt法として2の32乗とする、それは、正の符号を伴うNumber型である有限の整数値 k であり、且つ、数学的にposIntのものとは異なったり、数学的に2の32乗の複数の整数である k といったようなサイズにある2の32乗よりも小さいという意味
    5.int32bitが2の31乗以上である場合には、int32bit-2の32乗を返し、そうでなければint32bitを返す
</code></pre><p>[注釈] ToInt32:の上記定義について追記</p>
    <ul>
        <li>ToInt32抽象操作は、冪等(idempotent)です。もし、それが生成する結果を適用する場合には、2つめのアプリケーションは変更した値を残します。</li>
        <li>ToInt32(ToUint32(x))は、 x という全ての値についてToInt32(x)することと等価です。</li>
        <li>ToInt32は、-0を+0にマップします。</li>
    </ul>
    <p>[注記]冪等(idempotent)：「べきとう」の「とう」は、「など」という意味合いではなく「等しい」ことを表し、数学的には、ある1つの数値が表す値とその数値に同じ数値を複数回、累乗・べき乗(同じ数同士の乗算)した時の結果が等しい場合、「そのべき乗した際の演算子は、冪等である」とされ、その性質や規則性を冪等性(idempotence)、冪等律(Idempotent law)などといい、プログラミングを含む情報工学では、転じて「同じ条件下で1回の実行によって得られた結果は、複数回実行したとしても毎回全く同じ結果を得られる」ことを表す。</p>
    <h3 id="9-6-touint32-32-">9.6 ToUint32: (符号なし 32 ビット整数)</h3>
    <p>　抽象操作ToUint32は、その引数を0から2の32乗-1までの範囲を含むその中にある2の32乗の整数値の1つに変換します。 この抽象操作は、次のように機能します。</p>
<pre><code>1.numberは、入力となる引数についてToNumberを呼ぶことによって結果とする
    2.numberがNaN、+0、-0、+∞、-∞である場合には、+0を返す
    3.posIntは、sign(number) * floor(abs(number)) とする
    4.int32bitは、posInt法として2の32乗とする、それは、正の符号を伴うNumber型の有限の整数値 k と数学的にはposIntとは異なり、数学的に2の32乗の複数の整数である k といったようなサイズにある2の32乗より小さいという意味
    5.int32bitを返す
</code></pre><p>[注釈] ToUInt32:の上記定義について追記</p>
    <ul>
        <li>ステップ5については、唯一ToUInt32とToInt32とでは異なります。</li>
        <li>ToUint32抽象操作は、冪等(idempotent)です。もし、それが生成した結果を適用する場合には、2番めのアプリケーションは変換した値を残します。</li>
        <li>ToUint32(ToInt32(x)) は、x という全ての値についてToUint32(x)するのと等価です。(それは+0にマップされる+∞、-∞というこの最後のプロパティを保存する為にあります)</li>
        <li>ToUint32は-0を+0にマップします。</li>
    </ul>
    <h3 id="9-7-touint16-16-">9.7 ToUint16: (符号なし 16 ビット整数)</h3>
    <p>　抽象操作ToUint16は、その引数を0から2の16乗-1を含む範囲にある2の16乗の整数値に変換します。 この抽象操作は、次のように機能します、</p>
<pre><code>1.numberは、入力となる引数についてToNumberを呼ぶことによって結果とする
    2.numberがNaN、+0、-0、+∞、-∞である場合には、+0を返す
    3.posIntは、sign(number) * floor(abs(number)) とする
    4.int16bitはposInt法として2の16乗とする、それは正の符号を伴い、数学的にはposIntとは異なり、2の16乗の複数の整数値である k といったような大きさの中にある2の16乗よりも小さいNumber型の有限の整数値 k という意味。
    5.int16bitを返す
</code></pre><p>[注釈] ToUint16の上記定義について追記</p>
    <ul>
        <li>ステップ4にある2の32乗が、2の16乗に置き換わっている点だけが唯一ToUint32とToUint16とでは異なります。</li>
        <li>ToUint16は-0を+0にマップします。</li>
    </ul>
    <h3 id="9-8-tostring">9.8 ToString</h3>
    <p>　抽象操作ToStringは、その引数をTable 13によってString型の値に変換します。</p>
<pre><code>Table 13 -- ToString変換
    --------------------------------------------------------------------------------
    引数の型    結果
    --------------------------------------------------------------------------------
    Undefined   &quot;undefined&quot;
    Null        &quot;null&quot;
    Boolean     その引数が true である場合には、その結果は、 &quot;true&quot;
    その引数が false である場合には、その結果は、 &quot;false&quot;
    Number      9.8.1 参照
    String      入力となる引数を返す(変換なし)
    Object      次のステップを適用
    1. primValueは、ToPrimitive(input argument, hint String) とする
    2. ToString(primValue) を返す
    --------------------------------------------------------------------------------
</code></pre><h3 id="9-8-1-number-tostring">9.8.1 Number型に適用するToString</h3>
    <p>　抽象操作ToStringは、次のようにStringの書式にNumber m を変換します。</p>
<pre><code>1.もし、 m が NaN である場合には、Stringの&quot;NaN&quot;を返す
    2.もし、 m が +0 や -0 である場合には、Stringの&quot;0&quot;を返す
    3.もし、 m が ゼロより小さい場合には、Stringの&quot;-&quot;とToString(-m)の結合であるStringを返す
    4.もし、 m が 無限大である場合には、Stringの&quot;Infinity&quot;を返す
    5.それ以外の場合には、n,k,sは、k≧1,10のk乗-1≦s＜10のk乗、s*10のn-k乗におけるNumber型の値であるm、また k は可能な限り小さいといったような整数にする
</code></pre><p>　注釈として k は、s を表示する為の少数の桁の数であり、それは10で割り切れず、sの最下位桁が、これらの条件によって一意に決まる必要はありません。</p>
<pre><code>6.もし、 k ≦ n ≦ 21 である場合には、(先行するゼロがない為、) s の小数表示部 k 桁から成るStringを返し、文字&#39;0&#39;として現れるn-kによって続く
    7.もし、0 ＜ n ≦ 21 である場合には、s の小数表示の最も重要なn桁から成るStringを返し、小数点&#39;.&#39;によって続き、残りの s の小数表示部の k-n 桁まで続く
    8.もし、-6 ＜ n ≦ 0 である場合には、文字&#39;0&#39;から成るStringを返し、小数点&#39;.&#39;によって続き、文字&#39;0&#39;として現れる-nによって続き、s の小数表示部の k 桁によって続く
    9.それ以外の場合には、もし、 k = 1 である場合には、s の単独の桁から成るStringを返し、小文字 &#39;e&#39; によって続き、n-1 が正か負かにより1つのプラス記号 &#39;+&#39; やマイナス記号 &#39;-&#39; によって続き、先行するゼロのない整数 abs(n-1) の小数表示部によって続く
    10. s の小数表示部の最も重要な桁から成るStringを返し、小数点 &#39;.&#39; によって続き、残る s の小数表示部 k-1 によって続き、小文字 &#39;e&#39; によって続き、n-1 が正か負かにより1つのプラス記号 &#39;+&#39; やマイナス記号 &#39;-&#39; によって続き、先行するゼロのない整数 abs(n-1) の小数表示部によって続く
</code></pre><p>[注釈1]</p>
    <p>　次の観測は、実装におけるガイドラインとして便利になる場合もありますが、この標準規格の正規の要件の一部ではありません。</p>
    <ul>
        <li>もし、 x が -0 ではないNumber型の何らかの値で在る場合には、ToNumber(ToString(x)) は、xと全く同じNumber値です。</li>
        <li>sの最下位桁は、ステップ5で挙げた要件によって常に一意に決まる訳ではありません。</li>
    </ul>
    <p>[注釈2]</p>
    <p>　上記ルールによって要求される以上により正確な変換を提供する実装においては、ステップ5の次の代替バージョンをガイドラインとして使うことが推奨されます。 それ以外の場合には、n,k,sは、k ≧ 1、10のk-1乗 ≦ s ＜ 10のk乗、 s * 10のn-k乗 におけるNumber型の値が m であり、 k は可能な限り小さくなります。 もし、s について複数の可能性がある場合、mにおける値の中で最も近い値である s * 10のn-k乗 におけるsの値を選択します。 もし、s の値としてそのような可能性が2つある場合には、偶数の方を選択します。 付記として s の小数表示部にある桁の数 k と そのs自体は、10で割り切れません。</p>
    <p>[注釈3]</p>
    <p>　ECMAScriptの実装は、David M 氏によって書かれた有用な紙面とコードが見つかる場合があります。</p>
<pre><code>『Gay for binary-to-decimal conversion of floating-point numbers (浮動小数点数のバイナリから小数への変換における華) / Gay, David M.』
    『Correctly Rounded Binary-Decimal and Decimal-Binary Conversions (正しい丸め処理のBinary-DecimalとDecimal-Binary変換)』
    『Numerical Analysis, Manuscript 90-10 (数値解析、原稿90-10) 』

    AT&amp;T Bell Laboratories／AT&amp;Tベル研究所 (Murray Hill, New Jersey)
    1990年11月30日
    http://cm.bell-labs.com/cm/cs/doc/90/4-10.ps.gz. のようにすれば利用可能です。
    http://cm.bell-labs.com/netlib/fp/dtoa.c.gz と http://cm.bell-labs.com/netlib/fp/g_fmt.c.gz のようにすれば利用可能な関連コードは様々なnetlibミラーサイトで見つけることも可能です。
</code></pre><h3 id="9-9-toobject">9.9 ToObject</h3>
    <p>　抽象操作ToObjectは、その引数をTable 14によってObject型の値に変換します。</p>
<pre><code>Table 14 -- ToObject
    -------------------------------------------------------------------------------------------------------------
    引数の型    結果
    -------------------------------------------------------------------------------------------------------------
    Undefined   TypeError例外を投げる(スローする)
    Null        TypeError例外を投げる(スローする)
    Boolean     [[PrimitiveValue]]内部プロパティが引数の値に設定される新たなBooleanオブジェクトを生成。Booleanオブジェクトの概要については15.6参照。
    Number      [[PrimitiveValue]]内部プロパティが引数の値に設定される新たなNumberオブジェクトを生成。Numberオブジェクトの概要については15.7参照。
    String      [[PrimitiveValue]]内部プロパティが引数の値に設定される新たなStringオブジェクトを生成。Stringオブジェクトの概要については15.5参照。
    Object      結果は入力となる引数(変換なし)
    -------------------------------------------------------------------------------------------------------------
</code></pre><h3 id="9-10-checkobjectcoercible">9.10 CheckObjectCoercible</h3>
    <p>　抽象操作CheckObjectCoercibleは、その引数が、ToObjectを利用してObjectに変換されることができない値である場合、エラーを投げます。 これについてはTable 15によって定義されます。</p>
<pre><code>Table 15 -- CheckObjectCoercible の結果
    ---------------------------------------------------
    引数の型    結果
    ---------------------------------------------------
    Undefined   TypeError例外を投げる(スローする)
    Null        TypeError例外を投げる(スローする)
    Boolean     リターン
    Number      リターン
    String      リターン
    Object      リターン
    ---------------------------------------------------
</code></pre><h3 id="9-11-iscallable">9.11 IsCallable</h3>
    <p>　抽象操作IsCallableは、その引数がTable 16による関数のObjectを呼ぶことになるECMAScript言語の値にしなければいけない場合に決定されます。</p>
<pre><code>Table 16 -- IsCallable の結果
    -------------------------------------------------------------------------------------------------------------
    引数の型    結果
    -------------------------------------------------------------------------------------------------------------
    Undefined   falseを返す
    Null        falseを返す
    Boolean     falseを返す
    Number      falseを返す
    String      falseを返す
    Object      引数が[[Call]]内部メソッドを持つ場合にはtrue、そうでない場合にはfalseを返す
    -------------------------------------------------------------------------------------------------------------
</code></pre><h3 id="9-12-samevalue-">9.12 SameValue のアルゴリズム</h3>
    <p>　ECMAScript言語の値である x と y である場合の内部比較抽象操作SameValue(x, y)は、trueまたはfalseを生成します。 このような比較は次のように実行されます。</p>
<pre><code>1.Type(x)がType(y)と異なる場合、falseを返す
    2.Type(x)がUndefinedである場合、trueを返す
    3.Type(x)がNullである場合、trueを返す
    4.Type(x)がNumberである場合、
    a. x が NaN かつ y が NaNである場合、trueを返す
    b. x が +0 かつ y が -0である場合、falseを返す
    c. x が -0 かつ y が +0である場合、falseを返す
    d. x が y と同じNumber型の値である場合、trueを返す
    e.(何れでもない場合)falseを返す
    5.Type(x)がString型である場合、x と y の文字並びが全く同じ(一致する位置において同じ長さで同じ文字)であればtrueを返し、それ以外は、falseを返す
    6.Type(x)がBooleanである場合、x と y が共にtrueまたはfalseであればtrueを返し、それ以外は、falseを返す
    7.x と y が同じオブジェクトを参照する場合、trueを返す。それ以外はfalseを返す。
</code></pre><h2 id="10-executable-code-and-execution-contexts-standard-ecma-262-5-1-edition">10 実行コードと実行コンテキスト / Executable Code and Execution Contexts / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="10-">10 実行コードと実行コンテキスト</h3>
    <h2 id="10-1-types-of-executable-code-standard-ecma-262-5-1-edition">10.1 実行コードの種類 / Types of Executable Code / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="10-">10 実行コードと実行コンテキスト</h3>
    <h3 id="10-1-">10.1 実行コードの型・種類</h3>
    <p>　ECMAScriptの実行コードの種類には、3つあります(Global コード / Eval コード / Function コード)。</p>
    <ul>
        <li>Global コードは、ECMAScriptのProgramとして扱われるソーステキストです。固有のProgramのグローバルなコードは、FunctionBody(関数本体)の一部として解釈される一部のソーステキストを含みません。</li>
        <li>Eval コードは、組み込み eval 関数に提供されるソーステキストです。より正確には、組み込み eval 関数へのパラメータがString型である場合、ECMAScriptのProgramとして扱われます。特定の eval の呼び出しにおける evalのコードは、Programのグローバルコード部分です。</li>
        <li>Function コードは、FunctionBody(関数本体)の一部として解釈されるソーステキストです。特定のFunctionBodyの関数のコードは、ネストしたFunctionBodyの一部として解釈される一部のソーステキストを含みません。FunctionBodyの関数のコードは、コンストラクタとして組み込み Function オブジェクトを利用する場合に提供されるソーステキストであることをも意味します。より正確には、Functionコンストラクタに提供される最後のパラメータは、String型に変換され、FunctionBodyとして扱われます。Functionコンストラクタに提供されるパラメータが1つ以上ある場合には、最後の1つを除く全てのパラメータは、Strings型に変換、結合され、カンマで区切られます。結果となるString型は、最後のパラメータによって定義したFunctionBodyにおけるFormalParameterListとして解釈されます。Functionの特定のインスタンス化における関数のコードは、FunctionBodyの一部として解釈される一部のソーステキストを含みません。</li>
    </ul>
    <h3 id="10-1-1-strict-">10.1.1 Strictモードのコード</h3>
    <p>　ECMAScriptプログラムの構文上の単位は、無制限またはstrict(厳格)モードの構文とセマンティックに使用されて処理される場合があります。 ECMAScriptコードの3つのタイプが、strict(厳格)モードを使って処理される場合には、strict global(厳格なグローバル)コード、strict eval(厳格な評価)コード、strict function(厳格な関数)コードとして参照されます。</p>
    <p>　コードは、次の状況においてはstrict(厳格)モードのコードとして解釈されます。</p>
    <ul>
        <li>Globalコードは、Use Strict Directive ( 14.1 参照)を含むDirective Prologueで始まる場合には、strict(厳格)グローバルコードです。</li>
        <li>Evalコードは、Use Strict 指定 を含む Directive Prologue で始まる場合やevalの呼び出しがstrict(厳格)モードのコード内に含まれる eval 関数への直接呼び出し( 15.1.2.1.1 参照)である場合、strict(厳格)evalコードです。</li>
        <li>FunctionDeclaration(関数宣言)、FunctionExpression(関数の式)やアクセサPropertyAssignment(プロパティの関連付け)の一部であるFunctionコードは、そのFunctionDeclaration、FunctionExpressionやPropertyAssignmentがstrict(厳格)モードのコードに含まれる場合や関数のコードが、 Use Strict Directive を含む Directive Prologue で始まる場合、strict(厳格)関数コードです。</li>
        <li>組み込みFunctionコンストラクタへの最後の引数として提供される関数のコードは、その最後の引数がString型であり、Use Strict Directiveを含むDirective Prologueで始まるFunctionBody(関数本体)として処理される場合、strict(厳格)関数のコードです。</li>
    </ul>
    <p>&lt;!-- --&gt;
    </p>
<pre><code>[注：] Use Strict Directive と Directive Prologue

    Use Strict Directive
    Use Strict ディレクティブ(指定・指示・命令)

    &#39;use strict&#39;
    &quot;use strict&quot;

    によるstrict モードの指定

    Directive Prologue
    指定(指示・命令)プロローグ(序章・前置)
    前置指定
</code></pre><h2 id="10-2-lexical-environment-standard-ecma-262-5-1-edition">10.2 語彙環境 / Lexical Environment / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="10-">10 実行コードと実行コンテキスト</h3>
    <h3 id="10-2-lexical-environment">10.2 語彙環境 / Lexical Environment</h3>
    <p>　語彙環境(Lexical Environment)とは、固有の変数におけるIdentifiers(識別子)との関連付けを定義する為に使用される仕様上の種類であり、関数は、語彙的にネストしたECMAScriptコードの構造に基づきます。 語彙環境は、環境レコード(Environment Record)とnullである可能性もある外部の語彙的な環境への参照から成ります。 通常、語彙環境は、FunctionDeclaration (関数宣言)、WithStatement (With 文)、TryStatement (Try 文)のCatch句、または、そのようなコードが評価されるごとに生成される新たな語彙環境のようなECMAScriptのコードの同一の特定の構文上で関連付けされます。</p>
    <p>　環境レコードは、関連付けた語彙環境のスコープ内で生成される関連付けした識別子を記録します。</p>
    <p>　外部環境の参照は、語彙環境の値から成る論理的なネストを形成する為に使用されます。 (内部の)語彙環境の外部参照は、内部の語彙環境を論理的に括る語彙環境を参照します。 外部の語彙環境は、当然ながら、外部の語彙環境それ自身を持ちます。 語彙環境は、複数の内部の語彙環境における外部の環境として提供される場合があります。 例えば、FunctionDeclarationが2つのネストしたFunctionDeclarationsを含む場合、ネストした2つの関数ごとの語彙環境は、囲まれた関数について現在実行中の語彙環境を外部の語彙環境として持ちます。</p>
    <p>　語彙環境と環境レコードの値は、単に仕様上の仕組みであり、ECMAScriptの実装における人為的な一部仕様と一致する必要はありません。 それは、ECMAScriptのプログラムにおいて、そのような値に直接アクセスしたり、直接、値を操作することを可能にします。</p>
    <h3 id="10-2-1-environment-record">10.2.1 環境レコード / Environment Record</h3>
    <p>　宣言型環境レコードとオブジェクト型環境レコードという種類が2つある環境レコードの値は、この仕様の中で使用されます。 宣言型環境レコードは、ECMAScript言語の値と直接関連付ける識別子バインディングであるFunctionDeclarations、VariableDeclarationsとCatch句のようなECMAScript言語の構文上の要素の効果を定義する為に使用されます。 オブジェクト型環境レコードは、一部のオブジェクトのプロパティを伴う識別子バインディングとの関連付けである Program と WithStatement のようなECMAScriptの要素の効果を定義する為に使用されます。</p>
    <p>　仕様目的における環境レコードの値は、宣言型環境レコードとオブジェクト型環境レコードという具体的な2つのサブクラスを伴う抽象クラスである環境レコードにおけるオブジェクト指向的な階層内に存在するかのように考えることができます。 抽象クラスは、Table 17で定義した抽象仕様メソッドを含みます。</p>
    <p>　これらの抽象メソッドは、具体的なサブクラスごとの明らかに異なる具体的なアルゴリズムを持ちます。</p>
<pre><code>Table 17 -- 環境レコードの抽象メソッド
    -------------------------------------------------------------------------------------------------------------
    メソッド            目的
    -------------------------------------------------------------------------------------------------------------
    HasBinding(N)           環境レコードが識別子におけるバインディングを持つ場合に決定
    持てばtrue、持たなければfalse
    String型の値 N は、識別子のテキスト
    CreateMutableBinding(N, D)  環境レコード内に新たに変更可能なバインディングを生成
    String型の値 N は、バインドされた名前としてのテキスト
    オプションのBoolean型引数 D が、trueである場合には、バインディングは順次削除される可能性がある
    SetMutableBinding(N, V, S)  環境レコード内に既に存在する変更可能なバインディングの値を設定
    String型の値 N は、バインドされた名前としてのテキスト
    V は、バインディングにおける値であり、一部のECMAScript言語の型の値になる場合がある
    S は、Booleanフラグ
    S が、true で且つバインディングが設定できない場合には、TypeError例外を投げる(スローする)
    S は、strict(厳格)モード参照を識別する為に使用される
    GetBindingValue(N,S)        環境レコードから既存のバインディングの値を返す
    String型の値 N は、バインドされた名前としてのテキスト
    S は、strict(厳格)モード参照を識別する為に使用される
    S が、trueで且つバインディングするものが存在しない場合や初期化されていない場合には、ReferenceError例外を投げる(スローする)
    DeleteBinding(N)        環境レコードからバインディングを削除
    String型の値 N は、バインドされた名前としてのテキスト
    既存の N におけるバインディングが存在する場合には、そのバインディングを削除し、true を返す
    バインディングは存在するが削除できない場合には、false を返す
    バインディングが存在しない場合には、true を返す
    ImplicitThisValue()     当該環境レコードから値をバインディングする値を関数オブジェクトを呼ぶことによって取得される当該値と同様に使用する為の値を返す
    -------------------------------------------------------------------------------------------------------------
</code></pre><h3 id="10-2-1-1-declarative-environment-records">10.2.1.1 宣言型環境レコード／Declarative Environment Records</h3>
    <p>　各宣言型環境レコードは、変数と(や)関数宣言を含むECMAScriptプログラムにおけるスコープと関連付けられます。 宣言型環境レコードは、そのスコープ内に含まれる宣言によって定義した識別子の集合をバインドします(関連付けます)。</p>
    <p>　追記すると変更可能なバインディングは、全ての環境レコードによってサポートされ、宣言型環境レコードはまた恒久的なバインディングについても提供します。 恒久的なバインディングとは、識別子と生成されてすぐに変更されない値との間を関連付けることもその1つです。 恒久的なバインディングの生成と初期化は、初期化された、または初期化されていない状態の何れにも存在する為、このように関連付けて利用することが可能なので、そのステップは異なります。</p>
    <p>　宣言型環境レコードは、環境レコード抽象仕様メソッドにおける付記にある Table 18 の中で列挙したメソッドをサポートします。</p>
<pre><code>Table 18 -- 宣言型環境レコードの追加のメソッド
    -------------------------------------------------------------------------------------------------------------
    メソッド                目的
    -------------------------------------------------------------------------------------------------------------
    CreateImmutableBinding(N)       新たに生成するが、初期化されず、環境レコード内で恒久的に関連付ける
    String型の値 N は、バインドされた名前としてのテキスト
    InitializeImmutableBinding(N,V)     既存の値を設定するが、初期化されず、環境レコード内で恒久的に関連付ける
    String型の値 N は、バインドされた名前としてのテキスト
    V は、バインディングにおける値であり、一部のECMAScript言語の型の値
    -------------------------------------------------------------------------------------------------------------
</code></pre><p>　宣言型環境レコードにおける具体的な仕様メソッドの動作は、次のアルゴリズムによって定義されます。</p>
    <h3 id="10-2-1-1-1-hasbinding-n-">10.2.1.1.1 HasBinding(N)</h3>
    <p>　宣言型環境レコードにおける具体的な環境レコードメソッドHasBindingは、単に引数の識別子が、レコードによってバインドされる識別子の1つである場合に決められます。</p>
<pre><code>1.envRecは、メソッドが実行された場合に宣言型環境レコードとする
    2.envRecが N という値の 名称によるバインディング(結びつき)を持つ場合には、true を返す
    3.そのようなバインディングを持たない場合には、falseを返す
</code></pre><h3 id="10-2-1-1-2-createmutablebinding-n-d-">10.2.1.1.2 CreateMutableBinding (N, D)</h3>
    <p>　宣言型環境レコードにおける具体的な環境レコードのメソッドCreateMutableBindingは、新たに値undefinedに初期化される名称 N という変更可能なバインディングを生成します。 バインディングは、既存の N という環境レコードがあってはいけません。 Boolean型の引数 D が提供され、値が true である場合には、新たなバインディングは、削除の対象としてマークされます。</p>
<pre><code>1.envRecは実行されたメソッドにおける宣言型環境レコードとする
    2.Assert:envRecは、N という 既存のバインディングを持たない
    3. N において envRec 内に変更可能なバインディングを生成し、そのバインド値としてundefinedを設定
    D がtrueであり、新たに生成したバインディングであるレコードである場合には、順次DeleteBindingを呼ぶことによって削除される場合がある
</code></pre><h3 id="10-2-1-1-3-setmutablebinding-n-v-s-">10.2.1.1.3 SetMutableBinding (N,V,S)</h3>
    <p>　宣言型環境レコードにおける具体的な環境レコードのメソッドSetMutableBindingは、引数 V の値について引数 N という値である名前を持つ識別子としての現在のバインディングのバインド値の変更を試行します。 N というバインディングは既に存在しなければいけません。 バインディングが恒久的なバインディングである場合には、 S が true である場合、TypeErrorが投げられ(スローされ)ます。</p>
<pre><code>1.envRecは、実行される当該メソッドにおける宣言型環境レコードとする
    2.Assert:envRecは N というバインディングを持たなければならない
    3.envRecにある N というバインディングが変更可能なバインディングである場合には、そのバインド値を V に変更する
    4.それ以外の場合、S が true である場合、TypeError例外を投げる(スローする)為、恒久的なバインディングの値への変更を試行しなければならない
</code></pre><h3 id="10-2-1-1-4-getbindingvalue-n-s-">10.2.1.1.4 GetBindingValue(N,S)</h3>
    <p>　宣言型環境レコードにおける具体的な環境レコードのメソッドGetBindingValueは、単に引数 N の値である名称を持つ当該バインド識別子の値を返します。 当該バインディングは既に存在しなければいけません。 S が true で且つ当該バインディングが初期化されていない場合、恒久的なバインディングは、ReferenceError例外を投げます。</p>
<pre><code>1.envRecは、実行されたメソッドにおける宣言型環境レコードとする
    2.Assert: envRecは、N というバインディングを持つ
    3.envRec内の N というバインディングが、恒久的なバインディングとして初期化されていない場合、
    a. S がfalseである場合、値undefinedを返し、それ以外はReferenceError例外を投げる(スローする)
    4.それ以外は、envRec内の N への値currently bound(現在のバインド値)を返す
</code></pre><h3 id="10-2-1-1-5-deletebinding-n-">10.2.1.1.5 DeleteBinding (N)</h3>
    <p>　宣言型環境レコードにおける具体的な環境レコードのメソッドDeleteBindingは、削除の対象として明示的に指定されているバインディングだけを削除することが可能です。</p>
<pre><code>1.envRecは、実行されたメソッドにおける宣言型環境レコードとする
    2.envRecがNという値の名称におけるバインディングを持たない場合、trueを返す
    3.envRec内にあるNというバインディングは削除不可であり、falseを返す
    4.envRecからNというバインディングを削除
    5.trueを返す
</code></pre><h3 id="10-2-1-1-6-implicitthisvalue-">10.2.1.1.6 ImplicitThisValue()</h3>
    <p>　宣言型環境レコードは常にそれらのImplicitThisValueとしてundefinedを返します。</p>
<pre><code>1.undefinedを返す
</code></pre><h3 id="10-2-1-1-7-createimmutablebinding-n-">10.2.1.1.7 CreateImmutableBinding (N)</h3>
    <p>　宣言型環境レコードにおける具体的な環境レコードのメソッドCreateImmutableBindingは、値undefinedに初期化される名称 N という新しい恒久的なバインディングを生成します。 バインディングは、Nという環境レコード内に事前に存在してはいけません。</p>
<pre><code>1.envRecは、実行されたメソッドにおける宣言型環境レコードとする
    2.Assert:envRecは、まだNというバインディングを持たない
    3.NというenvRec内に恒久的なバインディングを生成、レコードは初期化されない
</code></pre><h3 id="10-2-1-1-8-initializeimmutablebinding-n-v-">10.2.1.1.8 InitializeImmutableBinding (N,V)</h3>
    <p>　宣言型環境レコードにおける具体的な環境レコードのメソッドInitializeImmutableBindingは、引数 N という値から引数 V という値までの値である名称を持つ識別子の現在のバインディングのバインド値を設定する為に使用されます。 N における初期化されない恒久的なバインディングは既に存在していなければいけません。</p>
<pre><code>1.envRecは実行されたメソッドにおける宣言型環境レコードとする
    2.Assert:envRecは、初期化されない N という恒久的なバインディングを持たなければならない
    3. V に envRec内の N　というバインド値を設定
    4. envRec内の N という恒久的なバインディングであるレコードは、初期化されている
</code></pre><h3 id="10-2-1-2-object-environment-records">10.2.1.2 オブジェクト型環境レコード / Object Environment Records</h3>
    <p>　各オブジェクト型環境レコードは、当該バインディング(結合)オブジェクトを呼ぶオブジェクトと関連付けされます。 オブジェクト型環境レコードは、当該バインディングオブジェクトの一致するプロパティ名をそのまま識別子名として設定します。 IdentifierNameではないプロパティ名は、バインド識別子の集合内には含まれません。 それ自身と継承したプロパティは共に、それらの[[Enumerable]]属性の設定に関わらず集合内に含まれます。 なぜならプロパティは、動的に追加されたり、オブジェクトから削除されたりすることが可能だからであり、オブジェクト型環境レコードによる識別子バインドの集合は、プロパティの追加または削除といった一部操作の副作用として潜在的に変更する場合があります。 このように副作用の結果として生成される一部のバインディングは、対応する値を持つプロパティのWritable属性が、falseである場合でさえ変更可能なバインディングになることが考えられます。 恒久的なバインディングは、オブジェクト型環境レコードにおいては存在しません。</p>
    <p>　オブジェクト型環境レコードは、関数呼び出しで使う為に暗黙のthis値としてそれらのバインディングオブジェクトを提供するように構成することができます。 この機能は、バインディングを誘発するWithステートメント(12.10)の動作を指定する為に使用されます。 その機能は、各オブジェクト型環境レコードごとに関連付けられるBoolean値provideThisによって操作されます。 既定では、provideThisの値は、いかなるオブジェクト型環境レコードにおいてもfalseです。</p>
    <p>　オブジェクト型環境レコードにおける具体的な仕様上のメソッドの動作は、次のアルゴリズムによって定義されます。</p>
    <h3 id="10-2-1-2-1-hasbinding-n-">10.2.1.2.1 HasBinding(N)</h3>
    <p>　オブジェクト型環境レコードにおける具体的な環境レコードのメソッドHasBindingは、その関連付けたバインディングオブジェクトが引数 N という値である名称のプロパティを持つ場合に決まります。</p>
<pre><code>1.envRecは、実行されたメソッドにおけるオブジェクト型環境レコードとする
    2.bindingsは、envRecにおけるバインディングオブジェクトとする
    3.プロパティ名として N を渡すことによってバインディングの[[HasProperty]]内部メソッドを呼ぶことで結果を返す
</code></pre><h3 id="10-2-1-2-2-createmutablebinding-n-d-">10.2.1.2.2 CreateMutableBinding (N, D)</h3>
    <p>　オブジェクト型環境レコードにおける具体的な環境レコードのメソッドCreateMutableBindingは、String型の値である名称を持つプロパティを環境オブジェクトの関連付けられたバインディングオブジェクト内で生成し、値undefinedに初期化します。 N と名付けたプロパティは、バインディングオブジェクト内に既に存在していてはいけません。 Boolean型の引数 D が提供され、値trueを持つ場合、新たなプロパティの[[Configurable]]属性はtrueに設定され、それ以外の場合にはfalseに設定されます。</p>
<pre><code>1.envRecは、実行されたオブジェクト型環境レコードとする
    2.bindingsは、envRecにおけるバインディングオブジェクトとする
    3.Assert:プロパティ名 N と渡すことによってバインディングの[[HasProperty]]内部メソッドはfalse
    4. D がtrueである場合には、configValueはtrueとし、それ以外の場合、configValueはfalseとする
    5.バインディングの[[DefineOwnProperty]]内部メソッドを呼び、引数として N 、プロパティ記述子 {[[Value]]:undefined, [[Writable]]: true, [[Enumerable]]: true , [[Configurable]]: configValue} 、trueを渡す
</code></pre><h3 id="10-2-1-2-3-setmutablebinding-n-v-s-">10.2.1.2.3 SetMutableBinding (N,V,S)</h3>
    <p>　オブジェクト型環境レコードにおける具体的な環境レコードのメソッドSetMutableBindingは、引数 N という値である名称を持つ環境レコードの関連付けられたバインディングオブジェクトのプロパティの値を引数 V という値に設定するべく試行します。 N と名付けたプロパティは、既に存在すべきですが、それが存在しなかったり、現在書き込み可能でない場合、エラー操作は、Boolean型引数 S という値によって決められます。</p>
<pre><code>1.envRec実行されたメソッドにおけるオブジェクト型環境レコードとする
    2.bindingsは、envRecにおけるバインディングオブジェクトとする
    3.引数N, V, Sを伴うバインディングの[[Put]]内部メソッドを呼ぶ
</code></pre><h3 id="10-2-1-2-4-getbindingvalue-n-s-">10.2.1.2.4 GetBindingValue(N,S)</h3>
    <p>　オブジェクト型環境レコードにおける具体的な環境レコードのメソッドGetBindingValueは、識別子 N を引数としたString型の値である名称を持つその関連付けられたバインディングオブジェクトのプロパティの値を返します。 プロパティは、既に存在すべきですが、引数 S の値に依存する結果にならない場合、(以下のように評価されます。)</p>
<pre><code>1.envRecは、実行されたオブジェクト型環境レコードとする
    2.bindingsは、envRecにおけるバインディングオブジェクトとする
    3.valueは、プロパティ名として N を渡すことによってバインディングの[[HasProperty]]内部メソッドを呼んだ結果とする
    4.valueがfalseである場合には、
    a. S がfalseである場合、値undefinedを返し、それ以外の場合、ReferenceError例外を投げる(スローする)
    5.引数における N を渡すことによってバインディングの[[Get]]内部メソッドを呼ぶことで結果を返す
</code></pre><h3 id="10-2-1-2-5-deletebinding-n-">10.2.1.2.5 DeleteBinding (N)</h3>
    <p>　オブジェクト型環境レコードにおける具体的な環境レコードのメソッドDeleteBindingは、値trueを持つ[[Configurable]]属性を持つ環境オブジェクトのプロパティと一致するバインディングだけを削除することが可能です。</p>
<pre><code>1.envRecは、実行されたメソッドにおけるオブジェクト型環境レコードとする
    2.bindingsは、envRecにおけるバインディングオブジェクトとする
    3.N と引数としてfalseを渡すことによってバインディングの[[Delete]]内部メソッドを呼ぶことで結果を返す
</code></pre><h3 id="10-2-1-2-6-implicitthisvalue-">10.2.1.2.6 ImplicitThisValue()</h3>
    <p>　オブジェクト型環境レコードは、それらのprovideThisフラグがtrueである場合以外は、それらのImplicitThisValueとしてundefinedを返します。</p>
<pre><code>1.envRecは、実行されたメソッドにおけるオブジェクト型環境レコードとする
    2.envRecのprovideThisフラグがtrueである場合、envRecにおけるバインディングオブジェクトを返す
    3.それ以外は、undefinedを返す
</code></pre><h3 id="10-2-2-lexical-environment-operations-">10.2.2 Lexical Environment Operations／語彙的環境の操作</h3>
    <p>　次の抽象操作は、語彙的な環境における操作についてのこの仕様内で使用されます。</p>
    <h3 id="10-2-2-1-getidentifierreference-lex-name-strict-">10.2.2.1 GetIdentifierReference (lex, name, strict)</h3>
    <p>　抽象操作GetIdentifierReferenceは、語彙環境であるlex、識別子としてString型のname、Booleanフラグであるstrictを伴って呼ばれます。 lexの値は、nullとなる場合があります。 呼ばれる際、次のステップが実行されます。</p>
<pre><code>1.lexがnull値である場合、
    a.基準値が未定義、参照する名称がname、strict(厳格)モードフラグがstrictであるReference型の値を返す
    2.envRecは、lexの環境レコードとする
    3.引数 N としての名称を渡すことによってenvRecの具体的なメソッドHasBinding(N)を呼んだ結果とする
    4.existsがtrueである場合、
    a.基準値がenvRec、参照する名称がname、strict(厳格)モードフラグがstrictであるReference型の値を返す
    5.それ以外の場合、
    a. outerは、lexの外部環境参照の値とする
    b. 引数としてouter、name、strictを渡すことによってGetIdentifierReferenceを呼ぶことで結果を返す
</code></pre><h3 id="10-2-2-2-newdeclarativeenvironment-e-">10.2.2.2 NewDeclarativeEnvironment (E)</h3>
    <p>　抽象操作NewDeclarativeEnvironmentが、語彙環境や引数 E としてnullを伴って呼ばれる際には、次のステップが実行されます。</p>
<pre><code>1.envは、新たな語彙環境とする
    2.envRecは、バインディングを一切含まない新たに宣言する環境レコードとする
    3.envの環境レコードはenvRecとして設定
    4.envとしての外部の語彙的な環境参照に E を設定
    5.envを返す
</code></pre><h3 id="10-2-2-3-newobjectenvironment-o-e-">10.2.2.3 NewObjectEnvironment (O, E)</h3>
    <p>　抽象操作NewObjectEnvironmentがオブジェクト O と引数として語彙環境 Eを伴って呼ばれる際には、次のステップが実行されます。</p>
<pre><code>1.envは、新たなLexical Environmentとする
    2.envRecは、バインディングオブジェクトとして O を含む新たなオブジェクト型環境レコードとする
    3.envの環境レコードはenvRecとして設定
    4.envの外部の語彙的な環境参照は E に設定
    5.envを返す
</code></pre><h3 id="10-2-3-the-global-environment">10.2.3 グローバル環境 / The Global Environment</h3>
    <p>　グローバル環境は、ECMAScriptコードが実行される前に生成される一意の語彙環境です。 グローバル環境の環境レコードは、グローバルオブジェクト(15.1)であるバインディングオブジェクトを持つオブジェクト型環境レコードです。 グローバル環境の外部環境参照は、nullです。 ECMAScriptコードが実行される場合、オプションとしてプロパティがグローバルオブジェクトに追加され、初期プロパティが変更される場合があります。</p>
    <h2 id="10-3-execution-contexts-standard-ecma-262-5-1-edition">10.3 実行コンテキスト / Execution Contexts / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="10-">10 実行コードと実行コンテキスト</h3>
    <h3 id="10-3-execution-contexts">10.3 実行コンテキスト / Execution Contexts</h3>
    <p>　操作がECMAScriptの実行可能コードに翻訳される際には、操作は、実行コンテキストを入力しています。 スタックから論理的な実行コンテキストをアクティブにします。 この論理的なスタックにおける1番上の実行コンテキストは、実行コンテキストを実行中にします。 操作時、常に生成される新たな実行コンテキストは、実行コンテキストと関連付けられていない実行可能コードに現在実行中の実行コンテキストを関連付けた実行可能コードから翻訳されます。</p>
    <p>　新たに生成した実行コンテキストは、スタック上にプッシュされ、実行中の実行コンテキストになります。 いかなる状態においても実行コンテキストは、その関連付けたコードの実行経過を追跡する必要があります。 追記すると各実行コンテキストは、Table 19 に挙げた状態コンポーネントを持ちます。</p>
<pre><code>Table 19 -- 実行コンテキストの状態コンポーネント
    -------------------------------------------------------------------------------------------------------------
    コンポーネント     目的
    -------------------------------------------------------------------------------------------------------------
    LexicalEnvironment  識別子参照を解決する為に使用した識別子Lexical Environment(語彙環境)は、この実行コンテキスト内にあるコードによって作成される
    VariableEnvironment 環境レコードである識別子Lexical Environmentは、この実行コンテキスト内にあるVariableStatements と FunctionDeclarationsによって生成したバインディングを保持する
    ThisBinding     この実行コンテキストと関連付けたECMAScriptコード内にあるthisキーワードと関連付けた値
    -------------------------------------------------------------------------------------------------------------
</code></pre><p>　実行コンテキストとしてのLexicalEnvironment と VariableEnvironmentコンポーネントは、常に語彙的な環境です。 実行コンテキストが当該LexicalEnvironment と VariableEnvironmentコンポーネントを生成する場合には、最初に同じ値を持ちます。 VariableEnvironmentコンポーネントの値は、LexicalEnvironmentコンポーネントの値が実行コンテキスト内にあるコードの実行中に変更する可能性がある間は、決して変更されません。</p>
    <p>多くの状況においては、唯一実行中の実行コンテキスト(実行コンテキストスタックの最上段)はこの仕様内にあるアルゴリズムによって直接操作されます。 その為、</p>
    <p>用語 “LexicalEnvironment”、“VariableEnvironment”、“ThisBinding”</p>
    <p>は、実行中の実行コンテキストのそれらコンポーネントへの参照について必要となる資格なしで使用されます。</p>
    <p>実行コンテキストは、単に仕様上の仕組みであり、ECMAScript実装の一部の特定の人為的なものと一致する必要はありません。 ECMAScriptプログラムにおいては実行コンテキストにアクセスすることは不可能です。</p>
    <h3 id="10-3-1-identifier-resolution">10.3.1 識別子の解決 / Identifier Resolution</h3>
    <p>　識別子の解決とは、実行中の実行コンテキストのLexicalEnvironmentを使用して識別子としてバインディングすることを決定している過程です。 ECMAScriptコードの実行中、構文上のプロダクションは、PrimaryExpression、識別子は次のアルゴリズムを使用して評価されます。</p>
<pre><code>1.envは、実行中の実行コンテキストのLexicalEnvironmentとする
    2.評価中に構文上のプロダクションが、strict(厳格)モードのコード内に含まれる場合には、strictをtrueとし、それ以外は、strictをfalseとする
    3.引数としてenv、Identifier、strictを渡してGetIdentifierReference関数を呼ぶことによって結果を返す
</code></pre><p>　評価中の識別子の結果は、常にString型のIdentifier(識別子)と等しい名称の参照するコンポーネントであるReference型の値です。</p>
    <h2 id="10-4-establishing-an-execution-context-standard-ecma-262-5-1-edition">10.4 生成中の実行コンテキスト / Establishing an Execution Context / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="10-">10 実行コードと実行コンテキスト</h3>
    <h3 id="10-4-">10.4 生成中の実行コンテキスト</h3>
    <p>　Globalコードやeval関数(15.1.2.1)使用中のコードが、確立し、新たな実行コンテキストを入力します。 関数が自身を再帰的に呼ぶ場合でさえ、ECMAScriptコードの関数(13.2.1)の呼び出しごとに確立し、新たな実行コンテキストを入力します。 各リターンは、任意の実行コンテキストを抜けます。 例外を投げる(スローする)と、1つ以上の実行コンテキストを抜ける場合もあります。</p>
    <p>　操作が実行コンテキストを入力する場合、当該実行コンテキストのThisBindingが設定され、そのVariableEnvironmentと初期のLexicalEnvironmentが定義され、宣言型バインディングのインスタンス化(10.5)が実行されます。 これらアクションにおける正確な動作は、入力されるコードの種類に依存して発生します。</p>
    <h3 id="10-4-1-global-">10.4.1 入力中のGlobalコード</h3>
    <p>　次のステップは、操作がGlobalコードにおける実行コンテキストを入力する場合に実行されます。</p>
<pre><code>1. 10.4.1.1で定義したようにGlobalコードを使用して実行コンテキストを初期化
    2.Globalコードを使用して 10.5 で定義したように宣言型バインディングのインスタンス化を実行
</code></pre><h3 id="10-4-1-1-global-">10.4.1.1 初期のGlobal実行コンテキスト</h3>
    <p>　次のステップは、ECMAScriptコード C におけるGlobal実行コンテキストを初期化する為に実行されます。</p>
<pre><code>1.VariableEnvironmentにGlobal環境を設定
    2.LexicalEnvironmentにGlobal環境を設定
    3.ThisBindingにGlobalオブジェクトを設定
</code></pre><h3 id="10-4-2-eval-">10.4.2 入力中のEvalコード</h3>
    <p>　次のステップは、操作がevalコードにおける実行コンテキストを入力する場合に実行されます。</p>
<pre><code>1.呼ぶコンテキストがなかったり、evalコードが、eval関数を直接呼ぶ(15.1.2.1.1)ことによって評価されない場合には、
    a. 10.4.1.1.で定義した C と同じevalコードを使用中のGlobal実行コンテキストであったかのように実行コンテキストを初期化
    2.Else,
    a.実行コンテキストを呼び出すことによるThisBindingと同じ値をThisBindingに設定
    b.実行コンテキストを呼び出すことによるLexicalEnvironmentと同じ値をLexicalEnvironmentに設定
    c.実行コンテキストを呼び出すことによるVariableEnvironmentと同じ値をVariableEnvironmentに設定
    3.evalコードがstrict(厳格)コードである場合、
    a.strictVarEnvは、引数としてLexicalEnvironmentを渡すことによってNewDeclarativeEnvironmentを呼んだ結果とする
    b.LexicalEnvironmentにstrictVarEnvを設定
    c.VariableEnvironmentにstrictVarEnvを設定
    4.evalコード使用して 10.5 で定義したように宣言型バインディングのインスタンス化を実行
</code></pre><h3 id="10-4-2-1-strict-">10.4.2.1 Strict(厳格)モードの制約</h3>
    <p>　evalコードは、仮にコンテキストを呼んだ結果としてのコードであったり、evalコードがstrict(厳格)コードであった場合でもevalを実行したコンテキストを呼ぶことによる変数環境にある変数や関数バインディングをインスタンス化することはできません。 代わりにそのようなバインディングは、evalコードに唯一アクセス可能である新たなVariableEnvironment内でインスタンス化されます。</p>
    <h3 id="10-4-3-">10.4.3 入力中の関数コード</h3>
    <p>　次のステップは、操作が、オブジェクト F 内に含まれる関数コードにおける実行コンテキストを入力する際、callerがthisArgを提供または、callerがargumentsListを提供する場合に実行されます。</p>
<pre><code>1.関数コードがstrict(厳格)コードである場合、ThisBindingにthisArgを設定
    2.thisArgがnullまたは、undefinedである場合、ThisBindingにGlobalオブジェクトを設定
    3.Type(thisArg)が、Object型ではない場合、ThisBindingにToObject(thisArg)を設定
    4.それ以外の場合、ThisBindingにthisArgを設定
    5.localEnvは、引数として F の[[Scope]]内部プロパティの値を渡すことによってNewDeclarativeEnvironmentを呼んだ結果とする
    6.LexicalEnvironmentにlocalEnvを設定
    7.VariableEnvironmentにlocalEnvを設定
    8.codeは、Fの[[Code]]内部プロパティの値とする
    9. 10.5で説明したように関数コードcodeとargumentsListを使用して宣言型バインディングのインスタンス化を実行
</code></pre><h2 id="10-5-declaration-binding-instantiation-standard-ecma-262-5-1-edition">10.5 宣言型バインディングのインスタンス化 / Declaration Binding Instantiation / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="10-">10 実行コードと実行コンテキスト</h3>
    <h3 id="10-5-declaration-binding-instantiation-">10.5 Declaration Binding Instantiation ／ 宣言型バインディングのインスタンス化</h3>
    <p>　各実行コンテキストは、関連したVariableEnvironmentを持ちます。 実行コンテキスト内で評価したECMAScriptコード内で定義した変数と関数は、そのVariableEnvironmentの環境レコード内でバインディングしたものとして追加されます。 関数コードについては、パラメータは、その環境レコードにバインディングするものとして追加されます。</p>
    <p>　環境レコードは、実行コンテキストによって実行したECMAScriptコードの型に依存するその種類をバインドする為に使用されますが、残りの動作は、一般的なものです。 入力中の実行コンテキストにおいては、バインディングは、次のようなcallerが提供したコードを使用してVariableEnvironment内で生成され、それが関数コードである場合には、引数リストargsは、(以下のように評価されます。)</p>
<pre><code>1.envは、実行中の実行コンテキストのVariableEnvironmentの環境レコードコンポーネントとする
    2.codeがevalコードである場合、configurableBindingsをtrueとし、それ以外は、configurableBindingsをfalseとする
    3.codeがstrict(厳格)モードのコードである場合には、strictをtrueとし、それ以外は、strictをfalseとする
    4.codeが関数コードである場合、
    a.funcは、コードの実行を初期化した[[Call]]内部メソッドを持つ関数とする。namesは、funcの[[FormalParameters]]内部プロパティの値とする
    b.argCountは、argsにある要素の数とする
    c. n は数値0とする
    d.namesにあるString型の各argNameにおいて、リスト順に実行します。
    i. n は、 n + 1 を現在の値とする
    ii. n が、argCountより大きい場合、 v は、undefined、それ以外は、 v は args の n 番めの要素の値とする
    iii.argAlreadyDeclaredは、引数としてargNameを渡すことによって具体的なメソッドであるenvのHasBindingを呼んだものを結果とする
    iv.argAlreadyDeclaredが、falseである場合、引数としてargNameを渡すことによって具体的なメソッドであるenvのCreateMutableBindingを呼ぶ
    v.引数としてargName、v、strictを渡すことによって具体的なメソッドであるenvのSetMutableBindingを呼ぶ
    5.code内の各FunctionDeclaration f において、ソーステキスト順に実行する
    a. fn は、FunctionDeclaration f 内のIdentifierとする
    b. fo は、第13項で説明したようにインスタンス化中のFunctionDeclaration f の結果とする
    c.funcAlreadyDeclaredは、引数として fn を渡すことによって具体的なメソッドであるenvのHasBindingを呼んだ結果とする
    d.funcAlreadyDeclaredがfalseである場合、引数として fn 、 configurableBindingsを渡すことによって具体的なメソッドenvのCreateMutableBindingを呼ぶ
    e.envがGlobal環境の環境レコードコンポーネントである場合、
    i. go は、Globalオブジェクトとする
    ii.existingPropは、引数 fn を伴う go の内部メソッド[[GetProperty]]を呼んだ結果とする
    iii. existingProp .[[Configurable]] がtrueである場合、
    1. 引数として fn 、プロパティ記述子{[[Value]]: undefined, [[Writable]]: true, [[Enumerable]]: true , [[Configurable]]: configurableBindings } 、true を渡すことによって go の内部メソッド[[DefineOwnProperty]]を呼ぶ
    iv. IsAccessorDescriptor(existingProp) やexistingPropが属性値 {[[Writable]]: true, [[Enumerable]]: true} を持たない場合、
    1.TypeError例外を投げる(スローする)
    f.引数として fn 、fo 、strictを渡すことによって具体的なメソッドであるenvのSetMutableBindingを呼ぶ
    6.argumentsAlreadyDeclaredは、引数として&quot;arguments&quot;を渡すことによって具体的なメソッドであるenvのHasBindingを呼んだ結果とする
    7.codeが、関数コード、且つargumentsAlreadyDeclaredがfalseである場合、
    a.argsObjは、引数としてfunc、names、args、env、strictを渡すことによって抽象操作CreateArgumentsObject (10.6) を呼んだ結果とする
    b.strictがtrueである場合、
    i.引数としてString型の&quot;arguments&quot;を渡すことによって具体的なメソッドであるenvのCreateImmutableBindingを呼ぶ
    ii.引数として&quot;arguments&quot; と argsObj を渡すことによって具体的なメソッドであるenvのInitializeImmutableBindingを呼ぶ
    c.それ以外の場合、
    i.引数としてString型の&quot;arguments&quot;を渡すことによって具体的なメソッドであるenvのCreateMutableBindingを呼ぶ
    ii.引数として&quot;arguments&quot;、argsObj、falseを渡すことによって具体的なメソッドであるenvのSetMutableBindingを呼ぶ
    8. code内にある各VariableDeclaration と VariableDeclarationNoIn d は、ソーステキスト順に実行する
    a. dn は、 d 内のIdentifierとする
    b.varAlreadyDeclaredは、引数として dn を渡すことによって具体的なメソッドであるenvのHasBindingを呼んで結果とする
    c.varAlreadyDeclaredがfalseである場合、
    i.引数として dn と configurableBindings を渡すことによって具体的なメソッドであるenvのCreateMutableBindingを呼ぶ
    ii.引数として dn、undefined、strictを渡すことによって具体的なメソッドであるenvのSetMutableBindingを呼ぶ
</code></pre><h2 id="10-6-arguments-arguments-object-standard-ecma-262-5-1-edition">10.6 argumentsオブジェクト / Arguments Object / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="10-">10 実行コードと実行コンテキスト</h3>
    <h3 id="10-6-arguments-arguments-object-">10.6 argumentsオブジェクト / Arguments Object / 引数オブジェクト</h3>
    <p>　操作が、関数のコードにおける実行コンテキストを入力する場合、(10.5で記述したように)識別子の引数が関数のFormalParameterList内にあるIdentifierとして現れるか、または、関数コード内に含まれるVariableDeclaration や FunctionDeclarationのIdentifierとして現れない限り、argumentsオブジェクトが生成されます。</p>
    <p>　当該argumentsオブジェクトは、評価される為にあるコード、関数の正規名を含んだ名称 List、[[Call]]内部メソッドへの実引数 args 、関数コードにおける変数環境 env 、関数コードがstrict(厳格)コードか否かを示すBoolean型のstrictを持つ関数オブジェクトである引数 func を伴う抽象操作CreateArgumentsObjectを呼ぶことによって生成されます。 CreateArgumentsObjectが呼ばれる場合、次のステップが実行されます。</p>
<pre><code>1. len は、args 内の要素の数とする
    2. obj は、新たなECMAScriptオブジェクトを生成したものを結果とする
    3. 8.12 で記述したように obj の全ての内部メソッドを設定
    4. obj の[[Class]]内部プロパティに&quot;Arguments&quot;を設定
    5. Object は、標準組み込みObjectコンストラクタ(15.2.2)とする
    6. obj の[[Prototype]]内部プロパティに標準組み込みObjectのプロトタイプオブジェクト(15.2.4)を設定
    7.引数として&quot;length&quot;、Property Descriptor(プロパティ記述子) {[[Value]]: len, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true}、falseを渡すことによって obj 上で[[DefineOwnProperty]]内部メソッドを呼ぶ
    8. map は、名前付き標準組み込みコンストラクタであるObjectである式 new Object() によるかのように新たなオブジェクトを生成することで結果とする
    9. mappedNames は、カラのListとする
    10. indx = len - 1 とする
    11. indx &gt;= 0 である間繰り返す
    a. val は、0基準リスト(0-origined list)の位置 indx における args の要素とする
    b. 引数として ToString(indx)、プロパティ記述子 {[[Value]]: val, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}、falseを渡すことによって obj 上で[[DefineOwnProperty]]内部メソッドを呼ぶ
    c. indx が names にある要素数よりも小さい場合、
    i. name は、0基準リスト(0-origined list)の位置 indx における names の要素とする
    ii. strict が、falseで且つ name が mappedNames の要素ではない場合、
    1.リストmappedNamesの要素の1つとして name を追加
    2. g は、引数 name と env を伴う抽象操作MakeArgGetterを呼んだ結果とする
    3. p は、引数 name と env を伴う抽象操作MakeArgSetterを呼んだ結果とする
    4.引数として ToString(indx)、プロパティ記述子 {[[Set]]: p, [[Get]]: g, [[Configurable]]: true}、false を渡すことによって map の[[DefineOwnProperty]]内部メソッドを呼ぶ
    d. indx = indx - 1 とする
    12. mappedNames がカラではない場合、
    a. obj の[[ParameterMap]]内部プロパティに map を設定
    b. obj の[[Get]]、[[GetOwnProperty]]、[[DefineOwnProperty]]、[[Delete]]内部メソッドに以下で提供した定義を設定
    13. strict が、false である場合、
    a.引数として&quot;callee&quot;、プロパティ記述子 {[[Value]]: func, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true}、false を渡すことによって obj 上で[[DefineOwnProperty]]内部メソッドを呼ぶ
    14.それ以外の場合、strict は、true となるので
    a. thrower は、[[ThrowTypeError]]関数Object(13.2.3)とする
    b.引数 &quot;caller&quot;、プロパティ記述子 {[[Get]]: thrower, [[Set]]: thrower, [[Enumerable]]: false, [[Configurable]]: false}、falseを伴う obj の[[DefineOwnProperty]]メソッドを呼ぶ
    c.引数 &quot;callee&quot;、プロパティ記述子 {[[Get]]: thrower, [[Set]]: thrower, [[Enumerable]]: false, [[Configurable]]: false}、falseを伴う obj の[[DefineOwnProperty]]メソッドを呼ぶ
    15. obj を返す
</code></pre><p>　String型の name と環境レコード env を伴って呼ぶ抽象操作MakeArgGetterは、env にある name においてバインドする値を返す為に実行した場合、関数オブジェクトを生成します。 それは次のステップを実行します。</p>
<pre><code>1. body は、文字列 &quot;return &quot;、name、&quot;;&quot;を連結したものを結果とする
    2.FormalParameterListがなく、FunctionBodyについては body 、Scopeとして env 、Strictについては trueとして使用することによって 13.2 で説明したように関数オブジェクトを生成した結果を返す
</code></pre><p>　String型の name と 環境レコード env を伴って呼ぶ抽象操作MakeArgSetterは、env にある name においてバインドする値の設定を実行した場合、関数オブジェクトを生成します。 それは次のステップを実行します。</p>
<pre><code>1. param は、文字列  &quot;_arg&quot; と連結した文字列 name とする
    2. body は、name の値によって置換される &lt;name&gt; と param の値によって置換される &lt;param&gt; で文字列 &quot;&lt;name&gt; = &lt;param&gt;;&quot; とする
    3.FormalParameterListとして単独の文字列 param を含む List 、FunctionBodyについては body 、Scopeとして env 、Strictについては true を使用して 13.2 で説明したように関数オブジェクトを生成した結果を返す
</code></pre><p>　プロパティ名 P を伴う非strict(厳格)モードの関数における引数 object の[[Get]]内部メソッドは、次のステップを実行します。</p>
<pre><code>1. map は、引数 object の[[ParameterMap]]内部プロパティの値とする
    2. isMapped は、引数として P を渡すことによって map の[[GetOwnProperty]]内部メソッドを呼んだ結果とする
    3. isMapped の値が undefined である場合には、
    a. v は、引数として P を渡すことによって引数 objectにおける既定の[[Get]] 内部メソッド (8.12.3) を呼んだ結果とする
    b. P が、&quot;caller&quot; である場合、 v は、strict(厳格)モードのFunctionオブジェクトであり、TypeError例外を投げる(スローする)
    c. v を返す
    4.それ以外の場合、 map は、 P における正規なパラメータマッピングを含む為、
    a.引数として P を渡すことによって map の[[Get]]内部メソッドを呼んだ結果を返す
</code></pre><p>　プロパティ名 P を伴って呼ばれる場合、正規のパラメータを伴う非strict(厳格)モードの関数におけるargumentsオブジェクトの[[GetOwnProperty]]内部メソッドは、次のステップを実行します。</p>
<pre><code>1. desc は、引数として P を渡すことによって 引数 object における既定の[[GetOwnProperty]]内部メソッド (8.12.1) を呼んだ結果とする
    2. desc が、undefinedである場合、 desc を返す
    3. map は、argumentsオブジェクトの[[ParameterMap]]内部プロパティの値とする
    4. isMapped は、引数として P を渡すことによって map の[[GetOwnProperty]]内部メソッドを呼んだ結果とする
    5. isMapped の値が、undefinedである場合、
    a. desc.[[Value]] に引数として P を渡すことによって map の[[Get]]内部メソッドを呼んだ結果を設定
    6. desc を返す
</code></pre><p>　プロパティ名 P 、プロパティ記述子 Desc 、Boolean型フラグ Throw を伴って呼んだ正規のパラメータを伴う非strict(厳格)モードの関数におけるargumentsオブジェクトの[[DefineOwnProperty]]内部メソッドは、次のステップを実行します。</p>
<pre><code>1. map は、引数 s オブジェクトの[[ParameterMap]]内部プロパティの値とする
    2. isMapped は、引数として P を渡すことによって map の[[GetOwnProperty]]内部メソッドを呼んだ結果とする
    3. allowed は、引数として P、Desc、false を渡すことによってargumentsオブジェクトにおける既定の[[DefineOwnProperty]]内部メソッド (8.12.9) を呼んだ結果とする
    4. allowed が、false である場合、
    a. Throw が、true である場合、TypeError例外を投げ、それ以外は、falseを返す
    5. isMapped の値が、undefinedである場合、
    a. IsAccessorDescriptor(Desc) が、true であれば、
    i.引数として P 、false を渡すことによって map の[[Delete]]内部メソッドを呼ぶ
    b.それ以外の場合、
    i. Desc.[[Value]] が、存在する場合、
    1.引数としてP 、 Desc.[[Value]] 、 Throw を渡すことによって map の [[Put]]内部メソッドを呼ぶ
    ii. Desc.[[Writable]] が、存在し、且つ、その値が falseである場合、
    1.引数としてP 、falseを渡すことによって map の[[Delete]]内部メソッドを呼ぶ
    6. true を返す
</code></pre><p>　プロパティ名 P 、Boolean型フラグ Throw を伴って呼んだ正規のパラメータを伴う非strict(厳格)モードの関数におけるargumentsオブジェクトの[[Delete]]内部メソッドは、次のステップを実行します。</p>
<pre><code>1. map は、argumentsオブジェクトの[[ParameterMap]]内部プロパティの値とする
    2. isMapped は、引数として P を渡すことによって map の[[GetOwnProperty]]内部メソッドを呼んだ結果とする
    3. result は、引数として P 、 Throwを渡すことによってargumentsオブジェクトにおける既定[[Delete]]内部メソッド (8.12.7) を呼んだ結果とする
    4. result が、true かつ、 isMapped の値が、undefined ではない場合、
    a.引数として P 、 falseを渡すことによって map の[[Delete]]内部メソッドを呼ぶ
    5. result を返す
</code></pre><p>[注釈1]</p>
    <p>　( 15.4 で定義した)非厳格モード(non-strict)の関数の配列インデックスにおいては、数値名の値を持つargumentsオブジェクトの名前付きデータプロパティは、当該関数の実行コンテキスト内でバインディングに対応する引数を伴うそれらの値を初期に共有する関数オブジェクトと対応する正規のパラメータの数よりも小さくなります。 これは、変更中のプロパティは、argumentsオブジェクトの値(逆も真なり)と一致するものを変更するということを意味します。 この対応は、プロパティが削除され再定義される場合やプロパティがアクセサプロパティに変更される場合などに壊れます。 strict(厳格)モードの関数においては、argumentsオブジェクトのプロパティの値は、単に関数に渡した引数のコピーであり、プロパティ値と正規のパラメータ値とを動的にリンクするものではありません。</p>
    <p>[注釈2]</p>
    <p>　ParameterMapオブジェクトとそのプロパティ値は、引数バインディングと対応するargumentsオブジェクトを指定する為にデバイスとして使用されます。 ParameterMapオブジェクトとそのプロパティの値であるオブジェクトは、ECMAScriptのコードから直接アクセスすることは不可能です。 ECMAScriptの実装は、実際に生成したり、指定したセマンティクスを実装する為にそのようなオブジェクトを使用する必要はありません。</p>
    <p>[注釈3]</p>
    <p>　strict(厳格)モードの関数におけるargumentsオブジェクトは、アクセスするとTypeError例外を投げる(スローする) “caller” と “callee” と名付た未構成のアクセサプロパティを定義します。 “callee” プロパティは、非strict(厳格)モードの関数においてという意味でより多くの仕様を持ち、“caller” プロパティは、一部のECMAScriptの実装によって実装定義の拡張として提供される履歴を持ちます。 それらの何れにも確実に存在するこれらプロパティのstrict(厳格)モード定義は、対応するECMAScriptの実装による他の方法の中で定義されます。</p>
    <h2 id="11-expressions-standard-ecma-262-5-1-edition">11 式 / Expressions / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="11-">11 式</h3>
    <h2 id="11-1-primary-expressions-standard-ecma-262-5-1-edition">11.1 主要な式 / Primary Expressions / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="11-">11 式</h3>
    <h3 id="11-1-">11.1 主要な式</h3>
<pre><code>構文

    PrimaryExpression :
    this
    Identifier
    Literal
    ArrayLiteral
    ObjectLiteral
    ( Expression )
</code></pre><h3 id="11-1-1-this-">11.1.1 thisキーワード</h3>
    <p>　thisキーワードは、現在の実行コンテキストのThisBindingの値を評価します。</p>
    <h3 id="11-1-2-">11.1.2 識別子参照</h3>
    <p>　識別子は、 10.3.1 で記述したように識別子解決を実行することによって評価されます。 識別子を評価した結果は、常にReference型の値となります。</p>
    <h3 id="11-1-3-">11.1.3 リテラル参照</h3>
    <p>　リテラルは、7.8 で説明したように評価されます。</p>
    <h3 id="11-1-4-">11.1.4 配列イニシャライザー</h3>
    <p>　配列イニシャライザーは、リテラルの書式で書かれたArrayオブジェクトの初期化を説明する式です。 それは、角ブラケットで括られた各配列要素を表すゼロ以上の式の列挙です。 要素は、リテラルとする必要はなく、それらは配列イニシャライザーが評価される度に評価されます。</p>
    <p>　配列要素は、要素リストの先頭、中間や末尾で省略される場合があります。 要素リスト内にあるカンマは、いかなる場合にもAssignmentExpressionによって先行される(例：他のカンマの前や後にカンマがある)ことはなく、不完全な配列要素は、配列の長さと要素の添え字のインデックスの増加に影響(寄与)します。 省略した配列要素は定義されません。 配列の末尾にある要素が省略される場合、その要素は、その配列・リストの長さに影響しません。</p>
<pre><code>【構文】
    ArrayLiteral :
    [ Elisionopt ]
    [ ElementList ]
    [ ElementList , Elisionopt ]

    ElementList :
    Elisionopt AssignmentExpression
    ElementList , Elisionopt AssignmentExpression

    Elision :
    ,
    Elision ,
</code></pre><p>【セマンティクス】</p>
    <p>　プロダクション ArrayLiteral : [ Elisionopt ] は次のように評価されます。</p>
<pre><code>1. array は、配列が名前付き標準組み込みコンストラクタとなる式 new Array() であるかのように新たなオブジェクトを生成したものを結果とする
    2. pad は、Elisionを評価したものを結果とし、存在しない場合には、数値ゼロを使用
    3.引数 &quot;length &quot;、pad 、false を伴う配列の[[Put]]内部メソッドを呼ぶ
    4. array を返す
</code></pre><p>　プロダクション ArrayLiteral : [ ElementList ] は、次のように評価されます。</p>
<pre><code>1.ElementListを評価した結果を返す
</code></pre><p>　プロダクション ArrayLiteral : [ ElementList , Elisionopt ] は、次のように評価されます。</p>
<pre><code>1. array は、ElementListを評価した結果とする
    2. pad は、Elisionを評価した結果とし、存在しなければ、数値ゼロを使用
    3. len は、引数 &quot;length &quot; を伴う配列の[[Get]]内部メソッドを呼び結果とする
    4.引数 &quot;length &quot; 、ToUint32(pad+len)、false を伴う配列の[[Put]]内部メソッドを呼ぶ
    5. array を返す
</code></pre><p>　プロダクション ElementList : Elisionopt AssignmentExpression は、次のように評価されます。</p>
<pre><code>1. array は、名前付き標準組み込みコンストラクタである配列となる式 new Array() によるかのように新たなオブジェクトを生成したものを結果とする
    2. firstIndex は、Elisionを評価したものを結果とし、存在しない場合、数値ゼロを使用
    3. initResult は、AssignmentExpressionを評価した結果とする
    4. initValue は、 GetValue(initResult) とする
    5.引数 ToString(firstIndex)、プロパティ記述子 { [[Value]]: initValue, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}、falseを伴う配列の[[DefineOwnProperty]]内部メソッドを呼ぶ
    6. array を返す
</code></pre><p>　プロダクション ElementList : ElementList , Elisionopt AssignmentExpression は、次のように評価されます。</p>
<pre><code>1. array は、ElementListを評価したものを結果とする
    2. pad は、Elisionを評価したものを結果とし、存在しない場合、数値ゼロを使用
    3. initResult は、AssignmentExpressionを評価した結果とする
    4. initValue は、GetValue(initResult) とする
    5. len は、引数 &quot;length &quot;を伴う配列の[[Get]]内部メソッドを呼び結果とする
    6.引数 ToString(ToUint32((pad+len)) 、プロパティ記述子 { [[Value]]: initValue, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}、falseを伴う配列の[[DefineOwnProperty]]内部メソッドを呼ぶ
    7. array を返す
</code></pre><p>　プロダクション Elision : , は、次のように評価されます。</p>
<pre><code>1.数値1を返す
</code></pre><p>　プロダクション Elision : Elision , は、次のように評価されます。</p>
<pre><code>1. preceding は、Elisionを評価した結果とする
    2. preceding+1 を返す
</code></pre><p>[注釈]</p>
    <p>　[[DefineOwnProperty]] は、[[Put]]を使って新たな自身のプロパティを生成することを阻む方法において変更される標準組み込みArrayプロトタイプオブジェクトでさえ、当該配列において定義される自身のプロパティを確保する為に使用されます。</p>
    <h3 id="11-1-5-">11.1.5 オブジェクトイニシャライザー</h3>
    <p>　オブジェクトイニシャライザーは、リテラルに似た書式で書かれるオブジェクトの初期化を説明する式です。 それは、波カッコで括られたゼロ以上のプロパティ名の組と関連値のリストです。 その値は、リテラルにする必要はなく、オブジェクトイニシャライザーが評価されるごとに評価されます。</p>
<pre><code>【構文】
    ObjectLiteral :
    { }
    { PropertyNameAndValueList }
    { PropertyNameAndValueList , }

    PropertyNameAndValueList :
    PropertyAssignment
    PropertyNameAndValueList , PropertyAssignment

    PropertyAssignment :
    PropertyName : AssignmentExpression
    get PropertyName ( ) { FunctionBody }
    set PropertyName ( PropertySetParameterList ) { FunctionBody }

    PropertyName :
    IdentifierName
    StringLiteral
    NumericLiteral

    PropertySetParameterList :
    Identifier
</code></pre><p>【セマンティクス】</p>
    <p>　プロダクション ObjectLiteral : { } は、次のように評価されます。</p>
<pre><code>1.名前付き標準組み込みコンストラクタであるObjectとなる式 new Object() によるかのように生成した新たなオブジェクトを返す
</code></pre><p>　プロダクション ObjectLiteral : { PropertyNameAndValueList } と ObjectLiteral : { PropertyNameAndValueList ,} は、次のように評価されます。</p>
<pre><code>1.PropertyNameAndValueListを評価した結果を返す
</code></pre><p>　プロダクション PropertyNameAndValueList : PropertyAssignment は、次のように評価されます。</p>
<pre><code>1. obj は、名前付き標準組み込みコンストラクタであるObjectとなる式 new Object() によるかのように新たなオブジェクトを生成した結果とする
    2. propId は、PropertyAssignmentを評価した結果とする
    3.引数 propId.name、propId.descriptor、falseを伴う obj の[[DefineOwnProperty]]内部メソッドを呼ぶ
    4. obj を返す
</code></pre><p>　プロダクション PropertyNameAndValueList : PropertyNameAndValueList , PropertyAssignment は、次のように評価されます。</p>
<pre><code>1. obj は、PropertyNameAndValueListを評価した結果とする
    2. propId は、PropertyAssignmentを評価した結果とする
    3. previous は、引数 propId.name を伴う obj の[[GetOwnProperty]]内部メソッドを呼び結果とする
    4. previous がundefinedではない場合、次の何れかの条件がtrueである場合、SyntaxError例外を投げる(スローする)
    a.strict(厳格)コードとIsDataDescriptor(previous)に含まれるプロダクションが true 且つ、 IsDataDescriptor(propId.descriptor) が true
    b. IsDataDescriptor(previous) が true 且つ、 IsAccessorDescriptor(propId.descriptor) が true
    c. IsAccessorDescriptor(previous)  が true 且つ、IsDataDescriptor(propId.descriptor) が true
    d. IsAccessorDescriptor(previous) が true 且つ、 IsAccessorDescriptor(propId.descriptor) が true、且つ、 previous と propId.descriptor の双方何れかが[[Get]]項目を持つか、または previous と propId.descriptor の双方何れかが[[Set]]項目を持つ
    5.引数 propId.name、propId.descriptor、falseを伴う obj の[[DefineOwnProperty]]内部メソッドを呼ぶ
    6. obj を返す
</code></pre><p>　もし、上記ステップがSyntaxErrorを投げる(スローする)場合には、実装は、初期エラー(第16項)としてそのエラーを扱わなければいけません。</p>
    <p>プロダクション PropertyAssignment : PropertyName : AssignmentExpression は、次のように評価されます。</p>
<pre><code>1. propName は、PropertyNameを評価した結果とする
    2. exprValue は、AssignmentExpressionを評価した結果とする
    3. propValue  は、 GetValue(exprValue) とする
    4. desc は、プロパティ記述子 {[[Value]]: propValue, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true} とする
    5.プロパティ識別子(propName、desc)を返す
</code></pre><p>　プロダクション PropertyAssignment : get PropertyName ( ) { FunctionBody } は、次のように評価されます。</p>
<pre><code>1. propName は、PropertyNameを評価した結果とする
    2. closure は、カラのパラメータリストとFunctionBodyによって指定した body を伴い、 13.2 で指定したように新たなFunctionオブジェクトを生成した結果とする
    Scope のように実行中の実行コンテキストのLexicalEnvironment内で渡す
    PropertyAssignment が、strict(厳格)コード内に含まれたり、そのFunctionBodyが、strict(厳格)コードである場合にはStrictフラグがtrueの場合に渡す
    3. desc は、プロパティ記述子 {[[Get]]: closure, [[Enumerable]]: true, [[Configurable]]: true} とする
    4.プロパティ識別子(propName、desc)を返す
</code></pre><p>　プロダクション PropertyAssignment : set PropertyName ( PropertySetParameterList ) { FunctionBody } は、次のように評価されます。</p>
<pre><code>1. propName は、PropertyNameを評価した結果とする
    2. closure は、PropertySetParameterListによって指定したパラメータとFunctionBodyによって指定した body を伴い、 13.2 で指定したように新たなFunctionオブジェクトを生成した結果とする
    その Scope として実行中の実行コンテキストのLexicalEnvironment内で渡す
    PropertyAssignment が、strict(厳格)コード内に含まれたり、そのFunctionBodyが、strict(厳格)コードである場合にはStrictフラグがtrueの場合に渡す
    3. desc は、プロパティ記述子 {[[Set]]: closure, [[Enumerable]]: true, [[Configurable]]: true} とする
    4.プロパティ識別子(propName、desc)を返す
</code></pre><p>　識別子 “eval” や識別子 “arguments” が、strict(厳格)コード内に含まれたり、そのFunctionBodyがstrict(厳格)コードであるPropertyAssignmentのPropertySetParameterList内にある識別子として現れる場合、それは、SyntaxErrorです。</p>
    <p>　プロダクション PropertyName : IdentifierName は、次のように評価されます。</p>
<pre><code>1.IdentifierNameとして同じ文字の並びを含むString型の値を返す
</code></pre><p>　プロダクション PropertyName : StringLiteral は、次のように評価されます。</p>
<pre><code>1.StringLiteral の SV を返す
</code></pre><p>　プロダクション PropertyName : NumericLiteral は、次のように評価されます。</p>
<pre><code>1. nbr は、NumericLiteralの値を形成した結果とする
    2. ToString(nbr) を返す
</code></pre><h3 id="11-1-6-">11.1.6 グループ化演算子</h3>
    <p>　プロダクション PrimaryExpression : ( Expression ) は、次のように評価されます。</p>
<pre><code>1.Expressionを評価した結果を返す
    これはReference型になる場合もある
</code></pre><p>[注釈]</p>
    <p>　このアルゴリズムは、GetValueには、Expressionを評価した結果を適用しません。 これについての主な動機は、deleteやtypeofといったような演算子は、カッコ付きの式を適用される場合がある為です。</p>
    <h2 id="11-2-left-hand-side-expressions-standard-ecma-262-5-1-edition">11.2 左辺式 / Left-Hand-Side Expressions / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="11-">11 式</h3>
    <h3 id="11-2-">11.2 左辺式</h3>
<pre><code>【構文】
    MemberExpression :
    PrimaryExpression
    FunctionExpression
    MemberExpression [ Expression ]
    MemberExpression .IdentifierName
    new MemberExpression Arguments

    NewExpression :
    MemberExpression
    new NewExpression

    CallExpression :
    MemberExpression Arguments
    CallExpression Arguments
    CallExpression [ Expression ]
    CallExpression .

    IdentifierName Arguments :
    ()
    ( ArgumentList )

    ArgumentList :
    AssignmentExpression
    ArgumentList , AssignmentExpression

    LeftHandSideExpression :
    NewExpression
    CallExpression
</code></pre><h3 id="11-2-1-">11.2.1 プロパティアクセサ</h3>
    <p>　プロパティは、何れかのドット記法を使って、</p>
<pre><code>MemberExpression .IdentifierName
    CallExpression .IdentifierName
</code></pre><p>または、ブラケット記法を使って</p>
<pre><code>MemberExpression [ Expression ]
    CallExpression [ Expression ]
</code></pre><p>名称でアクセスされます。</p>
    <p>　ドット記法は、次の構文変換によって説明されます。</p>
<pre><code>MemberExpression .IdentifierName
</code></pre><p>は、</p>
<pre><code>MemberExpression [ &lt;identifier-name-string&gt; ]
</code></pre><p>とその振る舞いが同じであり、また、似たようなものとして</p>
<pre><code>CallExpression .IdentifierName
</code></pre><p>は、</p>
<pre><code>CallExpression [ &lt;identifier-name-string&gt; ]
</code></pre><p>とその振る舞いが同じで</p>
<pre><code>&lt;identifier-name-string&gt;
</code></pre><p>は、IdentifierNameとしてUnicodeエスケープシーケンス処理の後に来る同じ文字の並びを含む文字列リテラルです。</p>
    <p>　プロダクション</p>
<pre><code>MemberExpression : MemberExpression [ Expression ]
</code></pre><p>は、次のように評価されます。</p>
<pre><code>1. baseReference は、MemberExpressionを評価した結果とする
    2. baseValue は、GetValue(baseReference) とする
    3. propertyNameReference は、Expressionを評価した結果とする
    4. propertyNameValue は、 GetValue(propertyNameReference) とする
    5. CheckObjectCoercible(baseValue) を呼ぶ
    6. propertyNameString は、 ToString(propertyNameValue) とする
    7.評価中の構文上のプロダクションがstrict(厳格)モードのコード内に含まれる場合、 strict は、true、それ以外は、 strict は、false
    8.基準値がbaseValue、参照名がpropertyNameString、strict(厳格)モードフラグがstrictであるReference型の値を返す
</code></pre><p>　プロダクション</p>
<pre><code>CallExpression : CallExpression [ Expression ]
</code></pre><p>は、ステップ1で評価されるCallExpressionを含む場合を除き、全く同じ方法で評価されます。</p>
    <h3 id="11-2-2-new-">11.2.2 new 演算子</h3>
    <p>　プロダクション</p>
<pre><code>NewExpression : new NewExpression
</code></pre><p>は、次のように評価されます。</p>
<pre><code>1. ref は、NewExpressionを評価した結果とする
    2. constructor は、 GetValue(ref) とする
    3. Type(constructor) が、Objectでない場合には、TypeError例外を投げる(スローする)
    4. constructor が[[Construct]]内部メソッドを実装しない場合には、TypeError例外を投げる(スローする)
    5. 引数を何も渡さず(引数のリストがカラのまま)constructor における[[Construct]]内部メソッドを呼んだ結果を返す
</code></pre><p>　プロダクション</p>
<pre><code>MemberExpression : new MemberExpression Arguments
</code></pre><p>は、次のように評価されます。</p>
<pre><code>1. ref は、MemberExpressionを評価した結果とする
    2. constructor は、 GetValue(ref) とする
    3. argList は、引数値の内部リスト(11.2.4)を生成中にArgumentsを評価した結果とする
    4. Type(constructor) が、Objectではない場合、TypeError例外を投げる(スローする)
    5. constructor が、[[Construct]]内部メソッドを実行しない場合、TypeError例外を投げる(スローする)
    6. 引数の値としてリスト argList を渡し、constructor における[[Construct]]内部メソッドを呼んだ結果を返す
</code></pre><h3 id="11-2-3-">11.2.3 関数呼び出し／ファンクションコール</h3>
    <p>　プロダクション</p>
<pre><code>CallExpression : MemberExpression Arguments
</code></pre><p>は、次のように評価されます。</p>
<pre><code>1. ref は、MemberExpressionを評価した結果とする
    2. func は、GetValue(ref) とする
    3. argList は、Argumentsを評価した結果とし、引数の値の内部リストを生成 ( 11.2.4 参照 )
    4. Type(func) がObjectではない場合、TypeError例外を投げる(スローする)
    5. IsCallable(func) が、falseである場合、TypeError例外を投げる(スローする)
    6. Type(ref) が、Referenceである場合、
    a. IsPropertyReference(ref) が trueである場合、
    i. thisValue は、 GetBase(ref) とする
    b. それ以外の場合で ref の基準が、環境レコードである場合、
    i. thisValue は、 GetBase(ref) の具体的なメソッド ImplicitThisValue を呼んだ結果とする
    7.それ以外の場合で Type(ref) がReferenceではない場合、
    a. thisValue は、undefinedとする
    8.引数の値であるリスト argList 、this 値としてthisValue を渡し、 func における[[Call]]内部メソッドを呼んだ結果を返す
</code></pre><p>　プロダクション</p>
<pre><code>CallExpression : CallExpression Arguments
</code></pre><p>は、ステップ1で評価されるCallExpressionを含む場合を除き、全く同じ方法で評価されます。</p>
    <p>[注釈]</p>
    <p>　返した結果は、 func が、ネイティブなECMAScriptオブジェクである場合、Reference型となることは決してありません。 ホストオブジェクトを呼ぶ場合は常に実装依存であるReference型の値を返すことができます。 Reference型の値が返される場合、非strict(厳格)なProperty Reference(プロパティ参照)にしなければいけません。</p>
    <h3 id="11-2-4-">11.2.4 引数リスト</h3>
    <p>　引数リストの評価は、値のリストを生成します( 8.8 参照)。</p>
    <p>　プロダクション</p>
<pre><code>Arguments : ( )
</code></pre><p>は、次のように評価されます。</p>
<pre><code>1.カラのListを返す
</code></pre><p>　プロダクション</p>
<pre><code>Arguments : ( ArgumentList )
</code></pre><p>は、次のように評価されます。</p>
<pre><code>1.ArgumentListを評価した結果を返す
</code></pre><p>　プロダクション</p>
<pre><code>ArgumentList : AssignmentExpression
</code></pre><p>は、次のように評価されます。</p>
<pre><code>1. ref は、AssignmentExpressionを評価した結果とする
    2. arg は、 GetValue(ref) とする
    3.唯一のアイテムが、 arg であるListを返す
</code></pre><p>　プロダクション</p>
<pre><code>ArgumentList : ArgumentList , AssignmentExpression
</code></pre><p>は、次のように評価されます。</p>
<pre><code>1. precedingArgs は、ArgumentListを評価した結果とする
    2. ref は、AssignmentExpressionを評価した結果とする
    3. arg は、 GetValue(ref) とする
    4. precedingArgs の長さより長く、新たなリストの最後のアイテムである arg によって末尾に続くことにより、precedingArgs のアイテムであるアイテムを持つ List を返す
</code></pre><h3 id="11-2-5-">11.2.5 関数式</h3>
    <p>　プロダクション</p>
<pre><code>MemberExpression : FunctionExpression
</code></pre><p>は、次のように評価されます。</p>
<pre><code>1. FunctionExpression を評価した結果を返す
</code></pre><h2 id="11-3-postfix-expressions-standard-ecma-262-5-1-edition">11.3 後置式 / Postfix Expressions / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="11-">11 式</h3>
    <h3 id="11-3-">11.3 後置式</h3>
<pre><code>【構文】
    PostfixExpression :
    LeftHandSideExpression
    LeftHandSideExpression [no LineTerminator here] ++
    LeftHandSideExpression [no LineTerminator here] --
</code></pre><h3 id="11-3-1-">11.3.1 後置増分演算子</h3>
    <p>　プロダクション</p>
<pre><code>PostfixExpression : LeftHandSideExpression [no LineTerminator here] ++
</code></pre><p>は、次のように評価されます。</p>
<pre><code>1. lhs は、LeftHandSideExpressionを評価した結果とする
    2.続く条件が全て true である場合、SyntaxError例外を投げる(スローする)
    ・Referenceである Type(lhs) が、true
    ・IsStrictReference(lhs) が、true
    ・Type(GetBase(lhs)) が、環境レコード
    ・GetReferencedName(lhs)が、 &quot;eval&quot; または &quot;arguments&quot; の何れか
    3. oldValue は、 ToNumber(GetValue(lhs)) とする
    4. newValue は、 + 演算子( 11.6.3 参照)における同様のルールを使っている間、oldValueに値 1 を追加した結果とする
    5. PutValue(lhs, newValue)を呼ぶ
    6. oldValue を返す
</code></pre><h3 id="11-3-2-">11.3.2 後置減分演算子</h3>
    <p>　プロダクション</p>
<pre><code>PostfixExpression : LeftHandSideExpression [no LineTerminator here] --
</code></pre><p>は、次のように評価されます。</p>
<pre><code>1. lhs は、LeftHandSideExpressionを評価した結果とする
    2.続く条件が全て trueである場合、SyntaxError例外を投げる(スローする)
    ・ReferenceであるType(lhs)が、 true
    ・IsStrictReference(lhs)が、 true
    ・Type(GetBase(lhs))が、環境レコード
    ・GetReferencedName(lhs) が &quot;eval&quot; または &quot;arguments&quot; の何れか
    3. oldValue は、 ToNumber(GetValue(lhs)) とする
    4. newValue は、当該演算子における同様のルール(11.6.3)を使用中は、oldValue から 1 を引いた結果とする
    5.PutValue(lhs, newValue)を呼ぶ
    6. oldValue を返す
</code></pre><h2 id="11-4-unary-operators-standard-ecma-262-5-1-edition">11.4 単項演算子 / Unary Operators / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="11-">11 式</h3>
    <h3 id="11-4-">11.4 単項演算子</h3>
<pre><code>【構文】
    UnaryExpression :
    PostfixExpression
    delete UnaryExpression
    void UnaryExpression
    typeof UnaryExpression
    ++ UnaryExpression
    -- UnaryExpression
    + UnaryExpression
    - UnaryExpression
    ~ UnaryExpression
    ! UnaryExpression
</code></pre><h3 id="11-4-1-delete-">11.4.1 delete 演算子</h3>
    <p>　プロダクション</p>
<pre><code>UnaryExpression : delete UnaryExpression
</code></pre><p>は、次のように評価されます。</p>
<pre><code>1. ref は、UnaryExpressionを評価した結果とする
    2. Type(ref) がReferenceではない場合、trueを返す
    3. IsUnresolvableReference(ref) が、trueである場合、
    a. IsStrictReference(ref)が、trueである場合、SyntaxError例外を投げる(スローする)
    b.それ以外の場合、trueを返す
    4. IsPropertyReference(ref) が、trueである場合、
    a.引数として GetReferencedName(ref) と IsStrictReference(ref) を渡し、 ToObject(GetBase(ref)) における[[Delete]]内部メソッドを呼んだ結果を返す
    5.それ以外の場合、 ref は、環境レコードバインディングへの参照である為、
    a. IsStrictReference(ref) が、trueである場合、SyntaxError例外を投げる(スローする)
    b. bindingsは、 GetBase(ref) とする
    c.引数として GetReferencedName(ref) を渡し、バインディングの具体的なメソッドDeleteBindingを呼んだ結果を返す
</code></pre><p>[注釈]</p>
    <p>　delete演算子が、strict(厳格)モードのコード内で現れる場合、そのUnaryExpression(単項式)が、変数、関数の引数、関数名等への直接参照である場合、SyntaxError例外が投げられ(スローされ)ます。 追記するとdelete演算子が、strict(厳格)モードのコード内で現れる場合で且つ、削除されるプロパティが属性 { [[Configurable]]: false } を持つ場合、TypeError例外が投げられ(スローされ)ます。</p>
    <h3 id="11-4-2-void-">11.4.2 void 演算子</h3>
    <p>　プロダクション</p>
<pre><code>UnaryExpression : void UnaryExpression
</code></pre><p>は、次のように評価されます。</p>
<pre><code>1. expr は、UnaryExpressionを評価した結果とする
    2. GetValue(expr) を呼ぶ
    3. undefined を返す
</code></pre><p>[注釈]</p>
    <p>　GetValueは、観測可能な副作用を持つ場合がある為、その値は使用されませんが、呼ばれなければいけません。</p>
    <h3 id="11-4-3-typeof-">11.4.3 typeof 演算子</h3>
    <p>　プロダクション</p>
<pre><code>UnaryExpression : typeof UnaryExpression
</code></pre><p>は、次のように評価されます。</p>
<pre><code>1. val は、UnaryExpressionを評価した結果とする
    2. Type(val) がReferenceである場合、
    a. IsUnresolvableReference(val) が、trueであれば、&quot;undefined&quot;を返す
    b. val は、 GetValue(val) とする
    3.Table 20による Type(val) によって決まるString型を返す

    Table 20 -- typeof 演算子の結果
    ------------------------------------------------------------------------------------------------------------------------------------
    val の型                          結果
    ------------------------------------------------------------------------------------------------------------------------------------
    Undefined                           &quot;boolean&quot;
    Null                                &quot;object&quot;
    Number                              &quot;number&quot;
    Boolean                             &quot;boolean&quot;
    String                              &quot;string&quot;
    Object (ネイティブ且つ[[Call]]を実装しない)          &quot;object&quot;
    Object (ネイティブかホストで且つ[[Call]]を実装しない)     &quot;function&quot;
    Object (ホストで且つ[[Call]]を実装しない)           &quot;undefined&quot;、&quot;boolean&quot;、&quot;number&quot;、&quot;string&quot;となる場合を除き、実装定義
    ------------------------------------------------------------------------------------------------------------------------------------
</code></pre><h3 id="11-4-4-">11.4.4 前置増分演算子</h3>
    <p>　プロダクション</p>
<pre><code>UnaryExpression : ++ UnaryExpression
</code></pre><p>は、次のように評価されます。</p>
<pre><code>1. expr は、UnaryExpressionを評価した結果とする
    2.次の条件が全て true である場合、SyntaxError例外を投げる(スローする)
    ・ReferenceであるType(expr) が、true
    ・IsStrictReference(expr) が、true
    ・Type(GetBase(expr)) が、Environment Record(環境レコード)
    ・GetReferencedName(expr) が、 &quot;eval&quot; または &quot;arguments&quot; の何れか
    3. oldValue は、 ToNumber(GetValue(expr)) とする
    4. newValue は、 + 演算子( 11.6.3 参照)であるものとして同様のルールを使って oldValue に1を加えたものを結果とする
    5. PutValue(expr, newValue) を呼ぶ
    6. newValue を返す
</code></pre><h3 id="11-4-5-">11.4.5 前置減分演算子</h3>
    <p>　プロダクション</p>
<pre><code>UnaryExpression : -- UnaryExpression
</code></pre><p>は、次のように評価されます。</p>
<pre><code>1. expr は、UnaryExpressionを評価した結果とする
    2.次の条件が全て true である場合、SyntaxError例外を投げる(スローする)
    ・ReferenceであるType(expr) が、true
    ・IsStrictReference(expr) が、true
    ・Type(GetBase(expr)) が、環境レコード
    ・GetReferencedName(expr) が、 &quot;eval&quot; または &quot;arguments&quot; の何れか
    3. oldValue は、 ToNumber(GetValue(expr)) とする
    4. newValue は、その - 演算子( 11.6.3 参照)と同様のルールを使って oldValue から値 1 を引いた結果とする
    5. PutValue(expr, newValue) を呼ぶ
    6. newValue を返す
</code></pre><h3 id="11-4-6-">11.4.6 単項 + 演算子</h3>
    <p>　単項 + (加算)演算子は、当該オペランドをNumber型に変換します。</p>
    <p>　プロダクション</p>
<pre><code>UnaryExpression : + UnaryExpression
</code></pre><p>は、次のように評価されます。</p>
<pre><code>1. expr は、UnaryExpressionを評価した結果とする
    2. ToNumber(GetValue(expr)) を返す
</code></pre><h3 id="11-4-7-">11.4.7 単項 - 演算子</h3>
    <p>　単項 - (減算)演算子は、当該オペランドをNumber型に変換し、それを否定します。 注記として+0の否定は-0を生成し、-0の否定は+0を生成します。</p>
    <p>　プロダクション</p>
<pre><code>UnaryExpression : - UnaryExpression
</code></pre><p>は、次のように評価されます。</p>
<pre><code>1. expr は、UnaryExpressionを評価した結果とする
    2. oldValue は、 ToNumber(GetValue(expr)) とする
    3. oldValue が、NaNである場合、NaNを返す
    4. oldValue を否定したものを結果として返す、つまり、同じ大きさであるNumber型の値を生成するが、符号は反対となるという意味
</code></pre><h3 id="11-4-8-not-">11.4.8 ビット単位の NOT 演算子 ( ~ )</h3>
    <p>　プロダクション</p>
<pre><code>UnaryExpression : ~ UnaryExpression
</code></pre><p>は、次のように評価されます。</p>
<pre><code>1. expr は、UnaryExpressionを評価した結果とする
    2. oldValue は、 ToInt32(GetValue(expr)) とする
    3. oldValueにビット単位の補数を適用した結果を返す、その結果は、符号付き 32ビット整数
</code></pre><h3 id="11-4-9-not-">11.4.9 論理 NOT 演算子 ( ! )</h3>
    <p>　プロダクション</p>
<pre><code>UnaryExpression : ! UnaryExpression
</code></pre><p>は、次のように評価されます。</p>
<pre><code>1. expr は、UnaryExpressionを評価した結果とする
    2. oldValue は、 ToBoolean(GetValue(expr))とする
    3. oldValue が、trueである場合、falseを返す
    4. true を返す
</code></pre><h2 id="11-5-multiplicative-operators-standard-ecma-262-5-1-edition">11.5 乗法演算子 / Multiplicative Operators / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="11-">11 式</h3>
    <h3 id="11-5-">11.5 乗法演算子</h3>
<pre><code>【構文】
    MultiplicativeExpression :
    UnaryExpression
    MultiplicativeExpression * UnaryExpression
    MultiplicativeExpression / UnaryExpression
    MultiplicativeExpression % UnaryExpression

    【セマンティクス】

    プロダクション @が上記定義内の演算子の1つに当てはまる MultiplicativeExpression : MultiplicativeExpression @ UnaryExpression は、次のように評価されます。

    1. left は、MultiplicativeExpressionを評価した結果とする
    2. leftValue は、 GetValue(left) とする
    3. right は、UnaryExpressionを評価した結果とする
    4. rightValue は、 GetValue(right) とする
    5. leftNum は、 ToNumber(leftValue) とする
    6. rightNum は、 ToNumber(rightValue) とする
    7. leftNum と rightNum に指定した演算子(*, /, or %)を適用した結果を返す、11.5.1, 11.5.2, 11.5.3、それぞれの下にある注記参照。
</code></pre><h3 id="11-5-1-">11.5.1 * 演算子を適用</h3>
    <p>　 * (乗算)演算子は、乗算を実行し、当該オペランドのプロダクションを生成します。 乗算は、可換性(順序を入れ替えても結果が変わらない・順序の入れ替えが可能である性質)があります。 乗算は、有限精度である為、常にECMAScript内で関連付けられるというわけではありません。 浮動小数点の乗算の結果は、『IEEE 754 binary double-precision arithmetic / バイナリ(二進)倍精度演算』の規則によって規定されています。</p>
    <ul>
        <li>何れかのオペランドが、NaNである場合、その結果は、 NaNです。</li>
        <li>結果の符合は、双方のオペランドが、同じ符号を持つ場合、正、異なる符号を持つオペランドである場合、負です。</li>
        <li>ゼロによる無限大の乗算の結果は、NaNの中にあります(NaNです)</li>
        <li>無限大による無限大の乗算の結果は、無限大であり、その符号は、既に上記で述べた規則によって決定されます。</li>
        <li>非ゼロの値である無限大による無限大の乗算の結果は、符号付き無限大であり、その符号は、既に上記で述べた規則によって決定されます。</li>
        <li><p>無限大やNaNの何れかが関係する残りのケースについては、プロダクションが算出され、『IEEE 754 round-to-nearest mode / 近似値への丸め(処理)モード』を使用して表示値に最も近い値に丸められ、大きさが、表示するには大きすぎる場合、その結果は、適切な符号から成る無限大、大きさが表示するには小さすぎる場合、その結果は、適切な符号から成る1つのゼロです。ECMAScript言語は、 IEEE 754 によって定義したように漸次(的)アンダーフローのサポートを要求します。</p>
            <p>[付記]
                <em>漸次(的) / gradualとは、「次第に」、「徐々に」、「だんだん」という意味。
                </em>アンダーフローとは、四則演算や数学関数による演算結果が正規化された浮動小数点データ型数値における絶対値の最小範囲を下回る際に発生(、ちなみにオーバーフローは浮動小数点演算の丸め処理の結果、絶対値が表示上の最大有限数を超える際に発生)。
                *漸次(的)アンダーフローとは、最小範囲を下回る際に正規化する際、わずかながら正規化しきれない範囲があり、その範囲においては微妙に精度が失われることがあることを指す。</p>
        </li>
    </ul>
    <h3 id="11-5-2-">11.5.2 / 演算子を適用</h3>
    <p>　 / (除算)演算子は、除算を実行し、プロダクションは、当該オペランドの商を生成します。 左オペランドは被除数、右オペランドは除数です。 ECMAScriptは、整数除算を実行しません。 オペランドと全ての除算操作の結果は、倍精度浮動小数点数です。 除算の結果は、『IEEE 754 arithmetic / 演算』の仕様によって決められます。</p>
    <ul>
        <li>何れかのオペランドが、NaNである場合、その結果はNaNです。</li>
        <li>結果の符合は、両方のオペランドが同じ符号であれば正、異なる符号であれば負です。</li>
        <li>無限大による無限大の除算の結果はNaNの中にあります(NaNです)。</li>
        <li>ゼロによる無限大の除算の結果は、無限大の中にあり(無限大であり)、その符号は、既に上記で述べた規則によって決定されます。</li>
        <li>非ゼロの無限大の値による無限大の除算の結果は、符号付き無限大の中にあり(符号付き無限大であり)、その符号は、既に上記で述べた規則によって決定されます。</li>
        <li>無限大による有限の除算の結果は、ゼロの中にあり(ゼロであり)、その符号は、既に上記で述べた規則によって決定されます。</li>
        <li>ゼロによるゼロの除算の結果は、NaNの中にあり(NaNであり)、他の一部の無限大の値によるゼロの除算はゼロの中にあり(ゼロであり)、その符号は、既に上記で述べた規則によって決定されます。</li>
        <li>ゼロによる非ゼロの無限大の値の除算の結果は、符号付き無限大の中にあり(符号付き無限大であり)、その符号は、既に上記で述べた規則によって決定されます。</li>
        <li>無限大、ゼロ、NaNの何れかが含まれる残りのケースについては、 その商が算出され、『IEEE 754 round-to-nearest mode / 近似値への丸め(処理)モード』を使用して表示値に最も近い値に丸められ、大きさが、表示するには大きすぎる場合、その操作はオーバーフローであり、その結果は、適切な符号から成る無限大、大きさが表示するには小さすぎる場合、その操作はアンダーフローであり、その結果は、適切な符号から成る1つのゼロです、ECMAScript言語は、 IEEE 754 によって定義したように漸次(的)アンダーフローのサポートを要求します。</li>
    </ul>
    <h3 id="11-5-3-">11.5.3 % 演算子を適用</h3>
    <p>　 % (剰余)演算子の暗黙的な除算から当該オペランドの残りをもたらし(剰余を生成し)、左オペランドは被除数、右オペランドは除数です。</p>
    <p>[注釈]</p>
    <p>　C/C++では、剰余演算子は、積分オペランドだけを許容しますが、ECMAScriptでは、浮動小数点オペランドも併せて許容します。</p>
    <p>　 % 演算子によって算出したものとする浮動小数点剰余演算子の結果は、 IEEE 754 で定義した“remainder”演算子と同一ではありません。 丸め除算から剰余を算出する IEEE 754 の“remainder”演算子は、切り捨て除算ではなく、その為、その動作は、通常、整数剰余演算と同質ではありません。 代わりにECMAScript言語は、Java の整数剰余演算子と類似した方法で動作する為の浮動小数点操作における % を定義します、尚、これはCライブラリ関数 fmod と比較される場合があります。 ECMAScriptの浮動小数点剰余演算子の結果は、『IEEE arithmetic / 演算』によって決定されます。</p>
    <ul>
        <li>何れかのオペランドが、NaNである場合、その結果はNaNです。</li>
        <li>結果の符号は、除算の符号と同等です。</li>
        <li>被除数が無限大であったり、除数がゼロであったり、それら両方である場合、結果は、 NaNです。</li>
        <li>被除数が無限大かつ除数が無限大である場合、その結果は被除数と同等です。</li>
        <li>被除数がゼロで且つ除数が非ゼロで無限大である場合、その結果は、被除数と同等です。</li>
        <li>無限大、ゼロ、NaNの何れかが関係する残りのケースについては、除数 n と除数 d から成る浮動小数点剰余 r は、 n/d が負である場合に負、 n/d が正である場合に正であり、算出された n と d. r の数学的な商を真とする大きさを超えることなく可能な限り同じ大きさであり、『IEEE 754 round-to-nearest mode / 近似値への丸め(処理)モード』を使用した表示値に最も近くなる丸め(処理)である整数 q という場合において数学的関係 r = n - (d x q) によって定義されます。</li>
    </ul>
    <h2 id="11-6-additive-operators-standard-ecma-262-5-1-edition">11.6 加法演算子 / Additive Operators / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="11-">11 式</h3>
    <h3 id="11-6-">11.6 加法演算子</h3>
<pre><code>【構文】
    AdditiveExpression :
    MultiplicativeExpression
    AdditiveExpression + MultiplicativeExpression
    AdditiveExpression - MultiplicativeExpression
</code></pre><h3 id="11-6-1-">11.6.1 加算演算子 ( + )</h3>
    <p>　加算演算子は、文字列連結または数値加算の何れかを実行します。</p>
    <p>　プロダクション</p>
<pre><code>AdditiveExpression : AdditiveExpression + MultiplicativeExpression
</code></pre><p>は、次のように評価されます。</p>
<pre><code>1. lref は、 AdditiveExpressionを評価した結果とする
    2. lval は、 GetValue(lref) とする
    3. rref は、 MultiplicativeExpressionを評価した結果とする
    4. rval は、 GetValue(rref) とする
    5. lprim は、 ToPrimitive(lval) とする
    6. rprim は、 ToPrimitive(rval) とする
    7. Type(lprim) が、String、または、 Type(rprim) が、Stringである場合、
    a. ToString(rprim) によって続く ToString( lprim)を連結した結果であるStringを返す
    8. ToNumber(lprim) と ToNumber(rprim) に加算演算子を適用した結果を返す、11.6.3 下段注釈参照
</code></pre><p>[注釈 1]</p>
    <p>　ステップ 5 と 6 で ToPrimitive を呼ぶ中で提供されるヒントは、何もありません。 Dateオブジェクトを除く全てのネイティブなECMAScriptオブジェクトは、ヒント番号が与えられるかのようにヒントの欠如を扱います。 Dateオブジェクトは、ヒントとなる文字列が与えられるかのようにヒントの欠如を扱います。 ホストオブジェクトは、何らかの他の方法でヒントの欠如を扱う場合があります。</p>
    <p>[注釈 2]</p>
    <p>　ステップ 7 と論理AND演算子の代わりに論理OR演算子を使用することによる関係演算子( 11.8.5 )における比較アルゴリズムから成るステップ 3 とでは異なります。</p>
    <h3 id="11-6-2-">11.6.2 減算演算子 ( - )</h3>
    <p>　プロダクション</p>
<pre><code>AdditiveExpression : AdditiveExpression - MultiplicativeExpression
</code></pre><p>は、次のように評価されます。</p>
<pre><code>1. lref は、 AdditiveExpressionを評価した結果とする
    2. lval は、 GetValue(lref) とする
    3. rref は、 MultiplicativeExpressionを評価した結果とする
    4. rval は、 GetValue(rref) とする
    5. lnum は、 ToNumber(lval) とする
    6. rnum は、 ToNumber(rval) とする
    7. lnum と rnum に減算演算子を適用したものを結果として返す、11.6.3 下段注釈参照
</code></pre><h3 id="11-6-3-">11.6.3 数字に加算演算子を適用</h3>
<pre><code> + 演算子は、オペランドの合計を生成する2つの数値型のオペランドに適用する場合、加算を実行します。
    - 演算子は、2つの数値オペランドの差を生成する減算を実行します。
</code></pre><p>　加算は、可換性のある演算子ですが、常にそのように想定するというわけではありません。</p>
    <p>　加算の結果は、『IEEE 754 binary double-precision arithmetic / バイナリ(二進)倍精度演算』の規則を使用して決められます。</p>
    <ul>
        <li>何れかのオペランドが、NaNである場合、その結果は、NaNです。</li>
        <li>反対の符号を持つ2つの無限大の合計は、NaNです。</li>
        <li>同じ符号を持つ2つの無限大の合計は、その符号を持つ無限大です。</li>
        <li>無限大と無限大の合計値は、無限大のオペランドと同等です。</li>
        <li>2つの負のゼロの合計は、-0です。2つの正のゼロの合計や反対の符号を持つ2つのゼロの合計は、+0です。</li>
        <li>ゼロと非ゼロの無限大の合計は、非ゼロのオペランドと同等です。</li>
        <li>同じ大きさで反対の符号を持つ2つの非ゼロの無限大の値は、+0です。</li>
        <li>無限大、ゼロ、NaNが関係する残りのケース、そしてまたオペランドが同じ符号を持っていたり、異なる大きさを持つ場合、その合計が算出され、『IEEE 754 round-to-nearest mode / 近似値への丸め(処理)モード』を使って表示値に最も近い値に丸め(処理を行い)ます。もし、その大きさが表示値に対して大きすぎる場合には、その操作はオーバーフローであり、その結果は、適切な符号を持つ無限大です。ECMAScript言語は、 IEEE 754 によって定義したように漸次(的)アンダーフローのサポートを要求します。</li>
    </ul>
    <p>　 - 演算子は、数値型の2つのオペランドに適用する場合に減算を実行し、そのオペランドの差を生成します。左オペランドは、被減数、右オペランドは、減数です。 与えられた数値オペランド a と b において、それは a - b というケースは常に、 a + (-b) と同じ結果を生成します。</p>
    <h2 id="11-7-bitwise-shift-operators-standard-ecma-262-5-1-edition">11.7 ビット単位シフト演算子 / Bitwise Shift Operators / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="11-">11 式</h3>
    <h3 id="11-7-">11.7 ビット単位シフト演算子</h3>
<pre><code>【構文】
    ShiftExpression :
    AdditiveExpression ShiftExpression &lt;&lt; AdditiveExpression
    ShiftExpression &gt;&gt; AdditiveExpression
    ShiftExpression &gt;&gt;&gt; AdditiveExpression
</code></pre><h3 id="11-7-1-">11.7.1 左シフト演算子 ( \&lt;\&lt; )</h3>
    <p>　右オペランドで指定された量だけ左オペランドについてバイト左シフト演算を実行。</p>
    <p>　プロダクション</p>
<pre><code>ShiftExpression : ShiftExpression &lt;&lt; AdditiveExpression
</code></pre><p>は、次のように評価されます。</p>
<pre><code>1. lref は、 ShiftExpressionを評価した結果とする
    2. lval は、 GetValue(lref) とする
    3. rref は、 AdditiveExpressionを評価した結果とする
    4. rval は、 GetValue(rref) とする
    5. lnum は、 ToInt32(lval) とする
    6. rnum は、 ToUint32(rval) とする
    7. shiftCount は、 rnum の全て、最下位5ビットをマスク設定した結果とする
    つまり計算 rnum &amp; 0x1F という意味
    8. shiftCount ビット分 lnum を左シフトした結果を返す
    その結果は符号付き32ビット整数
</code></pre><h3 id="11-7-2-the-signed-right-shift-operator-">11.7.2 符号付き右シフト演算子 / The Signed Right Shift Operator ( >> )</h3>
    <p>　右オペランドで指定した量によって左オペランドについて符号付き(sign-filling)ビット単位右シフト演算を実行。</p>
    <p>　プロダクション</p>
<pre><code>ShiftExpression : ShiftExpression &gt;&gt; AdditiveExpression
</code></pre><p>は、次のように評価されます。</p>
<pre><code>1. lref は、 ShiftExpressionを評価した結果とする
    2. lval は、 GetValue(lref) とする
    3. rref は、 AdditiveExpressionを評価した結果とする
    4. rval は、 GetValue(rref) とする
    5. lnum は、 ToInt32(lval) とする
    6. rnum は、 ToUint32(rval) とする
    7. shiftCount は、 rnum の全て、最下位5ビットをマスク設定した結果とする
    つまり計算 rnum &amp; 0x1F という意味
    8. shiftCount ビットで lnum の符号拡張右シフトを実行した結果を返す
    最も重要なビットが伝達される
    その結果は、符号付き32ビット整数
</code></pre><h3 id="11-7-3-">11.7.3 符号なし右シフト演算子 ( >>> )</h3>
    <p>　右オペランドで指定された量で左オペランドについてゼロ埋めビット単位右シフト演算を実行。</p>
    <p>　プロダクション</p>
<pre><code>ShiftExpression : ShiftExpression &gt;&gt;&gt; AdditiveExpression
</code></pre><p>は、次のように評価されます。</p>
<pre><code>1. lref は、 ShiftExpressionを評価した結果とする
    2. lval は、 GetValue(lref) とする
    3. rref は、 AdditiveExpressionを評価した結果とする
    4. rval は、 GetValue(rref) とする
    5. lnum は、 ToUint32(lval) とする
    6. rnum は、 ToUint32(rval) とする
    7. shiftCount は、 rnum の全て、最下位5ビットをマスク設定した結果とする
    つまり計算 rnum &amp; 0x1F という意味
    8. shiftCount ビットで lnum のゼロ埋め右シフトを実行した結果を返す
    空いたビットはゼロで埋められる
    その結果は、符号なし32ビット整数
</code></pre><h2 id="11-8-relational-operators-standard-ecma-262-5-1-edition">11.8 関係演算子 / Relational Operators / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="11-">11 式</h3>
    <h3 id="11-8-">11.8 関係演算子</h3>
<pre><code>【構文】
    RelationalExpression :
    ShiftExpression
    RelationalExpression &lt; ShiftExpression
    RelationalExpression &gt; ShiftExpression
    RelationalExpression &lt;= ShiftExpression
    RelationalExpression &gt;= ShiftExpression
    RelationalExpression instanceof ShiftExpression
    RelationalExpression in ShiftExpression

    RelationalExpressionNoIn :
    ShiftExpression
    RelationalExpressionNoIn &lt; ShiftExpression
    RelationalExpressionNoIn &gt; ShiftExpression
    RelationalExpressionNoIn &lt;= ShiftExpression
    RelationalExpressionNoIn &gt;= ShiftExpression
    RelationalExpressionNoIn instanceof ShiftExpression
</code></pre><p>[注釈]</p>
    <p>　“NoIn”変数は、ステートメント(文)内にある演算子内に持つ関係式の中にある演算子内で紛らわしさを回避する為に必要とされます。</p>
    <p>[注記：]“NoIn”だけに注釈原文↓自体に in を多用して、こういう風に紛らわしくならないようにという意味がある模様
        The “NoIn” variants are needed to avoid confusing the in operator in a relational expression with the in operator in a for statement.</p>
    <p>【セマンティクス】</p>
    <p>　関係演算子を評価した結果は、常にBoolean型であり、2つのオペランド間で保持する演算子によって名づけられた関係かどうかに影響します。 RelationalExpressionNoIn プロダクションは、RelationalExpressionを含む代わりに評価されるRelationalExpressionNoInを含む場合を除き、RelationalExpressionプロダクションと同じ方法で評価されます。</p>
    <h3 id="11-8-1-less-than-">11.8.1 Less-than(より小さい・小なり) 演算子 ( \&lt; )</h3>
    <p>　プロダクション</p>
<pre><code>RelationalExpression : RelationalExpression &lt; ShiftExpression
</code></pre><p>は、次のように評価されます。</p>
<pre><code>1. lref は、 RelationalExpressionを評価した結果とする
    2. lval は、 GetValue(lref) とする
    3. rref は、 ShiftExpressionを評価した結果とする
    4. rval は、 GetValue(rref) とする
    5. r は、抽象関係比較  lval &lt; rval ( 11.8.5 参照)を実行した結果とする
    6. r が、undefinedである場合、falseを返す、それ以外は、r を返す
</code></pre><h3 id="11-8-2-greater-than-">11.8.2 Greater-than(より大きい・大なり) 演算子 ( > )</h3>
    <p>　プロダクション</p>
<pre><code>RelationalExpression : RelationalExpression &gt; ShiftExpression
</code></pre><p>は、次のように評価されます。</p>
<pre><code>1. lref は、 RelationalExpressionを評価した結果とする
    2. lval は、 GetValue(lref) とする
    3. rref は、 ShiftExpressionを評価した結果とする
    4. rval は、 GetValue(rref) とする
    5. r は、falseと同等の LeftFirst を伴う抽象関係比較 rval &lt; lval ( 11.8.5 参照)を実行した結果とする
    6. r が、undefinedである場合、falseを返す、それ以外は、r を返す
</code></pre><h3 id="11-8-3-less-than-or-equal-">11.8.3 Less-than-or-equal(以下) 演算子 ( \&lt;= )</h3>
    <p>　プロダクション</p>
<pre><code>RelationalExpression : RelationalExpression &lt;= ShiftExpression
</code></pre><p>は、次のように評価されます。</p>
<pre><code>1. lref は、 RelationalExpressionを評価した結果とする
    2. lval は、 GetValue(lref) とする
    3. rref は、 ShiftExpressionを評価した結果とする
    4. rval は、 GetValue(rref) とする
    5. r は、falseと同等の LeftFirst を伴う抽象関係比較 rval &lt; lval ( 11.8.5 参照)を実行した結果とする
    6. r が、trueまたはundefinedである場合、falseを返す、それ以外は、r を返す
</code></pre><h3 id="11-8-4-greater-than-or-equal-">11.8.4 Greater-than-or-equal(以上) 演算子 ( >= )</h3>
    <p>　プロダクション</p>
<pre><code>RelationalExpression : RelationalExpression &gt;= ShiftExpression
</code></pre><p>は、次のように評価されます。</p>
<pre><code>1. lref は、 RelationalExpressionを評価した結果とする
    2. lval は、 GetValue(lref) とする
    3. rref は、 ShiftExpressionを評価した結果とする
    4. rval は、 GetValue(rref) とする
    5. r は、抽象関係比較 lval &lt; rval ( 11.8.5 参照)を実行した結果とする
    6. r が、trueまたはundefinedである場合、falseを返す、それ以外は、true を返す
</code></pre><h3 id="11-8-5-">11.8.5 抽象関係比較のアルゴリズム</h3>
    <p>　値 x と y から成る比較 x \&lt; y は、(少なくとも1つのオペランドがNaNを示す場合に)true、false、undefinedを生成します。 x と y について追記するとアルゴリズムは、パラメータとして LeftFirst という名のBooleanフラグを取ります。 当該フラグは、 x と y 上で実行される視覚的な副作用を潜在的に伴う操作において順番をコントロールする為に使用されます。 ECMAScriptは、式を左から右へ評価する仕様なのでそれが必要となります。 LeftFirst の既定値は、trueであり、 y パラメータの一致する式の左に現れる式と一致する x パラメータを示します。 LeftFirst が、falseである場合、逆が、そのケースであり、操作は、x の前の y 上で実行されなければいけません。そのような比較は次のように実行されます。</p>
<pre><code>1. LeftFirst フラグが、trueである場合、
    a. px は、 ToPrimitive(x, hint Number) を呼んだ結果とする
    b. py は、 ToPrimitive(y, hint Number) を呼んだ結果とする
    2.それ以外の場合、評価の順は、左から右への評価に優先して逆にさせる必要がある
    a. py は、 ToPrimitive(y, hint Number) を呼んだ結果とする
    b. px は、 ToPrimitive(x, hint Number) を呼んだ結果とする
    3. Type(px) がStringで且つ Type(py) がStringというケースではない場合、
    a. nx は、 ToNumber(px) を呼んだ結果とする
    理由はプリミティブ(原始的)な値である px と py の評価順は、重要ではない為
    b. ny は、 ToNumber(py) を呼んだ結果とする
    c. nx が、NaNである場合、undefinedを返す
    d. ny が、NaNである場合、undefinedを返す
    e. nx と ny が、同一のNumber値である場合、falseを返す
    f. nx が、 +0 且つ ny が、 -0である場合、falseを返す
    g. nx が、 -0 且つ ny が、 +0である場合、falseを返す
    h. nx が、+∞である場合、falseを返す
    i. ny が、+∞である場合、trueを返す
    j. nx が、-∞である場合、falseを返す
    k. ny が、-∞である場合、trueを返す
    l. nx　という数学的な値が、ny という数学的な値よりも小さい場合、(注記としてそれら数学的な値が共に無限大且つ共にゼロでない場合)、trueを返し、それ以外はfalseを返す
    4.それ以外の場合、 px と py は、共に文字列であり、
    a. py が、 px の接頭辞である場合、falseを返す
    ( q が、 p と他のString値 r を連結した結果となることが可能な場合、String値 p は、String値 q の接頭辞である。注釈として一部のStringは、 r がカラのString値に成り得る為、それ自身の接頭辞である。)
    b. px が、 py の接頭辞である場合、trueを返す
    c. k は、 py 内の位置 k にある文字とは異なる px 内の位置 k にある文字のように最小の非負の整数とする
    (何れかのStringが他方の接頭辞である為、このように1つの k にしなければならない)
    d. m は、 px 内の位置 k にある文字におけるコードユニット値である整数とする
    e. n は、 py 内の位置 k にある文字におけるコードユニット値である整数とする
    f. m &lt; n である場合、trueを返し、そうではない場合、falseを返す
</code></pre><p>[注釈 1]</p>
    <p>　ステップ 3 は、その使用や代替等々といった意味では、加算演算子 + ( 11.6.1 )におけるアルゴリズム内のステップ 7 とは異なります。</p>
    <p>[注釈 2]</p>
    <p>　複数のStringの比較には、コードユニット値の並びにおける単純な辞書順を使用します。 Unicode仕様上で定義した、より複雑な文字や文字列の同一性、照合順といったセマンティックス的な指向の定義を使用する為に試すことは何もありません。 それゆえにUnicode標準規格による正規の等価性のあるString値は、等しくないものとしてテストすることが可能です。 このアルゴリズムの効果において、正規形の中に両方のString値が既にあることを前提としています。 また、補完文字を含む文字列についての追記として UTF-16 コードユニット値の並びにおける辞書順は、コードポイント値の並びにおける辞書順とは異なります。</p>
    <h3 id="11-8-6-instanceof-">11.8.6 instanceof 演算子</h3>
    <p>　プロダクション</p>
<pre><code>RelationalExpression: RelationalExpression instanceof ShiftExpression
</code></pre><p>は、次のように評価されます。</p>
<pre><code>1. lref は、RelationalExpressionを評価した結果とする
    2. lval は、 GetValue(lref) とする
    3. rref は、ShiftExpressionを評価した結果とする
    4. rval は、 GetValue(rref) とする
    5. Type(rval) が、Objectではない場合、TypeError例外を投げる(スローする)
    6. rval が、 [[HasInstance]] 内部メソッドを持たない場合、TypeError例外を投げる(スローする)
    7.引数 lval を伴う rval の[[HasInstance]]内部メソッドを呼んだ結果を返す
</code></pre><h3 id="11-8-7-in-">11.8.7 in 演算子</h3>
    <p>　プロダクション</p>
<pre><code>RelationalExpression : RelationalExpression in ShiftExpression
</code></pre><p>は、次のように評価されます。</p>
<pre><code>1. lref は、RelationalExpressionを評価した結果とする
    2. lval は、 GetValue(lref) とする
    3. rref は、ShiftExpressionを評価した結果とする
    4. rval は、 GetValue(rref) とする
    5. Type(rval) が、Objectではない場合、TypeError例外を投げる(スローする)
    6.引数 ToString(lval) を伴う rval の[[HasProperty]]内部メソッドを呼んだ結果を返す
</code></pre><h2 id="11-9-equality-operators-standard-ecma-262-5-1-edition">11.9 等価演算子 / Equality Operators / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="11-">11 式</h3>
    <h3 id="11-9-">11.9 等価演算子</h3>
<pre><code>【構文】
    EqualityExpression :
    RelationalExpression
    EqualityExpression == RelationalExpression
    EqualityExpression != RelationalExpression
    EqualityExpression === RelationalExpression
    EqualityExpression !== RelationalExpression

    EqualityExpressionNoIn :
    RelationalExpressionNoIn
    EqualityExpressionNoIn == RelationalExpressionNoIn
    EqualityExpressionNoIn != RelationalExpressionNoIn
    EqualityExpressionNoIn === RelationalExpressionNoIn
    EqualityExpressionNoIn !== RelationalExpressionNoIn
</code></pre><p>【セマンティックス】</p>
    <p>　等価演算子を評価した結果は、常に2つのオペランド間で保持する演算子によって名づけられた関係かどうかに影響するBoolean型です。 EqualityExpressionNoIn プロダクションは、EqualityExpression と RelationalExpressionのそれぞれを含む代わりにEqualityExpressionNoIn と RelationalExpressionNoInを含んで評価される場合を除き、EqualityExpressionプロダクションと同じ方法で評価されます。</p>
    <h3 id="11-9-1-">11.9.1 等価演算子 ( == )</h3>
    <p>　プロダクション</p>
<pre><code>EqualityExpression : EqualityExpression == RelationalExpression
</code></pre><p>は、次のように評価されます。</p>
<pre><code>1. lref は、 EqualityExpressionを評価した結果とする
    2. lval は、 GetValue(lref) とする
    3. rref は、 RelationalExpressionを評価した結果とする
    4. rval は、 GetValue(rref) とする
    5.抽象等価比較  rval == lval ( 11.9.3 参照)を実行した結果を返す
</code></pre><h3 id="11-9-2-">11.9.2 不等号演算子 ( != )</h3>
    <p>　プロダクション</p>
<pre><code>EqualityExpression : EqualityExpression != RelationalExpression
</code></pre><p>は、次のように評価されます。</p>
<pre><code>1. lref は、EqualityExpressionを評価した結果とする
    2. lval は、 GetValue(lref) とする
    3. rref は、RelationalExpressionを評価した結果とする
    4. rval は、 GetValue(rref) とする
    5. r は、抽象等価比較  rval == lval ( 11.9.3 参照)を実行した結果とする
    6. r が、trueである場合、falseを返し、それ以外の場合、trueを返す
</code></pre><h3 id="11-9-3-">11.9.3 抽象等価比較のアルゴリズム</h3>
    <p>　値 x と y における比較 x == y は、true または falseを生成します。 このような比較は、次のように実行されます。</p>
<pre><code>1. Type(x) が、 Type(y)と同じである場合、
    a. Type(x) が、Undefinedである場合、trueを返す
    b. Type(x) が、Nullである場合、trueを返す
    c. Type(x) が、Numberである場合、
    i. x が、 NaNである場合、falseを返す
    ii. y が、 NaNである場合、falseを返す
    iii. x が、 yと同じNumber値である場合、trueを返す
    iv.  x が、 +0で且つ y が、-0である場合、trueを返す
    v. x が、 -0で且つ y が、+0である場合、trueを返す
    vi. falseを返す
    d. Type(x) が、Stringである場合、 x と y の文字の並びが全く同じ(一致する位置にある文字が同じ長さの同じ文字)である場合、true を返し、それ以外は、falseを返す
    e. Type(x) が、Booleanである場合、 x と y が共に true または、共に falseである場合、 true を返し、それ以外の場合、false を返す
    f. x と y が同じオブジェクトを参照する場合、true を返し、それ以外の場合、false を返す
    2. x が、null且つ、 y がundefinedである場合、trueを返す
    3. x が、undefined且つ、y がnullである場合、trueを返す
    4. Type(x) が、Number且つ、 Type(y) が、Stringである場合、比較 x == ToNumber(y) の結果を返す
    5. Type(x) が、String且つ、 Type(y) が、Numberである場合、比較 ToNumber(x) == y  の結果を返す
    6. Type(x) が、Booleanである場合、比較 ToNumber(x) == y の結果を返す
    7. Type(y) が、Booleanである場合、比較 x == ToNumber(y) の結果を返す
    8. Type(x) が、Stringまたは、Numberであり、且つ Type(y) が、Objectである場合、比較 x == ToPrimitive(y) の結果を返す
    9. Type(x) が、Object且つ Type(y) が、Stringまたは、Numberである場合、比較 ToPrimitive(x) == y の結果を返す
    10. falseを返す

    [注記 1]
    等価についての上記定義について
    String 比較は、 &quot;&quot; + a == &quot;&quot; + b によって有効にすることが可能です。
    Numeric 比較は、 +a == +b によって有効にすることが可能です。
    Boolean 比較は、 !a == !b によって有効にすることが可能です。

    [注記 2]
    等価演算子は、次の不変量を維持しています。
    A != B は、 !(A == B) と等価です。
    A == B は、 A と Bの評価順を除き B == A と等価です。

    [注記 3]
    等価演算子は、常に他動詞というわけではありません。
    例えば、2つの異なるString型オブジェクトが、それぞれ同一のString値を表している場合、それぞれのString型オブジェクトは、 == 演算子によってString値と等価であると考えられそうな気がしますが、この場合、2つのString型オブジェクトは、それぞれ他方と等価にはなりません。
    例えば、
    ・ new String(&quot;a&quot;) == &quot;a&quot; と &quot;a&quot; == new String(&quot;a&quot;) は、共に trueです。
    ・ new String(&quot;a&quot;) == new String(&quot;a&quot;) は、 falseです。

    [注記 4]
    複数のStringの比較は、単にコードユニット値の並びについて等価テストを使用します。
    Unicode仕様上で定義した、より複雑な文字や文字列の同一性、照合順といったセマンティックス上の指向定義を使用する為に試すことは何もありません。
    その為、Unicode標準規格による正規の等価性のあるString値は、等しくないものとしてテストすることが可能です。
    このアルゴリズムの効果においては、正規形の中に両方のString値が既にあることを前提としています。
</code></pre><h3 id="11-9-4-">11.9.4 厳密な等価演算子 ( === )</h3>
    <p>　プロダクション</p>
<pre><code>EqualityExpression : EqualityExpression === RelationalExpression
</code></pre><p>は、次のように評価されます。</p>
<pre><code>1. lref は、EqualityExpressionを評価した結果とする
    2. lval は、 GetValue(lref) とする
    3. rref は、RelationalExpressionを評価した結果とする
    4. rval は、 GetValue(rref) とする
    5.厳密等価比較  rval === lval ( 11.9.6 参照)を実行した結果を返す
</code></pre><h3 id="11-9-5-">11.9.5 厳密な不等号演算子 ( !== )</h3>
    <p>　プロダクション</p>
<pre><code>EqualityExpression : EqualityExpression !== RelationalExpression
</code></pre><p>は、次のように評価されます。</p>
<pre><code>1. lref は、EqualityExpressionを評価した結果とする
    2. lval は、 GetValue(lref) とする
    3. rref は、RelationalExpressionを評価した結果とする
    4. rval は、 GetValue(rref) とする
    5. r は、厳密等価比較  rval === lval ( 11.9.6 参照)を実行した結果とする
    6. r が、trueである場合、falseを返し、それ以外の場合、trueを返す
</code></pre><h3 id="11-9-6-">11.9.6 厳密等価比較のアルゴリズム</h3>
    <p>　値 x と y における比較 x === y は、 true または falseを生成します。</p>
    <p>　このような比較は次のように実行されます。</p>
<pre><code>1. Type(x) が、Type(y)と異なる場合、falseを返す
    2. Type(x) が、Undefinedである場合、trueを返す
    3. Type(x) が、Nullである場合、trueを返す
    4. Type(x) が、Numberである場合、
    a. x が、 NaNである場合、 falseを返す
    b. y が、 NaNである場合、 falseを返す
    c. x が、 y と同一のNumber値である場合、 trueを返す
    d. x が、+0且つ、 y が、-0である場合、 trueを返す
    e. x が、-0且つ、 y が、+0である場合、 trueを返す
    f. falseを返す
    5. Type(x) が、Stringである場合、 x と yが、全く同一の文字の並び(一致する位置にある文字が同じ長さの同じ文字)である場合、 trueを返し、それ以外の場合、falseを返す
    6. Type(x) が、Booleanである場合、 x と yが、共に true または、共に falseである場合、 trueを返し、それ以外の場合、falseを返す
    7. x と yが、同一のオブジェクトを参照する場合、 true を返し、それ以外の場合、falseを返す
</code></pre><p>[注釈]</p>
    <p>　このアルゴリズムは、その符号付きゼロとNaNの扱いの中にあるSameValueアルゴリズム(9.12)とは異なります。</p>
    <h2 id="11-10-binary-bitwise-operators-standard-ecma-262-5-1-edition">11.10 バイナリビット単位演算子 / Binary Bitwise Operators / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="11-">11 式</h3>
    <h3 id="11-10-">11.10 バイナリビット単位演算子</h3>
<pre><code>【構文】
    BitwiseANDExpression :
    EqualityExpression
    BitwiseANDExpression &amp; EqualityExpression

    BitwiseANDExpressionNoIn :
    EqualityExpressionNoIn
    BitwiseANDExpressionNoIn &amp; EqualityExpressionNoIn

    BitwiseXORExpression :
    BitwiseANDExpression
    BitwiseXORExpression ^ BitwiseANDExpression

    BitwiseXORExpressionNoIn :
    BitwiseANDExpressionNoIn
    BitwiseXORExpressionNoIn ^ BitwiseANDExpressionNoIn

    BitwiseORExpression :
    BitwiseXORExpression
    BitwiseORExpression | BitwiseXORExpression

    BitwiseORExpressionNoIn :
    BitwiseXORExpressionNoIn
    BitwiseORExpressionNoIn | BitwiseXORExpressionNoIn
</code></pre><p>【セマンティックス】</p>
    <p>　@ が上記プロダクション内にあるビット単位演算子の1つである場合、プロダクション A : A @ B は、次のように評価されます。</p>
<pre><code>1. lref は、 A を評価した結果とする
    2. lval は、 GetValue(lref) とする
    3. rref は、 B を評価した結果とする
    4. rval は、 GetValue(rref) とする
    5. lnum は、 ToInt32(lval) とする
    6. rnum は、 ToInt32(rval) とする
    7.ビット単位演算子@を lnum と rnum に適用した結果を返す、その結果は、1つの符号付き32ビット整数
</code></pre><h2 id="11-11-binary-logical-operators-standard-ecma-262-5-1-edition">11.11 バイナリ論理演算子 / Binary Logical Operators / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="11-">11 式</h3>
    <h3 id="11-11-">11.11 バイナリ論理演算子</h3>
<pre><code>【構文】
    LogicalANDExpression :
    BitwiseORExpression
    LogicalANDExpression &amp;&amp; BitwiseORExpression

    LogicalANDExpressionNoIn :
    BitwiseORExpressionNoIn
    LogicalANDExpressionNoIn &amp;&amp; BitwiseORExpressionNoIn

    LogicalORExpression :
    LogicalANDExpression
    LogicalORExpression || LogicalANDExpression

    LogicalORExpressionNoIn :
    LogicalANDExpressionNoIn
    LogicalORExpressionNoIn || LogicalANDExpressionNoIn
</code></pre><p>【セマンティックス】</p>
    <p>　プロダクション</p>
<pre><code>LogicalANDExpression : LogicalANDExpression &amp;&amp; BitwiseORExpression
</code></pre><p>は、次のように評価されます。</p>
<pre><code>1. lref は、LogicalANDExpressionを評価した結果とする
    2. lval は、 GetValue(lref) とする
    3. ToBoolean(lval) が、falseである場合、 lval を返す
    4. rref は、BitwiseORExpressionを評価した結果とする
    5. GetValue(rref) を返す
</code></pre><p>　プロダクション</p>
<pre><code>LogicalORExpression : LogicalORExpression || LogicalANDExpression
</code></pre><p>は、次のように評価されます。</p>
<pre><code>1. lref は、LogicalORExpressionを評価した結果とする
    2. lval は、 GetValue(lref) とする
    3. ToBoolean(lval) が、 trueである場合、 lvalを返す
    4. rref は、LogicalANDExpressionを評価した結果とする
    5. GetValue(rref) を返す
</code></pre><p>　LogicalANDExpressionNoInとLogicalORExpressionNoInプロダクションは、LogicalANDExpression、BitwiseORExpression、LogicalORExpressionをそれぞれ含む代わりにLogicalANDExpressionNoIn、BitwiseORExpressionNoIn、LogicalORExpressionNoInを含んで評価される場合を除き、 LogicalANDExpression と LogicalORExpression と同じ方法で評価されます。</p>
    <p>[注釈]</p>
    <p>　 &amp;&amp; や || 演算子によって生成した値は、Boolean型である必要はありません。 生成した値は、常に2つのオペランドの内の一方の値になります。</p>
    <h2 id="11-12-conditional-operator-standard-ecma-262-5-1-edition">11.12 条件演算子 ( ? : ) / Conditional Operator / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="11-">11 式</h3>
    <h3 id="11-12-">11.12 条件演算子 ( ? : )</h3>
<pre><code>【構文】
    ConditionalExpression :
    LogicalORExpression
    LogicalORExpression ? AssignmentExpression : AssignmentExpression

    ConditionalExpressionNoIn :
    LogicalORExpressionNoIn
    LogicalORExpressionNoIn ? AssignmentExpression : AssignmentExpressionNoIn
</code></pre><p>【セマンティックス】</p>
    <p>　プロダクション</p>
<pre><code>ConditionalExpression : LogicalORExpression ? AssignmentExpression : AssignmentExpression
</code></pre><p>は、次のように評価されます。</p>
<pre><code>1. lref は、LogicalORExpressionを評価した結果とする
    2. ToBoolean(GetValue(lref)) が、 trueである場合、
    a. trueRef は、AssignmentExpressionを評価した結果とする
    b. GetValue(trueRef) を返す
    3.それ以外の場合、
    a. falseRef は、2つめのAssignmentExpressionを評価した結果とする
    b. GetValue(falseRef) を返す
</code></pre><p>　ConditionalExpressionNoInプロダクションは、LogicalORExpression、1つめのAssignmentExpression、2つめのAssignmentExpressionをそれぞれ含む代わりにLogicalORExpressionNoIn、AssignmentExpression 、AssignmentExpressionNoInを含んで評価される場合を除き、ConditionalExpressionと同じ方法で評価されます。</p>
    <p>[注釈]</p>
    <p>　ECMAScript内のConditionalExpression(条件式)における文法は、2つめの副次式がExpression(式)とすることを許容する一方、3つめの式については、ConditionalExpressionにすることを制限する C や Java での場合とは、ほんの少しばかり異なります。 ECMAScript内のこの相違における動機は、条件の一方(arm of a conditional)だけを有効にする場合、紛らわしさを排除したい場合、中央の式の大部分が、かなり無駄なカンマ式である場合の何れかによって規定される式の指定を許容する為です。</p>
    <h2 id="11-13-assignment-operators-standard-ecma-262-5-1-edition">11.13 代入演算子 / Assignment Operators / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="11-">11 式</h3>
    <h3 id="11-13-">11.13 代入演算子</h3>
<pre><code>【構文】
    AssignmentExpression :
    ConditionalExpression
    LeftHandSideExpression = AssignmentExpression
    LeftHandSideExpression AssignmentOperator AssignmentExpression

    AssignmentExpressionNoIn :
    ConditionalExpressionNoIn
    LeftHandSideExpression = AssignmentExpressionNoIn
    LeftHandSideExpression AssignmentOperator AssignmentExpressionNoIn

    AssignmentOperator :

    *= /= %= += -= &lt;&lt;= &gt;&gt;= &gt;&gt;&gt;= &amp;= ^= |=

    の何れか1つ
</code></pre><p>【セマンティックス】</p>
    <p>　AssignmentExpressionNoIn プロダクションは、ConditionalExpression と AssignmentExpressionを含む代わりにConditionalExpressionNoIn と AssignmentExpressionNoInを含んで評価される場合を除き、AssignmentExpressionプロダクションと同じ方法で評価されます。</p>
    <h3 id="11-13-1-">11.13.1 単純な代入 ( = )</h3>
    <p>　プロダクション</p>
<pre><code>AssignmentExpression : LeftHandSideExpression = AssignmentExpression
</code></pre><p>は、次のように評価されます。</p>
<pre><code>1. lref は、LeftHandSideExpressionを評価した結果とする
    2. rref は、AssignmentExpressionを評価した結果とする
    3. rval は、 GetValue(rref) とする
    4.次の条件が全て trueである場合、SyntaxError例外を投げる(スローする)
    ・ReferenceであるType(lref) が、true
    ・IsStrictReference(lref) が、 true
    ・Type(GetBase(lref)) が、環境レコード
    ・GetReferencedName(lref) が、 &quot;eval&quot; または &quot;arguments&quot;の何れか
    5. PutValue(lref, rval) を呼ぶ
    6. rval を返す
</code></pre><p>[注釈]</p>
    <p>　strictモードのコード内に代入が現れる場合、その LeftHandSide (左辺)については、未解決の参照を評価してはいけません。 ReferenceError例外とする場合には、代入について投げます(スローします)。 LeftHandSide はまた、属性値 {[[Writable]]:false}を伴うデータプロパティ、属性値 {[[Set]]:undefined}を伴うアクセサプロパティ、値falseを持つ[[Extensible]]内部プロパティであるオブジェクトの存在しない(non-existent)プロパティなどについては参照しない場合があります。 これらのケースについては、TypeError例外が投げられます(スローされます)。</p>
    <h3 id="11-13-2-op-">11.13.2 複雑な代入 ( op= )</h3>
    <p>　AssignmentOperatorが、上記で示された演算子の1つを表す @= と @ である場合、</p>
    <p>　プロダクション</p>
<pre><code>AssignmentExpression : LeftHandSideExpression AssignmentOperator AssignmentExpression
</code></pre><p>は、次のように評価されます。</p>
<pre><code>1. lref は、LeftHandSideExpressionを評価した結果とする
    2. lval は、 GetValue(lref) とする
    3. rref は、AssignmentExpressionを評価した結果とする
    4. rval は、 GetValue(rref) とする
    5. r は、 lval と rval に演算子 @ を適用した結果とする
    6.次の条件が全て trueである場合、SyntaxError例外を投げる(スローする)
    ・ReferenceであるType(lref) が、 true
    ・IsStrictReference(lref) が、 true
    ・Type(GetBase(lref)) が、 Environment Record(環境レコード)
    ・GetReferencedName(lref) が、 &quot;eval&quot; または &quot;arguments&quot;の何れか
    7. PutValue(lref, r) を呼ぶ
    8. r を返す
</code></pre><p>[注釈]</p>
    <p>　11.13.1の注釈参照</p>
    <h2 id="11-14-comma-operator-standard-ecma-262-5-1-edition">11.14 カンマ演算子 ( , ) / Comma Operator / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="11-">11 式</h3>
    <h3 id="11-14-">11.14 カンマ演算子 ( , )</h3>
<pre><code>【構文】
    Expression :
    AssignmentExpression Expression , AssignmentExpression

    ExpressionNoIn :
    AssignmentExpressionNoIn ExpressionNoIn , AssignmentExpressionNoIn
</code></pre><p>【セマンティックス】</p>
    <p>　プロダクション</p>
<pre><code>Expression : Expression , AssignmentExpression
</code></pre><p>は、次のように評価されます。</p>
<pre><code>1. lref は、Expressionを評価した結果とする
    2. GetValue(lref) を呼ぶ
    3. rref は、AssignmentExpressionを評価した結果とする
    4. GetValue(rref) を返す
</code></pre><p>　ExpressionNoInは、Expression と AssignmentExpressionのそれぞれを含む代わりにExpressionNoIn と AssignmentExpressionNoInを含んで評価される場合を除き、Expressionプロダクションと同じ方法で評価されます。</p>
    <p>[注釈]</p>
    <p>　GetValueは、観測可能な副作用を持つ場合がある為、その値が使用されない場合でさえ呼ばれなければいけません。</p>
    <h2 id="12-statements-standard-ecma-262-5-1-edition">12 文 / Statements / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="12-">12 ステートメント／文</h3>
<pre><code>【構文】
    Statement :
    Block
    VariableStatement
    EmptyStatement
    ExpressionStatement
    IfStatement
    IterationStatement
    ContinueStatement
    BreakStatement
    ReturnStatement
    WithStatement
    LabelledStatement
    SwitchStatement
    ThrowStatement
    TryStatement
    DebuggerStatement
</code></pre><p>【セマンティックス】</p>
    <p>　Statement(文)は、それ自身をLabelledStatement(ラベル付きの文)の一部とすることが可能等々といったようにLabelledStatementの一部とすることが可能です。 この方法を導入したラベルは、個別の文のセマンティクスを説明する場合に“現在のラベルのセット(集合)”といったようにひとまとめに参照されます。 LabelledStatementには、任意のラベル集合へのラベルの導入以外のセマンティック上の意味合いはありません。 IterationStatement (反復文)や SwitchStatement (Switch文)のラベルのセットは、最初は1つのカラの要素を含みます。 他の文のラベルのセットは、最初はカラです。</p>
    <p>　Statementを評価した結果は、常にCompletion(完了)値です。</p>
    <p>[注釈]</p>
    <p>　ECMAScriptの実装を使用した一部の拡張は、文としてFunctionDeclaration(関数宣言)の使用をサポートすることが知られています。 しかしながら、FunctionDeclarationsのように適用したセマンティクスについては、実装間において重大かつ両立し得ないバリエーションがあります。 これらの理由は、コード内のStatement結果としてのFunctionDeclarationの使用は、実装間での移植が確実でないという点から、その相違は相容れないからです。 ECMAScriptの実装においては、FunctionDeclarationの使用を禁ずるか、このような使用方法と遭遇した場合に警告を発することが推奨されます。 ECMAScriptの将来のエディション(版)では、Statementコンテキスト内で定義した関数における意味を移植する選択肢を定義するかもしれません。</p>
    <h2 id="12-1-block-standard-ecma-262-5-1-edition">12.1 ブロック / Block / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="12-">12 ステートメント／文</h3>
    <h3 id="12-1-">12.1 ブロック</h3>
<pre><code>【構文】
    Block :
    { StatementListopt }

    StatementList :
    Statement
    StatementList Statement
</code></pre><p>【セマンティックス】</p>
    <p>　プロダクション Block : { } は、次のように評価されます。</p>
<pre><code>1.return (normal, empty, empty)
</code></pre><p>　プロダクション Block : { StatementList } は、次のように評価されます。</p>
<pre><code>1.StatementListを評価した結果を返す
</code></pre><p>　プロダクション StatementList : Statement は、次のように評価されます。</p>
<pre><code>1. s は、Statementを評価した結果とする
    2.例外が投げられた(スローされた)場合、V は例外である return (throw, V, empty) とする(スローされた例外が何もないかのように現在の処理を実行)
    3. s を返す
</code></pre><p>　プロダクション StatementList : StatementList Statement は、次のように評価されます。</p>
<pre><code>1. sl は、StatementListを評価した結果とする
    2. sl が、中途完了(an abrupt completion)である場合、 slを返す
    3. s は、Statementを評価した結果とする
    4.例外が投げられた(スローされた)場合、V は例外である return (throw, V, empty) とする(スローされた例外が何もないかのように現在の処理を実行)
    5. s.value が、emptyである場合、 V = sl.value とし、それ以外の場合、 V = s.value とする
    6.return (s.type, V, s.target)
</code></pre><p>[注釈]</p>
    <p>　StatementListの値を確保する上記アルゴリズムのステップ 5 と 6 は、StatementList内で最後の値を生成したStatementの値です。 例えば、次は、全て値 1 を返す eval 関数を呼びます。</p>
<pre><code>eval(&quot;1;;;;;&quot;)
    eval(&quot;1;{}&quot;)
    eval(&quot;1;var a;&quot;)
</code></pre><h2 id="12-2-variable-statement-standard-ecma-262-5-1-edition">12.2 変数ステートメント / Variable Statement / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="12-">12 ステートメント／文</h3>
    <h3 id="12-2-">12.2 変数ステートメント</h3>
<pre><code>【構文】
    VariableStatement :
    var VariableDeclarationList ;

    VariableDeclarationList :
    VariableDeclaration
    VariableDeclarationList , VariableDeclaration

    VariableDeclarationListNoIn :
    VariableDeclarationNoIn
    VariableDeclarationListNoIn , VariableDeclarationNoIn

    VariableDeclaration :
    Identifier Initialiseropt

    VariableDeclarationNoIn :
    Identifier InitialiserNoInopt

    Initialiser :
    = AssignmentExpression

    InitialiserNoIn :
    = AssignmentExpressionNoIn
</code></pre><p>　変数ステートメントは、10.5 で定義したように生成される変数を宣言します。 変数は、生成される場合、Undefined(未定義)として初期化されます。 イニシャライザーを伴う変数は、その変数が生成される際ではなく、VariableStatementが実行される際に当該AssignmentExpressionの値を関連付けられます。</p>
    <p>【セマンティックス】</p>
    <p>　プロダクション VariableStatement : var VariableDeclarationList ; は、次のように評価されます。</p>
<pre><code>1.VariableDeclarationListを評価
    2.return (normal, empty, empty)
</code></pre><p>　プロダクション VariableDeclarationList :VariableDeclaration は、次のように評価されます。</p>
<pre><code>1.VariableDeclarationを評価
</code></pre><p>　プロダクション VariableDeclarationList : VariableDeclarationList , VariableDeclaration は、次のように評価されます。</p>
<pre><code>1.VariableDeclarationListを評価
    2.VariableDeclarationを評価
</code></pre><p>　プロダクション VariableDeclaration : Identifier は、次のように評価されます。</p>
<pre><code>1.識別子(Identifier)内にあるものと文字の並びが同じものを含むString値を返す
</code></pre><p>　プロダクション VariableDeclaration : Identifier Initialiser は、次のように評価されます。</p>
<pre><code>1. lhs は、11.1.2で定義したようにIdentifier(識別子)を評価した結果とする
    2. rhs は、Initialiser(イニシャライザー)を評価した結果とする
    3. value は、 GetValue(rhs) とする
    4. PutValue(lhs, value) を呼ぶ
    5.識別子(Identifier)内にあるものと文字の並びが同じものを含むString値を返す
</code></pre><p>[注釈]</p>
    <p>　VariableDeclaration(変数宣言)のString値は、 for-in 文(12.6.4)の評価の中で使用されます。</p>
    <p>　VariableDeclarationが、文を伴って内側にネストされたり、VariableDeclaration内の識別子が文のオブジェクト型環境レコードを伴うバインディングオブジェクトのプロパティ名と同名である場合には、ステップ4は、当該識別子のVariableEnvironmentバインディングへの代わりにプロパティに値を関連付けるでしょう。</p>
    <p>プロダクション Initialiser : = AssignmentExpression は、次のように評価されます。</p>
<pre><code>1.VariableEnvironmentを評価した結果を返す
</code></pre><p>　VariableDeclarationListNoIn、VariableDeclarationNoIn、InitialiserNoInは、VariableDeclarationList、VariableDeclaration、Initialiser 、AssignmentExpressionのそれぞれ含む代わりにVariableDeclarationListNoIn、VariableDeclarationNoIn、InitialiserNoIn、AssignmentExpressionNoInを含んで評価される場合を除き、VariableDeclarationList、VariableDeclaration、Initialiserプロダクションと同じ方法で評価されます。</p>
    <h3 id="12-2-1-strict-">12.2.1 Strict(厳格)モードの制限・制約</h3>
    <p>　VariableDeclaration や VariableDeclarationNoIn が、strictコード内に現れたり、当該識別子が “eval” や “arguments”である場合には、SyntaxErrorです。</p>
    <h2 id="12-3-empty-statement-standard-ecma-262-5-1-edition">12.3 空文・カラ文 / Empty Statement / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="12-">12 ステートメント／文</h3>
    <h3 id="12-3-empty-statement">12.3 空文・カラ文 / Empty Statement</h3>
<pre><code>【構文】

    EmptyStatement :
    ;
</code></pre><p>【セマンティックス】</p>
    <p>　プロダクション EmptyStatement : ; は、次のように評価されます。</p>
<pre><code>1. return (normal, empty, empty)
</code></pre><h2 id="12-4-expression-statement-standard-ecma-262-5-1-edition">12.4 式ステートメント / Expression Statement / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="12-">12 ステートメント／文</h3>
    <h3 id="12-4-">12.4 式ステートメント</h3>
<pre><code>【構文】
    ExpressionStatement :
    [lookahead ? {{, function}] Expression ;
</code></pre><p>[注釈]</p>
    <p>　ExpressionStatement(式の文)は、ブロックとの曖昧さを作り出す可能性があるので開始波カッコ “{” を伴って始めることはできません。 また、ExpressionStatementは、FunctionDeclaration(関数宣言)との曖昧さを作り出す可能性があるのでfunctionキーワードを伴って始めることはできません</p>
    <p>【セマンティックス】</p>
    <p>　プロダクション</p>
<pre><code>ExpressionStatement : [lookahead ? {{, function}] Expression;
    ( ? は、∈ の否定形)
</code></pre><p>は、次のように評価されます。</p>
<pre><code>1. exprRef は、Expressionを評価した結果とする
    2. return (normal, GetValue(exprRef), empty)
</code></pre><h2 id="12-5-if-the-if-statement-standard-ecma-262-5-1-edition">12.5 if 文 / The if Statement / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="12-">12 ステートメント／文</h3>
    <h3 id="12-5-if-">12.5 if 文</h3>
<pre><code>【構文】
    IfStatement :
    if ( Expression ) Statement else Statement
    if ( Expression ) Statement
</code></pre><p>　それぞれ他のどのifに関連する選択なのかが曖昧である場合は、他に何も一致するものがないという場合を除き、可能な限り最も近いものと関連させるようにしましょう。</p>
    <p>【セマンティックス】</p>
    <p>　プロダクション</p>
<pre><code>IfStatement : if ( Expression ) Statement else Statement
</code></pre><p>は、次のように評価されます。</p>
<pre><code>1. exprRef は、Expressionを評価した結果とする
    2. ToBoolean(GetValue(exprRef)) が、 trueである場合、
    a.1つめの文を評価した結果を返す
    3.それ以外の場合、
    a.2つめの文を評価した結果を返す
</code></pre><p>　プロダクション</p>
<pre><code>IfStatement : if ( Expression ) Statement
</code></pre><p>は、次のように評価されます。</p>
<pre><code>1. exprRef は、Expressionを評価した結果とする
    2. ToBoolean(GetValue(exprRef)) が、 falseである場合、 return (normal, empty, empty)
    3. Statementを評価した結果を返す
</code></pre><h2 id="12-6-iteration-statements-standard-ecma-262-5-1-edition">12.6 反復ステートメント / Iteration Statements / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="12-">12 ステートメント／文</h3>
    <h3 id="12-6-">12.6 反復ステートメント</h3>
<pre><code>【構文】
    IterationStatement :
    do Statement while ( Expression );
    while ( Expression ) Statement
    for (ExpressionNoInopt; Expressionopt ; Expressionopt ) Statement
    for ( var VariableDeclarationListNoIn; Expressionopt ; Expressionopt ) Statement
    for ( LeftHandSideExpression in Expression ) Statement
    for ( var VariableDeclarationNoIn in Expression ) Statement
</code></pre><h3 id="12-6-1-do-while-">12.6.1 do-while 文</h3>
    <p>　プロダクション</p>
<pre><code>do Statement while ( Expression );
</code></pre><p>は、次のように評価されます。</p>
<pre><code>1. V = empty とする
    2. iteratingは、trueとする
    3. iteratingが、trueの間、繰り返し
    a. stmt は、Statementを評価した結果とする
    b. stmt.value が、emptyではない場合、 V = stmt.valueとする
    c. stmt.type が、continueでない、または、 stmt.target が、現在のラベルのセットではない場合、
    i. stmt.type が、breakで且つ、 stmt.target が現在のラベルのセットである場合、return (normal, V, empty)
    ii. stmt が、途中完了(an abrupt completion)である場合、 stmt を返す
    d. exprRef は、Expressionを評価した結果とする
    e. ToBoolean(GetValue(exprRef)) が、falseである場合、iteratingにfalseを設定
    4. return (normal, V, empty)
</code></pre><h3 id="12-6-2-while-">12.6.2 while 文</h3>
    <p>　プロダクション</p>
<pre><code>IterationStatement : while ( Expression ) Statement
</code></pre><p>は、次のように評価されます。</p>
<pre><code>1. V = empty とする
    2.繰り返す
    a. exprRef は、Expressionを評価した結果とする
    b. ToBoolean(GetValue(exprRef)) が、 falseである場合、return (normal, V, empty)
    c. stmt は、Statementを評価した結果とする
    d. stmt.value が、emptyではない場合、 V = stmt.value とする
    e. stmt.type が、continueでない、または、 stmt.target が、現在のラベルのセットではない場合、
    i. stmt.type が、breakで且つ、 stmt.target が、現在のラベルのセット内にある場合、
    1. return (normal, V, empty)
    ii. stmt が、途中完了(an abrupt completion)である場合、 stmt を返す
</code></pre><h3 id="12-6-3-for-">12.6.3 for 文</h3>
    <p>　プロダクション</p>
<pre><code>IterationStatement : for (ExpressionNoInopt ; Expressionopt ; Expressionopt) Statement
</code></pre><p>は、次のように評価されます。</p>
<pre><code>1. ExpressionNoIn が存在する場合、
    a. exprRef は、ExpressionNoInを評価した結果とする
    b. GetValue(exprRef)を呼ぶ(この値は使われないが、副作用を持つ場合がある)
    2. V = empty とする
    3.繰り返す
    a.1つめのExpressionが存在する場合、
    i. testExprRef は、1つめのExpressionを評価した結果とする
    ii. ToBoolean(GetValue(testExprRef)) が、 falseである場合、 return (normal, V, empty)
    b. stmt は、Statementを評価した結果とする
    c. stmt.value が、emptyではない場合、 V = stmt.value とする
    d. stmt.type が、breakで且つ、 stmt.target が現在のラベルのセット内にある場合、return (normal, V, empty)
    e. stmt.type が、continueでない、または、 stmt.target が、現在のラベルのセット内にない場合、
    i. stmt が、途中完了(an abrupt completion)である場合、 stmt を返す
    f.2つめのExpressionが存在する場合、
    i. incExprRef は、2つめのExpressionを評価した結果とする
    ii. GetValue(incExprRef) を呼ぶ(この値は使用されない)
</code></pre><p>　プロダクション</p>
<pre><code>IterationStatement : for ( var VariableDeclarationListNoIn ; Expressionopt ; Expressionopt ) Statement
</code></pre><p>は、次のように評価されます。</p>
<pre><code>1. VariableDeclarationListNoInを評価
    2. V = empty とする
    3.繰り返す
    a.1つめのExpressionが存在する場合、
    i. testExprRef は、1つめのExpressionを評価した結果とする
    ii. ToBoolean(GetValue(testExprRef)) が、 falseである場合、 return (normal, V, empty)
    b. stmt は、Statementを評価した結果とする
    c. stmt.value が、emptyではない場合、 V = stmt.value とする
    d. stmt.type が、breakで且つ、 stmt.target が、現在のラベルのセット内にある場合、 return (normal, V, empty)
    e. stmt.type が、continueでない、または、 stmt.target が、現在のラベルのセット内にない場合、
    i. stmt が、途中完了(an abrupt completion)である場合、 stmt を返す
    f.2つめのExpressionが存在する場合、
    i. incExprRef は、2つめのExpressionを評価した結果とする
    ii. GetValue(incExprRef)を呼ぶ(この値は使用されない)
</code></pre><h3 id="12-6-4-for-in-">12.6.4 for-in 文</h3>
    <p>　プロダクション</p>
<pre><code>IterationStatement : for ( LeftHandSideExpression in Expression ) Statement
</code></pre><p>は、次のように評価されます。</p>
<pre><code>1. exprRef は、Expressionを評価した結果とする
    2. experValue は、 GetValue(exprRef) とする
    3. experValue が、 null または、 undefinedである場合、 return (normal, empty, empty)
    4. obj は、 ToObject(experValue) とする
    5. V = empty とする
    6.繰り返す
    a. P は、[[Enumerable]]属性が、trueである obj の次のプロパティの名称とする、そのようなプロパティがない場合、 return (normal, V, empty)
    b. lhsRef は、 LeftHandSideExpression を評価した結果とする (それは繰り返しと評価される場合がある)
    c. PutValue(lhsRef, P) を呼ぶ
    d. stmt は、Statementを評価した結果とする
    e. stmt.value が、 emptyである場合、 V = stmt.value とする
    f. stmt.type が、 breakで且つ stmt.target が、現在のラベルのセット内にある場合、 return (normal, V, empty)
    g. stmt.type が、continueでない、または、 stmt.target が、現在のラベルのセット内にない場合、
    i. stmt が、途中完了(an abrupt completion)である場合、 stmt を返す
</code></pre><p>　プロダクション</p>
<pre><code>IterationStatement : for ( var VariableDeclarationNoIn in Expression ) Statement
</code></pre><p>は、次のように評価されます。</p>
<pre><code>1. varName は、VariableDeclarationNoInを評価した結果とする
    2. exprRef は、Expressionを評価した結果とする
    3. experValue は、 GetValue(exprRef) とする
    4. experValue が、 null または、 undefinedである場合、return (normal, empty, empty)
    5. obj は、 ToObject(experValue) とする
    6. V = empty とする
    7.繰り返す
    a. P は、[[Enumerable]]属性がtrueである obj の次のプロパティの名称とする、そのようなプロパティがない場合には、 return (normal, V, empty)
    b. varRef は、識別子参照 (11.1.2)にあったように varName を評価した結果とする、それは繰り返しと評価される場合がある
    c. PutValue(varRef, P) を呼ぶ
    d. stmt は、Statementを評価した結果とする
    e. stmt.value が、emptyではない場合、 let V = stmt.value とする
    f. stmt.type が、 breakで且つ、stmt.target が、現在のラベルのセット内にある場合、 return (normal, V, empty)
    g. stmt.type が、continueでない、または、 stmt.target が現在のラベルのセット内にない場合、
    i. stmt が、途中完了(an abrupt completion)である場合、 stmt を返す
</code></pre><p>　(1つめのアルゴリズムのステップ 6.a. 、2つめのステップ 7.a. にある)プロパティの仕組みと列挙順は、指定されません。 列挙中のオブジェクトのプロパティは、列挙中に削除される場合があります。 プロパティが、列挙中に削除され、もはや存在しない場合、それは存在しないでしょう。 新たなプロパティが、列挙中に列挙されるオブジェクトに追加される場合、新たに追加されたプロパティが、アクティブな列挙内に存在する保証はありません。 プロパティ名は、列挙子内に1度以上現れてはいけません。</p>
    <p>　オブジェクトのプロパティを列挙中は、当該プロトタイプの列挙中のプロパティ、またはプロトタイプのプロトタイプ等々といった再帰を含みますが、同じ名称であるプロパティを持つプロトタイプチェーン内にあるオブジェクトの前に何かがある為に「陰になった」(“shadowed”である)場合、プロトタイプのプロトタイプは列挙されません。 [[Enumerable]]属性の値は、プロトタイプチェーンにおけるプロトタイプオブジェクトのプロトタイプが、前のオブジェクトによって隠されているかどうかについて決める際には考慮されません。</p>
    <p>[注釈]</p>
    <p>11.13.1.注釈参照</p>
    <h2 id="12-7-continue-the-continue-statement-standard-ecma-262-5-1-edition">12.7 continue 文 / The continue Statement / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="12-">12 ステートメント／文</h3>
    <h3 id="12-7-continue-">12.7 continue 文</h3>
<pre><code>【構文】
    ContinueStatement :
    continue ;
    continue [no LineTerminator here] Identifier;
</code></pre><p>【セマンティックス】</p>
    <p>プログラムは、次の何れかが、trueである場合、構文上の誤りがあると考えられます。</p>
    <ul>
        <li>プログラムが、IterationStatement(iteration・反復文)内で(関数の境界を超えずに)直接または、間接的にネストされない場合にオプションの識別子なしで continue 文を含む</li>
        <li>プログラムが、IterationStatement(iteration・反復文)に(関数の境界を超えずに)括られるラベルのセット内に現れない識別子においてオプションの識別子を伴って continue 文を含む</li>
    </ul>
    <p>　識別子のない ContinueStatement は、次のように評価されます。</p>
<pre><code>1.return (continue, empty, empty)
</code></pre><p>　オプションの識別子を伴う ContinueStatement は、次のように評価されます。</p>
<pre><code>1.return (continue, empty, Identifier)
</code></pre><h2 id="12-8-break-the-break-statement-standard-ecma-262-5-1-edition">12.8 break 文 / The break Statement / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="12-">12 ステートメント／文</h3>
    <h3 id="12-8-break-">12.8 break 文</h3>
<pre><code>【構文】
    BreakStatement :
    break ;
    break [no LineTerminator here] Identifier ;
</code></pre><p>【セマンティックス】</p>
    <p>プログラムは、次の何れかが、trueである場合、構文上の誤りがあると考えられます。</p>
    <ul>
        <li>プログラムが、IterationStatement(iteration・反復文) や SwitchStatement(switch文)内で(関数の境界を超えずに)直接または、間接的にネストされない場合にオプションの識別子なしで break 文を含む</li>
        <li>プログラムが、(関数の境界を超えない)文で括られるラベルのセット内に現れない識別子である場合にオプションの識別子を伴う break 文を含む</li>
    </ul>
    <p>　識別子のない BreakStatement は、次のように評価されます。</p>
<pre><code>1.return (break, empty, empty).
</code></pre><p>　識別子を伴う BreakStatement は、次のように評価されます。</p>
<pre><code>1.return (break, empty, Identifier).
</code></pre><h2 id="12-9-return-the-return-statement-standard-ecma-262-5-1-edition">12.9 return 文 / The return Statement / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="12-">12 ステートメント／文</h3>
    <h3 id="12-9-return-">12.9 return 文</h3>
<pre><code>【構文】
    ReturnStatement :
    return ;
    return [no LineTerminator here] Expression ;
</code></pre><p>【セマンティックス】</p>
    <p>　ECMAScriptのプログラムは、FunctionBody(関数本体)内に何もない return 文を含む場合、構文上の誤りがあると考えられます。 実行を中止する為の関数に起因する return 文は、callerに値を返します。 Expression が、省略される場合、戻り値は、undefined(未定義)です。 それ以外の場合、戻り値は、Expression(式)の値です。</p>
    <p>　ReturnStatement は、次のように評価されます。</p>
<pre><code>1.Expressionが、存在しない場合、return (return, undefined, empty)
    2. exprRef は、Expressionを評価した結果とする
    3.return (return, GetValue(exprRef), empty)
</code></pre><h2 id="12-10-with-the-with-statement-standard-ecma-262-5-1-edition">12.10 with 文 / The with Statement / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="12-">12 ステートメント／文</h3>
    <h3 id="12-10-with-">12.10 with 文</h3>
<pre><code>【構文】
    WithStatement :
    with ( Expression ) Statement
</code></pre><p>　 with 文は、現在の実行コンテキストの語彙的な環境に生成したオブジェクトについてオブジェクト型環境レコードを追加します。 その場合、引数とした語彙的な環境を使って文を実行します。 最後にそれは元の語彙的な環境を復元します。</p>
    <p>【セマンティックス】</p>
    <p>　プロダクション</p>
<pre><code>WithStatement : with ( Expression ) Statement
</code></pre><p>は、次のように評価されます。</p>
<pre><code>1. val は、Expressionを評価した結果とする
    2. obj は、 ToObject(GetValue(val)) とする
    3. oldEnv は、実行中の実行コンテキストのLexicalEnvironmentとする
    4. newEnv は、引数として obj と oldEnv を渡すことによってNewObjectEnvironmentを呼んだ結果とする
    5. newEnv の provideThis フラグに true を設定
    6. 実行中の実行コンテキストのLexicalEnvironmentに newEnv を設定
    7. C は、Statementを評価した結果とするが、評価中に例外が投げられる(スローされる)場合、  V が例外である場合、 C は、 (throw, V, empty)とする(、もし、投げられる(スローされる)例外がない場合のように現在の結果を実行する)
    8.実行中の実行コンテキストのLexicalEnvironmentに oldEnv を設定
    9. C を返す
</code></pre><p>[注釈]</p>
    <p>　通常、中途完了(abrupt completion)、例外如何に関わらず、操作上、どんなに組み込み文が残ったとしてもLexicalEnvironmentは、常に元の状態に復元されます。</p>
    <h3 id="12-10-1-strict-">12.10.1 strict(厳格)モードの制限・制約</h3>
    <p>　strictモードのコードは、WithStatementに含まれない場合があります。 このようなコンテキスト内でのWithStatementの出現は、SyntaxErrorとして扱われます。</p>
    <h2 id="12-11-switch-the-switch-statement-standard-ecma-262-5-1-edition">12.11 switch 文 / The switch Statement / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="12-">12 ステートメント／文</h3>
    <h3 id="12-11-switch-">12.11 switch 文</h3>
<pre><code>【構文】
    SwitchStatement :
    switch ( Expression ) CaseBlock

    CaseBlock :
    { CaseClausesopt }
    { CaseClausesopt DefaultClause CaseClausesopt }

    CaseClauses :
    CaseClause
    CaseClauses CaseClause

    CaseClause :
    case Expression : StatementListopt

    DefaultClause :
    default : StatementListopt
</code></pre><p>【セマンティックス】</p>
    <p>　プロダクション</p>
<pre><code>SwitchStatement : switch ( Expression ) CaseBlock
</code></pre><p>は、次のように評価されます。</p>
<pre><code>1. exprRef は、Expressionを評価した結果とする
    2. R は、パラメータとして GetValue(exprRef)を渡すことによってCaseBlockを評価した結果とする
    3. R.type が、 break 且つ、 R.target が、現在のラベルのセット内にある場合、return (normal, R.value, empty)
    4. Rを返す
</code></pre><p>　プロダクション</p>
<pre><code>CaseBlock : { CaseClausesopt }
</code></pre><p>は、入力パラメータ input が与えられ、次のように評価されます。</p>
<pre><code>1. V = empty とする
    2. A は、ソーステキスト順におけるCaseClauseアイテムのリストとする
    3. searching は、true とする
    4. searching が trueである間、繰り返す
    a. C は、 A にある次のCaseClauseとする、そのようなCaseClauseがない場合、return (normal, V, empty)
    b. clauseSelector は、C を評価した結果とする
    c. input が、 === 演算子によって定義したように clauseSelector と同等である場合、
    i. searching に false を設定
    ii. C が、StatementListを持つ場合、
    1. C のStatementListを評価し、 R は、 result とする
    2. R が、中途完了(an abrupt completion)である場合、R を返す
    3. V = R.value とする
    5.繰り返す
    a. C は、 A にある次のCaseClauseとする、もし、そのようなCaseClauseがない場合、return (normal, V, empty)
    b. C が、StatementListを持つ場合、
    i. C のStatementListを評価し、 R は、 result とする
    ii. R.value が、emptyではない場合、 V = R.valueとする
    iii. R が、中途完了(an abrupt completion)である場合、return (R.type, V, R.target)
</code></pre><p>　プロダクション</p>
<pre><code>CaseBlock : { CaseClausesopt DefaultClause CaseClausesopt }
</code></pre><p>は入力パラメータ input を与えられ、次のように評価されます。</p>
<pre><code>1. V = empty とする
    2. A は、ソーステキスト順において1つめのCaseClausesとなるCaseClauseアイテムのリストとする
    3. B は、ソーステキスト順において2つめのCaseClausesとなるCaseClauseアイテムのリストとする
    4. found は、falseとする
    5. AにあるCaseClauseごとに順に文字 C として繰り返す
    a. found が、 falseである場合、
    i. clauseSelector は、 C を評価した結果とする
    ii. input が、 === 演算子によって定義したようにclauseSelectorと同等である場合、 found に trueを設定
    b. found が、 trueである場合
    i. C が、StatementListを持つ場合、
    1. C のStatementListを評価し、 R は、 result とする
    2. R.value が、emptyではない場合、 V = R.value とする
    3. R が、中途完了(an abrupt completion)である場合、return (R.type, V, R.target)とする
    6. foundInB は、 falseとする
    7. found が、 falseである場合、
    a. foundInB 且つ、未処理の B の要素全てが、falseの間、繰り返す
    i. C は、B にある次のCaseClauseとする
    ii. clauseSelectorは、 Cを評価した結果とする
    iii. input が、 === 演算子によって定義したようにclauseSelectorと同等である場合、
    1. foundInB にtrueを設定
    2. C が、 StatementListを持つ場合、
    a CのStatementListを評価し、 R は、 resultとする
    b もし、 R.value が、emptyではない場合、 V = R.valueとする
    c もし、R が、中途完了(an abrupt completion)である場合、return (R.type, V, R.target)とする
    8. foundInB が、false且つ、 DefaultClause が、StatementListを持つ場合、
    a.DefaultClauseのStatementListを評価し、 R は、 resultとする
    b. R.value が、 emptyではない場合、 V = R.valueとする
    c. R 、中途完了(an abrupt completion)である場合、return (R.type, V, R.target)とする
    9.繰り返す(注記として ステップ 7.a.i が実行される場合には、このループは、Bの始点で始まらない)
    a. C は、Bにある次のCaseClauseとする、そのようなCaseClauseがない場合、return (normal, V, empty)とする
    b. C が、StatementListを持つ場合、
    i. C のStatementListを評価し、 R は、resultとする
    ii. R.value が、 emptyではない場合、 V = R.value とする
    iii. R が、中途完了(an abrupt completion)である場合、return (R.type, V, R.target)とする
</code></pre><p>　プロダクション</p>
<pre><code>CaseClause : case Expression : StatementListopt
</code></pre><p>は、次のように評価されます。</p>
<pre><code>1. exprRef は、Expressionを評価した結果とする
    2. GetValue(exprRef)を返す
</code></pre><p>[注釈]</p>
    <p>　評価中のCaseClauseは、関連するStatementListを実行しません。 それは、単にExpressionを評価し、どのStatementListの実行を開始するかを決める為に使用されるCaseBlockアルゴリズムにおける値を返します。</p>
    <h2 id="12-12-labelled-statements-standard-ecma-262-5-1-edition">12.12 ラベル付き文 / Labelled Statements / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="12-">12 ステートメント／文</h3>
    <h3 id="12-12-">12.12 ラベル付き文</h3>
<pre><code>【構文】
    LabelledStatement :
    Identifier : Statement
</code></pre><p>【セマンティックス】</p>
    <p>　Statementは、ラベルで前置される場合があります。 ラベルづけした文は、ラベル付けした break と継続する文を伴う接続詞の中でだけ使用されます。 ECMAScriptには、 goto 文はありません。</p>
    <p>　ECMAScriptのプログラムは、ラベルとしての同一の識別子を伴うLabelledStatementによって括られるLabelledStatementを含む場合、構文上の誤りであると考えられます。 これは、ラベル付けした文の内側で直接または間接的にネストされるFunctionDeclarationの本体内に現れるラベルには適用しません。</p>
    <p>　プロダクション Identifier : Statement は、Statementとその際に評価中のStatementのラベルのセットに識別子を追加することによって評価されます。 LabelledStatementそれ自身が、カラではないラベルのセットを持つ場合、これらのラベルもまた、それを評価する前にStatementのラベルのセットに追加されます。 評価中のStatementの結果が、L が識別子と同等である場合において(break, V, L)である場合、当該プロダクションは、(normal, V, empty)内にある結果となります。</p>
    <p>　LabelledStatementの評価に先だって、含まれるStatementは、カラである1つ要素から成るラベルのセットを処理中であるものとみなされる状況におけるIterationStatement や SwitchStatementである場合を除き、カラのラベルのセットを処理中であるものとみなされます。</p>
    <h2 id="12-13-throw-the-throw-statement-standard-ecma-262-5-1-edition">12.13 throw 文 / The throw Statement / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="12-">12 ステートメント／文</h3>
    <h3 id="12-13-throw-">12.13 throw 文</h3>
<pre><code>【構文】
    ThrowStatement :
    throw [no LineTerminator here] Expression ;
</code></pre><p>【セマンティックス】</p>
    <p>　プロダクション</p>
<pre><code>ThrowStatement : throw [no LineTerminator here] Expression ;
</code></pre><p>は、次のように評価されます。</p>
<pre><code>1. exprRef は、Expressionを評価した結果とする
    2. return (throw, GetValue(exprRef), empty)
</code></pre><h2 id="12-14-try-the-try-statement-standard-ecma-262-5-1-edition">12.14 try 文 / The try Statement / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="12-">12 ステートメント／文</h3>
    <h3 id="12-14-try-">12.14 try 文</h3>
<pre><code>【構文】
    TryStatement :
    try Block Catch
    try Block Finally
    try Block Catch Finally

    Catch :
    catch ( Identifier ) Block

    Finally :
    finally Block
</code></pre><p>　 try 文は、 ランタイムエラー(実行時エラー)や throw 文のように現れる例外的な条件についてコードのブロックで括ります。 catch 句は、例外操作(exception-handling)コードを提供します。 catch 句が、例外を捕捉した場合、その識別子は、例外にバインド(連結・結合)されます。</p>
    <p>【セマンティックス】</p>
    <p>　プロダクション</p>
<pre><code>TryStatement : try Block Catch
</code></pre><p>は、次のように評価されます。</p>
<pre><code>1. B は、Blockを評価した結果とする
    2. B.type が、throwではない場合、Bを返す
    3.パラメータ B.value を伴う Catch を評価した結果を返す
</code></pre><p>　プロダクション</p>
<pre><code>TryStatement : try Block Finally
</code></pre><p>は、次のように評価されます。</p>
<pre><code>1. B は、Blockを評価した結果とする
    2. F は、Finallyを評価した結果とする
    3. F.type が、normalである場合、 Bを返す
    4. F を返す
</code></pre><p>　プロダクション</p>
<pre><code>TryStatement : try Block Catch Finally
</code></pre><p>は、次のように評価されます。</p>
<pre><code>1. B は、Blockを評価した結果とする
    2. B.type が、 throwである場合、
    a. C は、パラメータ B.valueを伴う Catch を評価した結果とする
    3.それ以外の場合、 B.type が、throwではない場合、
    a. C は、 Bとする
    4. F は、Finallyを評価した結果とする
    5. F.type が、normalである場合、Cを返す
    6. F を返す
</code></pre><p>　プロダクション</p>
<pre><code>Catch : catch ( Identifier ) Block
</code></pre><p>は、次のように評価されます。</p>
<pre><code>1. C は、このプロダクションに解釈されるパラメータとする
    2. oldEnv は、実行中の実行コンテキストのLexicalEnvironmentとする
    3. catchEnv は、引数として oldEnv を渡すことによってNewDeclarativeEnvironmentを呼んだ結果とする
    4.引数として識別子のString値を渡すことによって catchEnv の具体的なメソッドCreateMutableBindingを呼ぶ
    5.引数として識別子、C、falseを渡すことによって catchEnv の具体的なメソッドSetMutableBindingを呼ぶ、注釈としては、最後の引数は、このような状況下では、さして重要ではない
    6.実行中の実行コンテキストのLexicalEnvironmentをcatchEnvに設定
    7. B は、Blockを評価した結果とする
    8.実行中の実行コンテキストのLexicalEnvironmentをoldEnvに設定
    9. B を返す
</code></pre><p>[注釈]</p>
    <p>　操作が、どれほどBlockを残したとしてもLexicalEnvironmentは、常に元の状態に復元されます。</p>
    <p>　プロダクション</p>
<pre><code>Finally : finally Block
</code></pre><p>は、次のように評価されます。</p>
<pre><code>1.Blockを評価した結果を返す
</code></pre><h3 id="12-14-1-strict-strict-mode-restrictions">12.14.1 strict(厳格)モードの制限・制約 ／ Strict Mode Restrictions</h3>
    <p>　 Catch を伴うTryStatementがstrict(厳格)コード内で現れたり、 Catch プロダクションの識別子が、“eval” または、 “arguments”の何れかである場合には、SyntaxErrorです。</p>
    <h2 id="12-15-debugger-the-debugger-statement-standard-ecma-262-5-1-edition">12.15 debugger 文 / The debugger statement / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="12-">12 ステートメント／文</h3>
    <h3 id="12-15-debugger-">12.15 debugger 文</h3>
<pre><code>【構文】
    DebuggerStatement :
    debugger ;
</code></pre><p>【セマンティックス】</p>
    <p>　評価中のDebuggerStatementプロダクションは、debuggerの下で実行する際、ブレークポイントに起因する実装を許容する場合があります。 debuggerが存在しない場合やこの文がアクティブではない場合、観測可能な効果は、何もありません。</p>
    <p>　プロダクション</p>
<pre><code>DebuggerStatement : debugger ;
</code></pre><p>は、次のように評価されます。</p>
<pre><code>1.実装定義のデバッグ機能が利用可能であり、使用可能な状態にある場合、
    a.実装定義済みのデバッグアクションを実行
    b. result は、実装定義の Completion 値とする
    2.それ以外の場合、
    a. result は、(normal, empty, empty)とする
    3.resultを返す
</code></pre><h2 id="13-function-definition-standard-ecma-262-5-1-edition">13 関数定義 / Function Definition / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="13-">13 関数定義</h3>
<pre><code>【構文】
    FunctionDeclaration :
    function Identifier ( FormalParameterListopt ) { FunctionBody }

    FunctionExpression :
    function Identifieropt ( FormalParameterListopt ) { FunctionBody }

    FormalParameterList :
    Identifier FormalParameterList , Identifier

    FunctionBody : SourceElementsopt
</code></pre><p>【セマンティックス】</p>
    <p>プロダクション</p>
<pre><code>FunctionDeclaration : function Identifier ( FormalParameterListopt ) { FunctionBody }
</code></pre><p>は、宣言結合のインスタンス化 (10.5 Declaration Binding instantiation )中で次のようにインスタンス化されます。</p>
<pre><code>1.FormalParameterListoptによって指定したパラメータとFunctionBodyによって指定したボディを伴う 13.2 で指定したような新たなFunctionオブジェクトを生成した結果を返す
    Scopeとして実行中の実行コンテキストのVariableEnvironmentに渡す
    FunctionDeclarationがstrict(モードの)コードに含まれる場合、当該FunctionBodyが、strict(モードの)コードである場合には、Strictフラグとしてtrueを渡す
</code></pre><p>プロダクション</p>
<pre><code>FunctionExpression : function ( FormalParameterListopt ) { FunctionBody }
</code></pre><p>は、次のように評価されます。</p>
<pre><code>1.FormalParameterListoptによって指定したパラメータとFunctionBodyによって指定したボディを伴う 13.2 で指定したような新たなFunctionオブジェクトを生成した結果を返す
    Scopeとして実行中の実行コンテキストのLexicalEnvironmentに渡す
    FunctionExpressionが、strict(モードの)コードに含まれる場合、当該FunctionBodyが、strict(モードの)コードである場合には、Strictフラグとしてtrueを渡す
</code></pre><p>プロダクション</p>
<pre><code>FunctionExpression : function Identifier ( FormalParameterListopt ) { FunctionBody }
</code></pre><p>は、次のように評価されます。</p>
<pre><code>1. funcEnv は、引数として実行中の実行コンテキストの語彙環境を渡すことによってNewDeclarativeEnvironmentを呼んだ結果とする
    2. envRec は、funcEnvの環境レコードとする
    3.引数として識別子のString値を渡すことによって envRec の具体的なメソッドCreateImmutableBindingを呼ぶ
    4. closure は、FormalParameterListoptによって指定したパラメータとFunctionBodyによって指定したボディを伴う 13.2 で指定したような新たなFunctionオブジェクトを生成した結果とする
    Scopeとして funcEnv 内で渡す
    FunctionExpressionが、strict(モードの)コードに含まれる場合や、そのFunctionBodyが、strict(モードの)コードである場合には、Strictフラグとしてtrueを渡す
    5.引数としてIdentifierとclosureのString値を渡すことによって envRec の具体的なメソッドInitializeImmutableBindingを呼ぶ
    6. closureを返す
</code></pre><p>[注釈]</p>
    <p>　 FunctionExpression (関数式) 内の識別子は、それ自身を再帰的に呼ぶ関数を許容する為に FunctionExpression の FunctionBody (関数本体)内から参照されることが可能です。 しかしながら、(この項冒頭の【構文】の) FunctionDeclaration (関数宣言)内とは異なり、 FunctionExpression (関数式)そのものに含まれる Identifier (つまり、関数名としての Identifier )は、参照不可であり、 FunctionExpression を括るスコープへの影響はありません。</p>
    <p>プロダクション</p>
<pre><code>FunctionBody : SourceElementsopt
</code></pre><p>は、次のように評価されます。</p>
<pre><code>1. FunctionBodyの code は、FunctionDeclaration や FunctionExpressionの一部が、strict(モードの)コードに含まれる場合、または、当該SourceElementsの指定プロローグ (14.1 指定プロローグ)が、Use Strict 指定を含む場合、または、10.1.1 内の条件の一部を適用する場合には、strictモードのコード
    このFunctionBodyのコードが、strictモードのコードである場合、SourceElementsは、strictモードのコードのように次のステップで評価
    それ以外の場合には、SourceElementsは、非strictモードのコードのように次のステップで評価
    2. SourceElementsが、存在する場合には、SourceElementsを評価した結果を返す
    3.それ以外の場合、return (normal, undefined, empty)
</code></pre><h3 id="13-1-strict-strict-mode-restrictions">13.1 厳格(strict)モードの制限・制約 ／ Strict Mode Restrictions</h3>
    <p>　識別子の値がstrictモードのFunctionDeclaration や FunctionExpressionのFormalParameterList内に1つ以上現れる場合には、SyntaxErrorエラーです。</p>
    <p>　識別子 “eval” や識別子 “arguments” が、strictモードのFunctionDeclaration や FunctionExpressionのFormalParameterList内に現れる場合には、SyntaxErrorエラーです。</p>
    <p>　識別子 “eval” や識別子 “arguments” が、strictモードのFunctionDeclaration や FunctionExpressionの識別子として現れる場合には、SyntaxErrorエラーです。</p>
    <h3 id="13-2-function-">13.2 Functionオブジェクトを生成</h3>
    <p>　オプションのFormalParameterListによって指定したパラメータリスト、FunctionBodyによって指定した本体、Scopeによって指定した語彙環境、Booleanフラグ Strict と Functionオブジェクトを与えた場合には、次のように構築されます。</p>
<pre><code>1.新たにネイティブなECMAScriptオブジェクトを生成し、F は、オブジェクトとする
    2. 8.12で説明したような F から成る[[Get]]を除く内部メソッドを全て設定
    3. F の[[Class]]内部プロパティに&quot;Function&quot;を設定
    4. F の[[Prototype]]内部プロパティに15.3.3.1で指定したように標準組み込みFunctionプロトタイプオブジェクトを設定
    5. 15.3.5.4で説明したように F から成る[[Get]]内部プロパティを設定
    6. 13.2.1で説明したように F から成る[[Call]]内部プロパティを設定
    7. 13.2.2で説明したように F から成る[[Construct]]内部プロパティを設定
    8. 15.3.5.3で説明したように F から成る[[HasInstance]]内部プロパティを設定
    9. F の[[Scope]]内部プロパティにScopeの値を設定
    10. names は、FormalParameterListの識別子と一致する文字列であり、左から右に向かってテキスト順で含まれる List とする
    もし、指定されるパラメータがない場合には、 names は、カラのリストとする
    11. F の[[FormalParameters]]内部プロパティにnamesを設定
    12. F の[[Code]]内部プロパティにFunctionBodyを設定
    13. F の[[Extensible]]内部プロパティにtrueを設定
    14. len は、FormalParameterListで指定した正規のパラメータの数とする
    もし、指定されるパラメータがない場合には、 len は、0とする
    15.引数 &quot;length&quot;、プロパティ記述子 {[[Value]]: len, [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false}、falseを伴う F の[[DefineOwnProperty]]内部プロパティを呼ぶ
    16. proto は、名称を伴う標準組み込みコンストラクタであるObjectとなる式 new Object() によって構築されるかのように新たなオブジェクトを生成した結果とする
    17.引数 &quot;constructor&quot;、プロパティ記述子 {[[Value]]: F, { [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true}、 falseを伴う proto の内部メソッド[[DefineOwnProperty]]を呼ぶ
    18.引数  &quot;prototype&quot;、プロパティ記述子  {[[Value]]: proto, { [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false}、 falseを伴う F の内部メソッド[[DefineOwnProperty]]を呼ぶ
    19. Strict が、trueである場合、
    a. thrower は、 [[ThrowTypeError]] 関数オブジェクト (13.2.3)とする
    b.引数 &quot;caller&quot;、PropertyDescriptor {[[Get]]: thrower, [[Set]]: thrower, [[Enumerable]]: false, [[Configurable]]: false}、falseを伴う F の内部メソッド[[DefineOwnProperty]]を呼ぶ
    c.引数 &quot;arguments&quot;、PropertyDescriptor {[[Get]]: thrower, [[Set]]: thrower, [[Enumerable]]: false, [[Configurable]]: false}、falseを伴う F の内部メソッド[[DefineOwnProperty]]を呼ぶ
    20. F を返す
</code></pre><p>[注釈]</p>
    <p>　prototype プロパティは、コンストラクタとして使用される関数という可能性を許容する為に関数ごとに自動的に生成されます。</p>
    <h3 id="13-2-1-call-">13.2.1 [[Call]]</h3>
    <p>　Functionオブジェクト F における内部メソッド[[Call]]が、 this 値と引数のリストを伴って呼ばれる際には、次のステップがとられます。</p>
<pre><code>1. funcCtx は、10.4.3で説明したように引数リスト args と this 値を渡すことによって F の内部プロパティ[[FormalParameters]]の値を使用して関数コードにおける新たな実行コンテキストを生成した結果とする
    2. result は、 F の内部プロパティ[[Code]]の値であるFunctionBodyを評価した結果とする
    F が内部プロパティ[[Code]]を持たない場合や当該値がカラのFunctionBodyである場合、 result は、(normal, undefined, empty) とする
    3.実行コンテキスト以前に復元中に、実行コンテキスト funcCtx を抜ける
    4. result.type が、 throwである場合、 result.value を投げる(スローする)
    5. result.type が、 returnである場合、 result.value を返す
    6.それ以外の場合、 result.type は、normalとしなければならず、またundefinedを返す
</code></pre><h3 id="13-2-2-construct-">13.2.2 [[Construct]]</h3>
    <p>　関数オブジェクト F　における内部メソッド[[Construct]]が、引数として利用可能なカラのリストを伴って呼ばれる場合、次のステップがとられます。</p>
<pre><code>1. obj は、新たに生成したネイティブECMAScriptオブジェクトとする
    2. 8.12で指定したように obj の全ての内部メソッドを設定
    3. obj の内部プロパティ[[Class]]に&quot;Object&quot;を設定
    4. obj の内部プロパティ[[Extensible]]に trueを設定
    5. proto は、引数&quot;prototype&quot;を伴う F の内部プロパティ[[Get]]を呼ぶ値とする
    6. Type(proto) が、 Objectであれば、 obj の内部プロパティ[[Prototype]]に protoを設定
    7. Type(proto) が、 Objectでなければ、 obj の内部プロパティ[[Prototype]]に 15.2.4で説明したように標準組み込みObject型プロトタイプオブジェクトを設定
    8. resultは、this 値として obj を提供し、 args として[[Construct]]に渡した引数リストの提供することによって F の内部プロパティ[[Call]]を呼んだものを結果とする
    9. Type(result) が、Objectである場合、 result を返す
    10. objを返す
</code></pre><h3 id="13-2-3-throwtypeerror-">13.2.3 [[ThrowTypeError]] 関数オブジェクト</h3>
    <p>　[[ThrowTypeError]] オブジェクトは、次のように1度だけ定義される一意の関数オブジェクトです。</p>
<pre><code>1.新たなネイティブECMAScriptオブジェクトを生成し、 F は、オブジェクトとする
    2. 8.12で説明したように F の全ての内部プロパティを設定
    3. F の内部プロパティ[[Class]]に&quot;Function&quot;を設定
    4. F の内部プロパティ[[Prototype]]に 15.3.3.1で指定したように標準組み込みFunctionプロトタイプオブジェクトを設定
    5. 13.2.1で説明したように F の内部プロパティ[[Call]]を設定
    6. F の内部プロパティ[[Scope]]にGlobal環境を設定
    7. F の内部プロパティ[[FormalParameters]]にカラのリストを設定
    8. F の内部プロパティ[[Code]]に無条件にTypeError例外を投げ(スローし)、他に実行するものが何もないFunctionBodyとして設定
    9.引数&quot;length&quot;、プロパティ記述子 {[[Value]]: 0, [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false}、 falseを伴う F の内部メソッド[[DefineOwnProperty]]を呼ぶ
    10. F の内部プロパティ[[Extensible]]に falseを設定
    11. [[ThrowTypeError]]は、F とする
</code></pre><h2 id="14-program-standard-ecma-262-5-1-edition">14 プログラム / Program / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="14-">14 プログラム</h3>
<pre><code>【構文】
    Program :
    SourceElementsopt

    SourceElements :
    SourceElement
    SourceElements SourceElement

    SourceElement :
    Statement
    FunctionDeclaration
</code></pre><p>【セマンティックス】</p>
    <p>プロダクション</p>
<pre><code>Program : SourceElementsopt
</code></pre><p>は、次のように評価されます。</p>
<pre><code>1.このProgramのコードは、指定プロローグ (14.1 指定プロローグ)が、 Use Strict 指定を含む当該SourceElementsから成る場合や一部が、 10.1.1を適用した条件から成る場合、strict mode(厳格モード)のコード
    Programのコードが、strict mode(厳格モード)のコードである場合、SourceElementsは、strict mode(厳格モード)のコードのように次のステップ内で評価され、それ以外は、SourceElementsは、非strict mode(厳格モード)のコードのように次のステップ内で評価される
    2. SourceElementsが、存在しない場合には、return (normal, empty, empty)
    3. progCxt は、 10.4.1で説明したようにグローバルコードにおける新たな実行コンテキストとする
    4. result は、SourceElementsを評価した結果とする
    5.実行コンテキスト progCxt を抜ける
    6. resultを返す
</code></pre><p>[注釈]</p>
    <p>　Programの評価を初期化中、また、このような評価の結果を伴う処理中における複数のプロセスは、この仕様によって定義されるのではなく、ECMAScriptの実装によって定義されます。</p>
    <p>プロダクション</p>
<pre><code>SourceElements : SourceElements SourceElement
</code></pre><p>は、次のように評価されます。</p>
<pre><code>1. headResult は、SourceElementsを評価した結果とする
    2. headResult が、中途完了(an abrupt completion)である場合、 headResultを返す
    3. tailResult は、SourceElementを評価した結果とする
    4. tailResult.value が、 emptyである場合、 V = headResult.value とし、それ以外の場合、 V = tailResult.valueとする
    5. return (tailResult.type, V, tailResult.target)
</code></pre><p>プロダクション</p>
<pre><code>SourceElement : Statement
</code></pre><p>は、次のように評価されます。</p>
<pre><code>1. Statementを評価した結果を返す
</code></pre><p>プロダクション</p>
<pre><code>SourceElement : FunctionDeclaration
</code></pre><p>は、次のように評価されます。</p>
<pre><code>1. return (normal, empty, empty).
</code></pre><h2 id="14-1-use-strict-directive-prologues-and-use-strict-directive-standard-ecma-262-5-1-edition">14.1 指定プロローグとUse Strict 指定 / Directive Prologues and Use Strict Directive / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="14-">14 プログラム</h3>
    <h3 id="14-1-use-strict-">14.1 指定プロローグとUse Strict 指定</h3>
    <p>　指定プロローグ(前置指定)は、Program (プログラム)や FunctionBody (関数本体)の最初の SourceElement (ソース要素)プロダクション、また、セミコロンに続けて StringLiteral (文字列リテラル・文字そのままの)トークン (字句)全体を構成する並びにある各 ExpressionStatement (式文・式の文)として現れる ExpressionStatement プロダクションの最も長い並びです。 セミコロンは、明示的に現れる場合や自動セミコロン挿入によって挿入される場合があります。 指定プロローグは、カラの並びになることもあります。</p>
    <p>　Use Strict指定は、正確な文字の並び “use strict” や ’use strict’の何れかのStringLiteralを持つ指定プロローグ内のExpressionStatementです。 Use Strict指定は、EscapeSequence (エスケープシーケンス・エスケープ文字の並び)や LineContinuation (行継続)を含まない場合もあります。</p>
    <p>　指定プロローグは、1つ以上のUse Strict指定を含む場合があります。 しかしながら、ある実装は、これが現れる場合、警告を発する場合があります。</p>
    <p>[注釈]</p>
    <p>　指定プロローグのExpressionStatementプロダクションは、通常、含まれているSourceElementsプロダクションの評価中に評価されます。 実装は、Use Strict指定がなく、指定プロローグ内に現れる ExpressionStatement プロダクションという実装仕様上の意味を定義する場合があります。 適切な通知の仕組みが存在する場合、指定プロローグ内でUse Strict指定がなかったり、実装によって定義した意味を持たない ExpressionStatement に遭遇した場合、実装は、警告を発するべきです。</p>
    <h2 id="15-ecmascript-standard-built-in-ecmascript-objects-standard-ecma-262-5-1-edition">15 標準組み込みECMAScriptオブジェクト / Standard Built-in ECMAScript Objects / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="15-ecmascript-">15 標準組み込みECMAScriptオブジェクト</h3>
    <p>　特定の組み込みオブジェクトは、ECMAScriptプログラムが実行を開始する度に利用可能です。 その1つとしてGlobalオブジェクトは、実行中のプログラムの語彙的な環境の一部です。 それ以外は、Globalオブジェクトの内部プロパティとしてアクセス可能です。</p>
    <p>　特段に記述されない限りにおいては、組み込みオブジェクトの内部プロパティ[[Class]]は、その組み込みオブジェクトが内部プロパティ[[Call]]を持つ場合には、“Function”であり、その組み込みオブジェクトが内部プロパティ[[Call]]を持たない場合には、“Object”です。 特段に記述されない限りにおいては、組み込みオブジェクトの内部プロパティ[[Extensible]]は、最初は値trueを持ちます。</p>
    <p>　多くの組み込みオブジェクトは関数であり、引数を伴って実行することが可能です。 それらの内の一部は、更にコンストラクタであり、それらは、new 演算子を伴って使用することを意図した関数です。 各組み込み関数について、この仕様は、関数とFunctionオブジェクトのプロパティによって要求される引数を説明します。 各組み込み関数について、この仕様は、更にコンストラクタのプロトタイプオブジェクトのプロパティ、また、コンストラクタを実行する式 new によって返される特定のオブジェクトのインスタンスを指定するプロパティを説明します。</p>
    <p>　特定の関数の概要について特段の記述がない場合には、この項で説明した関数やコンストラクタが、1つ以上の複数の引数を要求することが記述された関数を与えられる場合、その関数やコンストラクタは、引数がundefinedという値(未定義値)である場合にも、まるで十分にオプションの引数があったかのように確実に動作させましょう。</p>
    <p>　特定の関数の概要について特段の記述がない場合には、この項で説明した関数やコンストラクタが、1つ以上の複数の引数を許容することが記述された関数を与えられる場合、呼ぶまでは評価される余分な引数は、関数によって無視されます。 しかしながら、実装は、余分な引数の存在について単に述部であるTypeError例外を投げる(スローする)ことなく、このような動作と同じ length (一般的に取るべき引数の数を示すプロパティ)の引数と関連する実装固有の動作を定義する場合があります。</p>
    <p>[注釈]</p>
    <p>　組み込み関数の設定における付加的な機能を追加する実装においては、既存の関数に新たなパラメータを追加するのではなく、新たな関数を追加することによってそうすることが推奨されます。</p>
    <p>　各組み込み関数と組み込みコンストラクタには、その内部プロパティ[[Prototype]]の値として式 Function.prototype (15.3.4) という初期値を持つFunctionプロトタイプオブジェクトがあります。</p>
    <p>　特段の記述がない限り、各組み込みプロトタイプオブジェクトには、そのオブジェクト型プロトタイプオブジェクトを除き、その内部プロパティ[[Prototype]]の値として式 Object.prototype (15.2.4)の初期値であるObject型のプロトタイプオブジェクトがあります。</p>
    <p>　この項で説明した組み込み関数の注釈としては、コンストラクタは、特定の関数の説明に記述されない限り、内部メソッド[[Construct]]を実装することはありません。 この項で説明した組み込み関数の注釈としては、コンストラクタは、特定の関数の説明に記述されない限り、prototypeプロパティを持ちます。 この項では、コンストラクタが「関数として呼ばれる場合」と「 new 式の一部として呼ばれる場合」で異なる動作について一般的な説明をします。</p>
    <p>　「関数として呼ばれる場合」は、コンストラクタの内部メソッド[[Call]]の呼び出しと一致する動作をし、「 new 式の一部として呼ばれる場合」には、コンストラクタの内部メソッド[[Construct]]の呼び出しと一致する動作をします。</p>
    <p>　この項の中で説明したコンストラクタ、通常の関数、または両方である各組み込みFunctionオブジェクトは、値が整数であるlengthプロパティを持っています。 特段の記述がない限り、この値は、オプションのパラメータを含んでいる場合、関数概要における節の見出しで表示した名前付き引数の最大値と同等です。</p>
    <p>[注釈]</p>
    <p>　例えば、Stringプロトタイプオブジェクトの slice プロパティの初期値であるFunctionオブジェクトは、節の見出しであり、2つの名前付き引数 start と endを表示する“String.prototype.slice (start, end)”の下で説明されるので、よってFunctionオブジェクトにおける length プロパティの値は、2 になります。</p>
    <p>　状況に応じてこの項で説明した組み込みFunctionオブジェクトの length プロパティは、属性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false } を持ちます。 この項で説明した他のプロパティのそれぞれは、特段の記述がない限り、属性 { [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true } を持ちます。</p>
    <h2 id="15-1-global-the-global-object-standard-ecma-262-5-1-edition">15.1 Globalオブジェクト / The Global Object / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="15-ecmascript-">15 標準組み込みECMAScriptオブジェクト</h3>
    <h3 id="15-1-global-">15.1 Globalオブジェクト</h3>
    <p>　一意のGlobalオブジェクトは、操作が一部の実行コンテキストを入力する前に生成されます。</p>
    <p>　特段の記述がない限り、Globalオブジェクトの標準組み込みプロパティは、属性 {[[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true} を持ちます。</p>
    <p>　Globalオブジェクトは、内部プロパティ[[Construct]]を持たず、new 演算子を伴うコンストラクタとしてGlobalオブジェクトを使用することは不可能です</p>
    <p>　Globalオブジェクトは、内部プロパティ[[Call]]を持たず、関数としてGlobalオブジェクトを実行することは不可能です。</p>
    <p>　Globalオブジェクトの内部プロパティ[[Prototype]] と [[Class]]の値は、実装依存(implementation-dependent)です。</p>
    <p>　この仕様の中で定義したプロパティについての追記としては、Globalオブジェクトは、オプションでホスト定義のプロパティを持つ場合があります。 これは、Globalオブジェクトがそれ自身である値を持つプロパティを含む場合があるということであり、例えば、HTMLドキュメントオブジェクトモデルでは、Globalオブジェクトのwindowプロパティは、Globalオブジェクト自身です。</p>
    <h2 id="15-1-1-global-value-value-properties-of-the-global-object-standard-ecma-262-5-1-edition">15.1.1 GlobalオブジェクトのValueプロパティ / Value Properties of the Global Object / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="15-ecmascript-">15 標準組み込みECMAScriptオブジェクト</h3>
    <h3 id="15-1-global-">15.1 Globalオブジェクト</h3>
    <h3 id="15-1-1-global-value-">15.1.1 GlobalオブジェクトのValueプロパティ</h3>
    <h3 id="15-1-1-1-nan">15.1.1.1 NaN</h3>
    <p>　 NaN (Not a Number)プロパティの値は、 NaN ( 8.5 )です。 このプロパティは、属性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false } を持ちます。</p>
    <h3 id="15-1-1-2-infinity">15.1.1.2 Infinity</h3>
    <p>　Infinity (無限大)プロパティの値は、 +∞ ( 8.5 参照)です。 このプロパティは、属性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false } を持ちます。</p>
    <h3 id="15-1-1-3-undefined">15.1.1.3 undefined</h3>
    <p>　undefined (未定義)プロパティの値は、undefined ( 8.1 参照)です。 このプロパティは、属性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false } を持ちます。</p>
    <h2 id="15-1-2-global-function-function-properties-of-the-global-object-standard-ecma-262-5-1-edition">15.1.2 GlobalオブジェクトのFunctionプロパティ / Function Properties of the Global Object / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="15-ecmascript-">15 標準組み込みECMAScriptオブジェクト</h3>
    <h3 id="15-1-global-">15.1 Globalオブジェクト</h3>
    <h3 id="15-1-2-global-function-">15.1.2 GlobalオブジェクトのFunctionプロパティ</h3>
    <h3 id="15-1-2-1-eval-x-">15.1.2.1 eval (x)</h3>
    <p>　 eval 関数は、引数 x を1つ伴って呼ばれる場合、次のステップをとります。</p>
<pre><code>1. Type(x) が、Stringでない場合には、xを返す
    2. prog は、Programとして x を構文解析した結果であるECMAScriptのコードとする
    解析が失敗した場合、SyntaxError例外を投げる(が、第16項も参照)
    3. evalCtx は、 eval コードである  prog における新たな実行コンテキストを発行(10.4.2)した結果とする
    4. result は、プログラム prog を評価した結果とする
    5.実行コンテキストの前に復元中に実行中の実行コンテキスト evalCtx を抜ける
    6. result.type が、 normalで且つ、その完了値が、値 V である場合、その値 V を返す
    7. result.type が、 normalで且つ、その完了値が、empty(カラ)である場合、値undefinedを返す
    8.それ以外の場合、 result.type は、スローされなければならず、例外として result.value をスローする
</code></pre><h3 id="15-1-2-1-1-eval-">15.1.2.1.1 Evalを直接呼び出す</h3>
    <p>　 eval 関数を直接呼び出すということは、CallExpression (式を呼ぶこと)を表明されるということであり、次の2つの条件を満たしています。 CallExpression内でMemberExpressionを評価した結果である参照は、当該基準値と名称が“eval”である当該参照としての環境レコードを持ちます。 引数として参照を伴う抽象操作GetValueを呼んだ結果は、 15.1.2.1で定義した標準組み込み関数です。</p>
    <h3 id="15-1-2-2-parseint-string-radix-">15.1.2.2 parseInt (string , radix)</h3>
    <p>　 parseInt 関数は、 radixの指定による引数 string の内容の解釈によって決定した整数値を生成します。 文字列内の先行するホワイトスペースは、無視されます。 radix が、undefinedや0である場合、16という radix であると仮定されるケースにおいて数字が 0x や 0Xの文字の組み合わせを伴って始まる場合以外は、10であるものと仮定されます。 radixが、 16である場合には、数字が、オプションとして 0x や 0Xの文字の組み合わせを伴って始まる場合があります。</p>
    <p>　 parseInt 関数が呼ばれる場合、次のステップがとられます。</p>
<pre><code>1. inputString は、 ToString(string) とする
    2. S は、StrWhiteSpaceCharではなく、その文字に続く全ての文字である新たに生成した最初の文字で構成するinputStringの部分文字列とする
    (言い換えると先行するホワイトスペースを削除する)
    inputString が、そのような文字列を一切含まない場合、 S は、カラの文字列とする
    3. sign は、 1とする
    4. S が、カラでなく、且つ、S の最初の文字がマイナス記号 - である場合、sign は、-1 とする
    5. S が、カラでなく、且つ、S の最初の文字がプラス記号 + または、マイナス記号 - である場合には、S から最初の文字を削除する
    6. R = ToInt32(radix)とする
    7. stripPrefix は、 trueとする
    8. R ≠ 0である場合、
    a. R &lt; 2 または、 R &gt; 36 である場合、 NaNを返す
    b. R ≠ 16 である場合、 stripPrefix は、 falseとする
    9.それ以外の場合で R = 0 である場合、
    a. R = 10 とする
    10. stripPrefix が、 true である場合、
    a.もし、 Sの長さが、少なくとも 2で且つ、S の2つの文字が、&quot;0x&quot;または、&quot;0X&quot;の何れかである場合、S から最初の2文字を削除し、 R = 16 とする
    11.もし、 S が、 radix-R 桁ではない何らかの文字を含む場合、 Z は、そのような文字の先頭の前の全ての文字から成る S の部分文字列とし、それ以外の場合、 Z は、 Sとする
    12. Z が、 empty(カラ)である場合、 NaNを返す
    13. mathInt は、10から35までの値を伴う桁において文字 A-Z、または、a-zを使用して radix-R 記法における Z によって表した数学的な整数値とする
    (しかしながら、実装のオプションとして R が10で Zが、20桁以上を含む場合、それぞれの20番め以降の有効桁は、0桁に置き換えられる場合があり、また、 R が、2、4、8、10、16、32ではない場合、 mathInt は、 radix-R 記法である Z によって表した数学的な整数値における実装依存の近似値となる場合がある)
    14. number は、 mathIntにおけるNumber値とする
    15. sign x number を返す
</code></pre><p>[注釈]</p>
    <p>　 parseInt は、整数値として文字列の先頭部分でのみ解釈される場合があります。 それは、整数の表記法の一部として解釈されることができない一部の文字を無視したり、または、一部、そのような文字が無視された結果、表示されるものが何もないといったような場合です。</p>
    <h3 id="15-1-2-3-parsefloat-string-">15.1.2.3 parseFloat (string)</h3>
    <p>　 parseFloat 関数は、小数リテラルとして引数 stringの内容を解釈することによって決定されるNumber値を生成します。 parseFloat 関数が、呼ばれる場合、次のステップがとられます。</p>
<pre><code>1. inputString は、 ToString(string) とする
    2. trimmedString は、StrWhiteSpaceCharではなく、その文字の右にある全ての文字において最も左側の文字から成る inputString の部分文字列とする
    (言い換えると先行するホワイトスペースを削除する)
    inputString が、そのような文字を何も含まない場合、 trimmedString はカラの文字列とする
    3. trimmedString や StrDecimalLiteral ( 9.3.1 参照)の構文を満たす trimmedString の接頭辞の何れもない場合、 NaNを返す
    4. numberString は、StrDecimalLiteralの構文を満たすtrimmedString自身である場合もあるtrimmedStringの最も長い接頭辞とする
    5. numberString の MV におけるNumber値を返す
</code></pre><p>[注釈]</p>
    <p>　 parseFloat は、Number値として文字列の先頭位置だけを解釈する場合があります。 それは、小数リテラルの表記法の一部として解釈できない一部の文字を無視したり、そのような文字が無視された結果、表示されるものが何もないといったような場合です。</p>
    <h3 id="15-1-2-4-isnan-number-">15.1.2.4 isNaN (number)</h3>
    <p>　引数を強制的にNaNに変換する場合、trueを返し、それ以外の場合、falseを返します。</p>
<pre><code>1. ToNumber(number) が、NaNである場合、trueを返す
    2.それ以外の場合、falseを返す
</code></pre><p>[注釈]</p>
    <p>　値 X が、NaNである場合、テストの為のECMAScriptのコードにおける信頼性の高い方法は、 X !== X から成る式です。 X が、NaNである場合、結果は、trueとなるでしょう。</p>
    <h3 id="15-1-2-5-isfinite-number-">15.1.2.5 isFinite (number)</h3>
    <p>　引数を強制的に +∞ や -∞ に変換する場合、falseを返し、それ以外の場合、trueを返します。</p>
<pre><code>1. ToNumber(number) が、 NaN、 +∞、 -∞ である場合、falseを返す
    2.それ以外の場合、trueを返す
</code></pre><h2 id="15-1-3-uri-uri-handling-function-properties-standard-ecma-262-5-1-edition">15.1.3 URI 操作関数のプロパティ / URI Handling Function Properties / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="15-ecmascript-">15 標準組み込みECMAScriptオブジェクト</h3>
    <h3 id="15-1-global-">15.1 Globalオブジェクト</h3>
    <h3 id="15-1-3-uri-">15.1.3 URI 操作関数のプロパティ</h3>
    <p>　Uniform Resource Identifiers(URI)や URIsは、リソース(例：ウェブページやファイル)を識別する文字列であり、インターネット上でそれら(例：HTTPやFTP)にアクセスすることによる転送手続きです。 ECMAScript言語それ自身は、 15.1.3.1、15.1.3.2、15.1.3.3、15.1.3.4で説明したようにURIsを encode したり、 decode する関数を除き、URIs を使用するにあたり、いかなるサポートも提供しません。</p>
    <p>[注釈]</p>
    <p>　多くのECMAScriptの実装は、ウェブページを操作するオプションの関数とメソッドを提供します。 これらの関数は、この標準の範囲を超えています。</p>
    <p>　URIは、コンポーネントセパレータによって分割されたコンポーネントの並びで構成されます。 一般的な書式は、</p>
<pre><code>Scheme : First / Second ; Third ? Fourth
</code></pre><p>でイタリック体の名称は、コンポーネントを表し、 “:” 、 “/” 、 “;” 、 “?” は、区切り(セパレータ)として使用される予約文字です。 encodeURI と decodeURI 関数は、完全なURIsを伴って動作することが意図されます。 URIにある一部の予約文字であると仮定されるそれらは、特別な意味を持つことが意図されるので符号化されません。 encodeURIComponent と decodeURIComponent 関数は、URIの個別のコンポーネントの部品を伴って動作することが意図されます。 当該コンポーネントが完全なURIの一部である場合、一部の予約文字は、テキストを表すものと仮定し、予約文字として解釈されない為、符号化されなければなりません。 次の語彙的な文法は、符号化したURIsの書式を指定します。</p>
<pre><code>【構文】
    uri ::: uriCharactersopt

    uriCharacters :::
    uriCharacter uriCharactersopt

    uriCharacter :::
    uriReserved
    uriUnescaped
    uriEscaped

    uriReserved :::
    ; / ? : @ &amp; = + $ ,
    の内の1つ

    uriUnescaped :::
    uriAlpha
    DecimalDigit
    uriMark

    uriEscaped :::
    % HexDigit HexDigit

    uriAlpha :::
    a b c d e f g h i j k l m n o p q r s t u v w x y z
    A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
    の内の1つ

    uriMark :::
    - _ . ! ~ * &#39; ( )
    の内の1つ
</code></pre><p>[注釈]</p>
    <p>　上記の構文は、RFC 2396 に基づいており、直近の RFC 3986 によって導入された変更への影響はありません。</p>
    <p>　URIに含まれる文字が、上記に列挙されない場合、または、予約文字に与えられるある特別な意味を持つことを意図しない場合、その文字は、符号化されなければいけません。</p>
    <p>　文字は、コードポイント値が一致する UTF-16 から最初に変換したサロゲートペア( Unicode仕様化当初において予想外の収録可能文字数の不足を補う一環としてUnicode未定義領域の2文字で1文字として表現することとし、固定長UTF-16と互換性を持たせた拡張 )を伴い、その UTF-8 エンコード方式に変換されます。 (範囲[0,127]にあるコードユニットにおける注釈としては、これは、同じ値を伴う1つのオクテット(1オクテット = 8ビット)内での結果となります。) 結果となるオクテットの並びは、その場合、“%xx”から成るエスケープシーケンスによって表したそれぞれのオクテットを伴う文字列に変換されます。</p>
    <p>　エンコード方式とエスケープ処理は、2つの文字列の引数 string と unescapedSetを取って抽象操作Encodeによって説明されます。</p>
<pre><code>1. strLen は、string にある文字数とする
    2. R は、カラの文字列とする
    3. k は、0とする
    4.繰り返す
    a. k が、 strLenと同等である場合、 R を返す
    b. C は、 string 内の 位置 k にある文字とする
    c. C が、unescapedSet内にある場合、
    i. S は、文字 C だけに含まれる文字列とする
    ii. R は、 R と S の前の値を連結することによって算出した新たな文字列値とする
    d.それ以外の場合、 C は、unescapedSetに存在せず、
    i. C のコードユニット値が、 0xDC00 より小さくなく、 0xDFFFよりも大きくない場合、URIError例外を投げる(スローする)
    ii. C のコードユニット値が、 0xD800 よりも小さいか、または、 0xDBFFよりも大きい場合、
    1. V は、C のコードユニット値とする
    iii.それ以外の場合、
    1. k を 1で増分する
    2. k が、strLenである場合、URIError例外を投げる(スローする)
    3. kChar は、 string 内の位置 k にある文字のコードユニット値とする
    4. kChar が、 0xDC00 よりも小さいか、または、 0xDFFF よりも大きい場合、URIError例外を投げる(スローする)
    5. V は、 (((C のコードユニット値) - 0xD800) x 0x400 + (kChar - 0xDC00) + 0x10000) とする
    iv. Octets は、 UTF-8 変換を適用することによる結果であるオクテットの配列とし、 L は、配列のサイズとする
    v. j は、 0 とする
    vi.  while j &lt; L (のループを)繰り返す
    1. jOctet は、Octets 内の 位置 j にある値とする
    2. S は、XYが、 jOctet の16進数エンコード方式の値である2つの大文字である場合、 &quot;%XY&quot; という3文字を含む文字列とする
    3. R は、 R と S の前の値を連結することによって算出した新たな文字列値とする
    4. j を1で増分する
    e. k を 1で増分する
</code></pre><p>　復号・復号化(unescaping)と解読(decoding)処理は、2つの文字列の引数 string と reservedSet を取る抽象操作Decodeによって説明されます。</p>
<pre><code>1. strLen は、 stringにある文字数とする
    2. R は、カラの文字列とする
    3. k は、0とする
    4.繰り返す
    a. k が、 strLenと同等である場合、 Rを返す
    b. C は、string 内の位置 k にある文字とする
    c. C が、&#39;%&#39;ではない場合、
    i. S は、文字 C にのみ含まれる文字列とする
    d.それ以外の場合、 C は、&#39;%&#39;であり、
    i. start は、 kとする
    ii. k + 2 が、 strLen よりも大きいか等しい場合、URIError例外を投げる(スローする)
    iii. string内の 位置 (k + 1) と (k + 2) にある文字が、16進数字を表さない場合、URIError例外を投げる(スローする)
    iv. B は、 位置 (k + 1) と (k + 2) にある2つの16進数字によって表した 8ビットの値とする
    v. k を 2で増分する
    vi. Bにある最大有効ビットが、0である場合、
    1. C は、コードユニット値 B を伴う文字とする
    2. C が、reservedSetではない場合、 S は、文字 C にのみ含まれる文字列とする
    3. それ以外の場合、 C は、reservedSet内にあり、
    a  S は、位置 start から k が含まれる位置までの string における部分文字列とする
    vii.それ以外の場合、B にある最大有効ビットは、1であり、
    1. n は、 (B &lt;&lt; n) &amp; 0x80 が 0 と等価であるような最小の非負数とする
    2. n が、1または、nが、4より大きい場合、URIError例外を投げる(スローする)
    3. Octets は、サイズ n の8ビットの整数から成る配列とする
    4.位置 0 にある(配列) Octets に Bを入れる
    5. k + (3 x (n - 1)) が、 strLenより大きいか、等しい場合、URIError例外を投げる(スローする)
    6. j は、 1とする
    7. while j &lt; n (の条件下で)繰り返す
    a kを1で増分する
    b 位置 kにある文字が&#39;%&#39;ではない場合、URIError例外を投げる(スローする)
    c string内の位置 (k + 1) と (k + 2) にある文字が、16進数字を表さない場合、URIError例外を投げる(スローする)
    d Bは、位置 (k + 1) と (k + 2) にある2つの16進数字によって表した 8ビットの値とする
    e Bにある2つの最大有効ビットが、10ではない場合、URIError例外を投げる(スローする)
    f  k を 2で増分する
    g 位置 j にある(配列) Octets に B を入れる
    h j を1で増分する
    8. V は、 Octetsに UTF-8 変換を適用することによって得られた値とし、それは21ビット値におけるオクテットの配列から成る、Octetsが、Unicodeコードポイントの有効な UTF-8 エンコード方式を含まない場合、URIError例外を投げる(スローする)
    9. V が、 0x10000よりも小さい場合、
    a  C は、コードユニット値 V を伴う文字とする
    b  C が、reservedSet内に存在しない場合、
    i. S は、文字 C にのみ含まれる文字列とする
    c それ以外の場合、 C は、reservedSet内に存在し、
    i. S は、位置 start から  k が含まれる位置までの文字列の部分文字列とする
    10.それ以外の場合、 V は、≧ 0x10000 であり、
    a  L は、 (((V - 0x10000) &amp; 0x3FF) + 0xDC00) とする
    b  H は、 ((((V - 0x10000) &gt;&gt; 10) &amp; 0x3FF) + 0xD800) とする
    c  S は、 コードユニット値 H と L を伴う2つの文字を含む文字列とする
    e. R は、R と S の前の値を連結することによって算出した新たな文字列値とする
    f. k を 1で増分する
</code></pre><p>[注釈]</p>
    <p>　このUniform Resource Identifiersの構文は、 RFC 2396 を基準としており、 RFC 2396 に置き換わる直近の RFC 3986 への影響はありません。 UTF-8 における正規の説明と実装は、 RFC 3629 でなされます。 UTF-8 では、文字は、1から6までのオクテットの並びを使って符号化されます。 1つの“sequence”(「並び」)から成るオクテットに限っては、上位ビットが0に設定され、残りの7ビットは文字の値を符号化する為に使用されます。 n オクテットの並びにおける n > 1 は、最初のオクテットは、上位の n ビットが1に設定され、0に設定されたビットによって続きます。 そのオクテットの残りのビットは、符号化される文字の値から成るビットを含みます。 次のオクテットの全ては、上位のビットが1、次のビットは0に設定され、残りの6ビットは、それぞれの中に符号化される文字から成るビットを含みます ECMAScriptの文字において利用可能なUTF-8エンコード方式は、Table 21で指定されます。</p>
<pre><code>Table 21 -- UTF-8 エンコード方式
    ------------------------------------------------------------------------------------------------------------
    コードユニット値    表示          1番めのOctet   2番めのOctet   3番めのOctet   4番めのOctet
    ------------------------------------------------------------------------------------------------------------
    0x0000 - 0x007F     00000000 0zzzzzzz   0zzzzzzz
    ------------------------------------------------------------------------------------------------------------
    0x0080 - 0x07FF     00000yyy yyzzzzzz   110yyyyy    10zzzzzz
    ------------------------------------------------------------------------------------------------------------
    0x0800 - 0xD7FF     xxxxyyyy yyzzzzzz   1110xxxx    10yyyyyy    10zzzzzz
    ------------------------------------------------------------------------------------------------------------
    0xD800 - 0xDBFF     110110vv vvwwwwxx   11110uuu    10uuwwww    10xxyyyy    10zzzzzz
    に以下が続く      に以下が続く
    0xDC00 - 0xDFFF     110111yy yyzzzzzz
    ------------------------------------------------------------------------------------------------------------
    0xD800 - 0xDBFF
    に以下が続かない    URIErrorを引き起こす
    0xDC00 - 0xDFFF
    ------------------------------------------------------------------------------------------------------------
    0xDC00 - 0xDFFF     URIErrorを引き起こす
    ------------------------------------------------------------------------------------------------------------
    0xE000 - 0xFFFF     xxxxyyyy yyzzzzzz   1110xxxx    10yyyyyy    10zzzzzz
    ------------------------------------------------------------------------------------------------------------
</code></pre><p>以下の</p>
<pre><code>uuuuu = vvvv + 1
</code></pre><p>は、Unicode標準規格のセクション 3.7 サロゲート内にあるように 0x10000 として追加する為のアカウントの場所です。</p>
    <p>　コードユニット値の範囲 0xD800-0xDFFF は、サロゲートペアを符号化する為に使用されます。 上記変換は、 UTF-32 表現について UTF-16 のサロゲートペアを結合し、 UTF-8 にある 21ビット値を結果として符号化します。 解読(Decoding)は、サロゲートペアを再構築します。 RFC 3629 は、有効な UTF-8 オクテットシーケンスの解読を禁止しています。 例えば、有効な並び C0 80 は、文字 U+0000 を解読(デコード)してはいけません。 デコードアルゴリズムの実装は、このように有効な並びに遭遇する場合、URIErrorを投げる(スローする)ことを要求されます。</p>
    <h3 id="15-1-3-1-decodeuri-encodeduri-">15.1.3.1 decodeURI (encodedURI)</h3>
    <p>　decodeURI関数は、それが表す文字を伴って置換されるencodeURI関数によって導入される場合があるソート済みのエスケープシーケンスと UTF-8 エンコード方式ごとにURIの新たなバージョンを算出します。 encodeURIによって導入されていないエスケープシーケンスは、置換されません。 decodeURI関数が、1つの引数encodedURIを伴って呼ばれる場合、次のステップが取られます。</p>
<pre><code>1. uriString は、 ToString(encodedURI) とする
    2. reservedURISet は、&quot;#&quot;を加えた uriReserved 内にある有効な文字ごとの1つのインスタンスを含む文字列とする
    3. Decode(uriString, reservedURISet) を呼んだ結果を返す
</code></pre><p>[注釈]</p>
    <p>　文字“#”は、予約済みURI文字ではありませんが、エスケープシーケンスから解読(デコード)されることはありません。</p>
    <h3 id="15-1-3-2-decodeuricomponent-encodeduricomponent-">15.1.3.2 decodeURIComponent (encodedURIComponent)</h3>
    <p>　decodeURIComponent関数は、それが表す文字を伴って置換されるencodeURIComponentによって導入される場合があるソート済みのエスケープシーケンスと UTF-8 エンコード方式ごとにURIの新たなバージョンを算出します。 decodeURIComponent関数が1つの引数encodedURIComponentを伴って呼ばれる場合、次のステップが取られます。</p>
<pre><code>1. componentString は、 ToString(encodedURIComponent) とする
    2. reservedURIComponentSet は、カラの文字列とする
    3. Decode(componentString, reservedURIComponentSet)を呼んだ結果を返す
</code></pre><h3 id="15-1-3-3-encodeuri-uri-">15.1.3.3 encodeURI (uri)</h3>
    <p>　encodeURI関数は、文字の UTF-8 エンコード方式を表す1つ、2つ、3つまたは4つのエスケープシーケンスによって置換される特定の文字のインスタンスごとに新たなURIのバージョンを算出します。 encodeURI関数が、1つの引数 uri を伴って呼ばれる場合、次のステップが取られます。</p>
<pre><code>1. uriString は、 ToString(uri) とする
    2. unescapedURISet は、&quot;#&quot;を加えた uriReserved と uriUnescaped内にある有効な文字ごとのインスタンスを1つ含むStringとする
    3. Encode(uriString, unescapedURISet) を呼んだ結果を返す
</code></pre><p>[注釈]</p>
    <p>　文字“#”は、予約済みまたは、復号・復号化(アンエスケープ)されたURI文字ではありませんが、エスケープシーケンスに符号化(エンコード)されることはありません。</p>
    <h3 id="15-1-3-4-encodeuricomponent-uricomponent-">15.1.3.4 encodeURIComponent (uriComponent)</h3>
    <p>　encodeURIComponent関数は、文字の UTF-8 エンコード方式を表す1つ、2つ、3つまたは4つのエスケープシーケンスによって置換される特定の文字のインスタンスごとに新たなURIのバージョンを算出します。 encodeURIComponent関数が、1つの引数 uriComponent を伴って呼ばれる場合、次のステップが取られます。</p>
<pre><code>1. componentString は、 ToString(uriComponent) とする
    2. unescapedURIComponentSet は、uriUnescaped にある有効な文字ごとのインスタンスを1つ含むStringとする
    3.Encode(componentString, unescapedURIComponentSet)を呼んだ結果を返す
</code></pre><h2 id="15-1-4-global-constructor-properties-of-the-global-object-standard-ecma-262-5-1-edition">15.1.4 Globalオブジェクトのコンストラクタプロパティ / Constructor Properties of the Global Object / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="15-ecmascript-">15 標準組み込みECMAScriptオブジェクト</h3>
    <h3 id="15-1-global-">15.1 Globalオブジェクト</h3>
    <h3 id="15-1-4-global-">15.1.4 Globalオブジェクトのコンストラクタプロパティ</h3>
    <h3 id="15-1-4-1-object-">15.1.4.1 Object ( . . . )</h3>
    <p>15.2.1 と 15.2.2を参照</p>
    <h3 id="15-1-4-2-function-">15.1.4.2 Function ( . . . )</h3>
    <p>15.3.1 と 15.3.2を参照</p>
    <h3 id="15-1-4-3-array-">15.1.4.3 Array ( . . . )</h3>
    <p>15.4.1 と 15.4.2を参照</p>
    <h3 id="15-1-4-4-string-">15.1.4.4 String ( . . . )</h3>
    <p>15.5.1 と 15.5.2を参照</p>
    <h3 id="15-1-4-5-boolean-">15.1.4.5 Boolean ( . . . )</h3>
    <p>15.6.1 と 15.6.2を参照</p>
    <h3 id="15-1-4-6-number-">15.1.4.6 Number ( . . . )</h3>
    <p>15.7.1 と 15.7.2を参照</p>
    <h3 id="15-1-4-7-date-">15.1.4.7 Date ( . . . )</h3>
    <p>15.9.2を参照</p>
    <h3 id="15-1-4-8-regexp-">15.1.4.8 RegExp ( . . . )</h3>
    <p>15.10.3 と 15.10.4を参照</p>
    <h3 id="15-1-4-9-error-">15.1.4.9 Error ( . . . )</h3>
    <p>15.11.1 と 15.11.2を参照</p>
    <h3 id="15-1-4-10-evalerror-">15.1.4.10 EvalError ( . . . )</h3>
    <p>15.11.6.1を参照</p>
    <h3 id="15-1-4-11-rangeerror-">15.1.4.11 RangeError ( . . . )</h3>
    <p>15.11.6.2を参照</p>
    <h3 id="15-1-4-12-referenceerror-">15.1.4.12 ReferenceError ( . . . )</h3>
    <p>15.11.6.3を参照</p>
    <h3 id="15-1-4-13-syntaxerror-">15.1.4.13 SyntaxError ( . . . )</h3>
    <p>15.11.6.4を参照</p>
    <h3 id="15-1-4-14-typeerror-">15.1.4.14 TypeError ( . . . )</h3>
    <p>15.11.6.5を参照</p>
    <h3 id="15-1-4-15-urierror-">15.1.4.15 URIError ( . . . )</h3>
    <p>15.11.6.6を参照</p>
    <h2 id="15-1-5-global-other-properties-of-the-global-object-standard-ecma-262-5-1-edition">15.1.5 Globalオブジェクトのその他のプロパティ / Other Properties of the Global Object / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="15-ecmascript-">15 標準組み込みECMAScriptオブジェクト</h3>
    <h3 id="15-1-global-">15.1 Globalオブジェクト</h3>
    <h3 id="15-1-5-global-">15.1.5 Globalオブジェクトのその他のプロパティ</h3>
    <h3 id="15-1-5-1-math">15.1.5.1 Math</h3>
    <p>15.8を参照</p>
    <h3 id="15-1-5-2-json">15.1.5.2 JSON</h3>
    <p>15.12を参照</p>
    <h2 id="15-2-object-object-objects-standard-ecma-262-5-1-edition">15.2 Objectオブジェクト / Object Objects / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="15-ecmascript-">15 標準組み込みECMAScriptオブジェクト</h3>
    <h3 id="15-2-object-">15.2 Objectオブジェクト</h3>
    <h2 id="15-2-1-object-the-object-constructor-called-as-a-function-standard-ecma-262-5-1-edition">15.2.1 関数として呼ぶ Objectのコンストラクタ / The Object Constructor Called as a Function / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="15-ecmascript-">15 標準組み込みECMAScriptオブジェクト</h3>
    <h3 id="15-2-object-">15.2 Objectオブジェクト</h3>
    <h3 id="15-2-1-object-">15.2.1 関数として呼ぶ Objectのコンストラクタ</h3>
    <p>　Objectが、コンストラクタではなく、関数として呼ばれる場合、型変換が実行されます。</p>
    <h3 id="15-2-1-1-object-value-">15.2.1.1 Object ( [ value ] )</h3>
    <p>　Objectの関数が、引数なし、または1つの引数を取って呼ばれる際には、次のステップが取られます。</p>
<pre><code>1. value が、 null 、または、undefined であるか、または、提供されない場合、標準組み込みコンストラクタが、同じ引数を伴って呼ばれているかのような正確な新しいオブジェクトを生成して返す(15.2.2.1)
    2. ToObject(value) を返す
</code></pre><h2 id="15-2-2-object-the-object-constructor-standard-ecma-262-5-1-edition">15.2.2 Object コンストラクタ / The Object Constructor / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="15-ecmascript-">15 標準組み込みECMAScriptオブジェクト</h3>
    <h3 id="15-2-object-">15.2 Objectオブジェクト</h3>
    <h3 id="15-2-2-object-">15.2.2 Object コンストラクタ</h3>
    <p>　Objectが、 new 式の一部として呼ばれる場合、それはオブジェクトを生成する可能性のあるコンストラクタです。</p>
    <h3 id="15-2-2-1-new-object-value-">15.2.2.1 new Object ( [ value ] )</h3>
    <p>　Objectのコンストラクタが、引数なし、または、1つの引数 value を伴って呼ばれる場合、次のステップが取られます。</p>
<pre><code>1. value が提供される場合、
    a. Type(value) が、 Objectである場合、
    i. value が、ネイティブECMAScriptのオブジェクトである場合、新たなオブジェクトを生成せずに、単に value を返す
    ii. value が、ホストオブジェクトである場合、ホストオブジェクトに依存する場合がある実装依存の方法でアクションが実行され、任意の結果が返される
    b. Type(value) が、 Stringである場合、 ToObject(value) を返す
    c. Type(value) が、 Booleanである場合、 ToObject(value) を返す
    d. Type(value) が、 Numberである場合、 ToObject(value) を返す
    2. Assert: 引数の値は、提供されなかったか、その型は、Null または Undefinedだった
    3. obj は、新たに生成したECMAScriptオブジェクト
    4. obj の内部プロパティ[[Prototype]]に標準組み込みObjectプロトタイプオブジェクト(15.2.4)を設定
    5. obj の内部プロパティ[[Class]]に&quot;Object&quot;を設定
    6. obj の内部プロパティ[[Extensible]]にtrueを設定
    7. 8.12 で指定したように全ての obj の内部メソッドを設定
    8. obj を返す
</code></pre><h2 id="15-2-3-object-properties-of-the-object-constructor-standard-ecma-262-5-1-edition">15.2.3 Objectコンストラクタのプロパティ / Properties of the Object Constructor / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="15-ecmascript-">15 標準組み込みECMAScriptオブジェクト</h3>
    <h3 id="15-2-object-">15.2 Objectオブジェクト</h3>
    <h3 id="15-2-3-object-">15.2.3 Objectコンストラクタのプロパティ</h3>
    <p>　Objectコンストラクタの内部プロパティ[[Prototype]]は、標準組み込みFunctionプロトタイプオブジェクトです。 更に内部プロパティと(値が1である) length プロパティの他にObjectコンストラクタは、次のプロパティを持ちます。</p>
    <h3 id="15-2-3-1-object-prototype">15.2.3.1 Object.prototype</h3>
    <p>　 Object.prototype の初期値は、標準組み込みObjectプロトタイプオブジェクト(15.2.4)です。 このプロパティは、属性 {[[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false } を持ちます。</p>
    <h3 id="15-2-3-2-object-getprototypeof-o-">15.2.3.2 Object.getPrototypeOf ( O )</h3>
    <p>　 getPrototypeOf 関数は、引数 0を伴って呼ばれ、次のステップを取ります。</p>
<pre><code>1. Type(O) が、 Objectではない場合、TypeError例外を投げる(スローする)
    2. Oから成る内部プロパティ[[Prototype]]の値を返す
</code></pre><h3 id="15-2-3-3-object-getownpropertydescriptor-o-p-">15.2.3.3 Object.getOwnPropertyDescriptor ( O, P )</h3>
    <p>　getOwnPropertyDescriptor関数が呼ばれる際には、次のステップを取ります。</p>
<pre><code>1. Type(O) が、 Objectではない場合、TypeError例外を投げる(スローする)
    2. name は、 ToString(P) とする
    3. desc は、引数 nameを伴うOから成る内部プロパティ[[GetOwnProperty]]を呼んだ結果とする
    4. FromPropertyDescriptor(desc) (8.10.4)を呼んだ結果を返す
</code></pre><h3 id="15-2-3-4-object-getownpropertynames-o-">15.2.3.4 Object.getOwnPropertyNames ( O )</h3>
    <p>　getOwnPropertyNames関数が呼ばれる際には、次のステップが取られます。</p>
<pre><code>1. Type(O) が、 Objectではない場合、TypeError例外を投げる(スローする)
    2. array は、Arrayが、その名称を伴う標準組み込みコンストラクタである場合に式 new Array () によるかのように新たなオブジェクトを生成した結果とする
    3. n は、 0 とする
    4. OのプロパティP自身に名前付けしたそれぞれにおいて
    a. name は、P の名称であるString値とする
    b.引数 ToString(n)、プロパティ記述子 {[[Value]]: name, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}、 falseを伴う array の内部メソッド[[DefineOwnProperty]]を呼ぶ
    c. n を1で増分する
    5. array を返す
</code></pre><p>[注釈]</p>
    <p>　O が、Stringのインスタンスである場合、オブジェクトの[[PrimitiveValue]]の文字列内の文字位置と一致する 15.5.5.2 で定義した暗黙のプロパティを含めステップ4で処理したプロパティ自身を設定します。</p>
    <h3 id="15-2-3-5-object-create-o-properties-">15.2.3.5 Object.create ( O [, Properties] )</h3>
    <p>　create関数は、指定したプロトタイプを伴って新たなオブジェクトを生成します。 create関数が呼ばれる際には、次のステップが取られます。</p>
<pre><code>1. Type(O) が、Object や Nullではない場合、TypeError例外を投げる(スローする)
    2. obj は、その名を持つ標準組み込みコンストラクタであるObjectを式 new Object() によるかのように新たに生成した結果とする
    3. obj の内部プロパティ[[Prototype]]に0を設定
    4.引数 Propertiesが、存在する場合、且つundefinedではない場合、 obj と Properties を伴う標準組み込み関数 Object.defineProperties を呼んだかのように自身のプロパティに obj を追加
    5. obj を返す
</code></pre><h3 id="15-2-3-6-object-defineproperty-o-p-attributes-">15.2.3.6 Object.defineProperty ( O, P, Attributes )</h3>
    <p>　defineProperty関数は、自身のプロパティを追加、または存在するオブジェクト自身のプロパティから成る属性を更新の両方または何れかの為に使用されます。 defineProperty関数が呼ばれる際には、次のステップが取られます。</p>
<pre><code>1. Type(O) が、Objectではない場合、TypeError例外を投げる(スローする)
    2. name は、 ToString(P) とする
    3. desc は、引数として Attributes を伴うToPropertyDescriptorを呼んだ結果とする
    4.引数 name、desc、trueを伴う内部メソッド[[DefineOwnProperty]]を呼ぶ
    5. O を返す
</code></pre><h3 id="15-2-3-7-object-defineproperties-o-properties-">15.2.3.7 Object.defineProperties ( O, Properties )</h3>
    <p>　defineProperties関数は、自身のプロパティを追加、または存在するオブジェクト自身のプロパティから成る属性を更新の両方または何れかの為に使用されます。 defineProperties関数が呼ばれる際には、次のステップが取られます。</p>
<pre><code>1. Type(O) が、Objectではない場合、TypeError例外を投げる(スローする)
    2. props は、 ToObject(Properties) とする
    3. names は、 props 自身のプロパティを列挙するごとの名前を含んだ内部リストとする
    4. descriptors はカラの内部リストとする
    5.リスト順の名称から成る要素 P ごとに
    a. descObj は、引数として P を伴う props の内部メソッド[[Get]]を呼んだ結果とする
    b. desc は、引数として descObj を伴うToPropertyDescriptorを呼んだ結果とする
    c.記述子の終わりに P と desc から成る(2つの要素Listの)ペアを付加する
    6.リスト順に記述子から成るペアごとに
    a. P は、ペアの1つめの要素とする
    b. desc は、ペアの2つめの要素とする
    c.引数 P、desc、trueを伴う O の内部メソッド[[DefineOwnProperty]]を呼ぶ
    7. O を返す
</code></pre><p>　実装が、 for-in 文における仕様上の列挙順を定義する場合、その同一の列挙順は、このアルゴリズムのステップ3にあるリストの要素順に使用されなければいけません。</p>
    <h3 id="15-2-3-8-object-seal-o-">15.2.3.8 Object.seal ( O )</h3>
    <p>　seal関数が呼ばれる際には、次のステップが取られます。</p>
<pre><code>1. Type(O) が、Objectではない場合、TypeError例外を投げる(スローする)
    2. O のプロパティ名 P 自身に名前を付けるごとに
    a. desc は、 P を伴う O の内部メソッド[[GetOwnProperty]]を呼んだ結果とする
    b. desc.[[Configurable]] が、 trueである場合、 desc.[[Configurable]] にfalseを設定
    c.引数として P 、desc、trueを伴う O の内部メソッド[[DefineOwnProperty]]を呼ぶ
    3. O の内部プロパティ[[Extensible]]にfalseを設定
    4. Oを返す
</code></pre><h3 id="15-2-3-9-object-freeze-o-">15.2.3.9 Object.freeze ( O )</h3>
    <p>　freeze関数が呼ばれる際には、次のステップが取られます。</p>
<pre><code>1. Type(O) が、Objectではない場合、TypeError例外を投げる(スローする)
    2. O のプロパティ名 P 自身に名前を付けるごとに
    a. desc は、 P を伴う O の内部メソッド[[GetOwnProperty]]を呼んだ結果とする
    b. IsDataDescriptor(desc) が、 trueである場合、
    i. desc.[[Writable]] が、 trueである場合、desc.[[Writable]]に falseを設定
    c. desc.[[Configurable]]が、 trueである場合、desc.[[Configurable]]に falseを設定
    d.引数として P 、 desc、 trueを伴う O の内部メソッド[[DefineOwnProperty]]を呼ぶ
    3. O の内部プロパティ[[Extensible]]に falseを設定
    4. O を返す
</code></pre><h3 id="15-2-3-10-object-preventextensions-o-">15.2.3.10 Object.preventExtensions ( O )</h3>
    <p>　preventExtensions関数が呼ばれる際には、次のステップが取られます。</p>
<pre><code>1. Type(O) が、Objectではない場合、TypeError例外を投げる(スローする)
    2. O の内部プロパティ[[Extensible]]に falseを設定
    3. O を返す
</code></pre><h3 id="15-2-3-11-object-issealed-o-">15.2.3.11 Object.isSealed ( O )</h3>
    <p>　isSealed関数が、引数 O を伴って呼ばれる際には、次のステップが取られます。</p>
<pre><code>1. Type(O) が、Objectではない場合、TypeError例外を投げる(スローする)
    2. O のプロパティ名 P 自身に名前を付けるごとに
    a. desc は、 P を伴う O の内部メソッド[[GetOwnProperty]]を呼んだ結果とする
    b. desc.[[Configurable]]が、trueである場合、falseを返す
    3. O の内部プロパティ[[Extensible]]が、falseである場合、trueを返す
    4.それ以外の場合、falseを返す
</code></pre><h3 id="15-2-3-12-object-isfrozen-o-">15.2.3.12 Object.isFrozen ( O )</h3>
    <p>　isFrozen関数が、引数 Oを伴って呼ばれる際には、次のステップが取られます。</p>
<pre><code>1. Type(O) が、Objectではない場合、TypeError例外を投げる(スローする)
    2. O のプロパティ名 P 自身に名前を付けるごとに
    a. desc は、 P を伴う O の内部メソッド[[GetOwnProperty]]を呼んだ結果とする
    b. IsDataDescriptor(desc) が、 trueである場合、
    i. desc.[[Writable]] が、 trueである場合、falseを返す
    c. desc.[[Configurable]] が、 trueである場合、falseを返す
    3. O の内部プロパティ[[Extensible]]が、falseである場合、trueを返す
    4.それ以外の場合、falseを返す
</code></pre><h3 id="15-2-3-13-object-isextensible-o-">15.2.3.13 Object.isExtensible ( O )</h3>
    <p>　isExtensible関数が、引数 Oを伴って呼ばれる際には、次のステップが取られます。</p>
<pre><code>1. Type(O) が、Objectではない場合、TypeError例外を投げる(スローする)
    2. O の内部プロパティ[[Extensible]]のBoolean値を返す
</code></pre><h3 id="15-2-3-14-object-keys-o-">15.2.3.14 Object.keys ( O )</h3>
    <p>　keys関数が、引数 Oを伴って呼ばれる際には、次のステップが取られます。</p>
<pre><code>1. Type(O) が、Objectではない場合、TypeError例外を投げる(スローする)
    2. n は、、O の列挙プロパティ自身の数とする
    3. array は、その名の標準組み込みコンストラクタである Array を式 new Array(n) によるかのように新たなObjectを生成した結果とする
    4. index は、 0とする
    5.名称文字列が、 P である O から成る自身の列挙プロパティごとに
    a.引数 ToString(index)、プロパティ記述子 {[[Value]]: P, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}、false.を伴う array の内部メソッド[[DefineOwnProperty]]を呼ぶ
    b. index を1で増分する
    6. array を返す
</code></pre><p>　実装が、 for-in 文における仕様上の列挙順を定義する場合、同一の列挙順が、このアルゴリズムのステップ5の中で使用されなければいけません。</p>
    <h2 id="15-2-4-object-prototype-properties-of-the-object-prototype-object-standard-ecma-262-5-1-edition">15.2.4 Objectのprototypeオブジェクトのプロパティ / Properties of the Object Prototype Object / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="15-ecmascript-">15 標準組み込みECMAScriptオブジェクト</h3>
    <h3 id="15-2-object-">15.2 Objectオブジェクト</h3>
    <h3 id="15-2-4-object-prototype-">15.2.4 Objectのprototypeオブジェクトのプロパティ</h3>
    <p>　Objectのprototypeオブジェクトの内部プロパティ[[Prototype]]の値は、null、内部プロパティ[[Class]]の値は、“Object”、内部プロパティ[[Extensible]]の値は、trueです。</p>
    <h3 id="15-2-4-1-object-prototype-constructor">15.2.4.1 Object.prototype.constructor</h3>
    <p>　Object.prototype.constructor の初期値は、標準組み込みObjectコンストラクタです。</p>
    <h3 id="15-2-4-2-object-prototype-tostring-">15.2.4.2 Object.prototype.toString ( )</h3>
    <p>　toStringメソッドが呼ばれる際には、次のステップが取られます。</p>
<pre><code>1. this の値が、undefinedである場合、&quot;[object Undefined]&quot;を返す
    2. this の値が、nullである場合、&quot;[object Null]&quot;を返す
    3. O は、引数として this 値を渡して ToObject を呼んだ結果とする
    4. class は、O の内部プロパティ[[Class]]の値とする
    5.3つの文字列&quot;[object &quot;, class, そして &quot;]&quot;を連結した結果であるString値を返す
</code></pre><h3 id="15-2-4-3-object-prototype-tolocalestring-">15.2.4.3 Object.prototype.toLocaleString ( )</h3>
    <p>　toLocaleStringメソッドが呼ばれる際には、次のステップが取られます。</p>
<pre><code>1. O は、引数として this 値を渡して ToObject を呼んだ結果とする
    2. toString は、引数として&quot;toString&quot;を渡して O の内部メソッド[[Get]]を呼んだ結果とする
    3. IsCallable(toString) が、 falseである場合、TypeError例外を投げる(スローする)
    4.引数のない this 値として O を渡して toString の内部メソッド[[Call]]を呼んだ結果とする
</code></pre><p>[注釈 1]</p>
    <p>　この関数は、全てがそれを使用すると言う訳ではありませんが、一般的なtoLocaleStringインタフェースを全てのオブジェクトに与える為に提供されます。 現在、Array、Number、Dateについては、ロケール依存(locale-sensitive)のtoLocaleStringメソッドを提供します。</p>
    <p>[注釈 2]</p>
    <p>　この関数における1つめのパラメータは、この標準規格の将来バージョン内で使用されるようになるかもしれません。 つまり、実装は、他のいかなる場合においても、このパラメータ位置を使わないことが推奨されるということです。</p>
    <h3 id="15-2-4-4-object-prototype-valueof-">15.2.4.4 Object.prototype.valueOf ( )</h3>
    <p>　valueOfメソッドが呼ばれる際には、次のステップが取られます。</p>
<pre><code>1. O は、引数として this 値を渡してToObjectを呼んだ結果とする
    2. O が、ホストオブジェクト(15.2.2.1)を伴うObjectコンストラクタを呼んだ結果となる場合、
    a.そのコンストラクタを渡してホストオブジェクトオリジナルであるかのように0または、他の値を返す、返されるその仕様上の結果は、実装定義です。
    3. O を返す
</code></pre><h3 id="15-2-4-5-object-prototype-hasownproperty-v-">15.2.4.5 Object.prototype.hasOwnProperty (V)</h3>
    <p>　hasOwnPropertyメソッドが、引数 V を伴って呼ばれる際には、次のステップが取られます。</p>
<pre><code>1. P は、 ToString(V) とする
    2. O は、引数として this 値を渡してToObjectを呼んだ結果とする
    3. desc は、引数として P を渡して O の内部メソッド[[GetOwnProperty]]を呼んだ結果とする
    4. desc が、 undefinedである場合、falseを返す
    5. trueを返す
</code></pre><p>[注釈 1]</p>
    <p>　[[HasProperty]] (8.12.6)とは異なり、このメソッドは、プロトタイプチェーン内にあるオブジェクトとはみなされません。</p>
    <p>[注釈 2]</p>
    <p>　ステップ1と2の順に関しては、 this 値が、undefined や nullである場合でさえ、 continue が投げられる(スローされる)この仕様上の前の版(エディション)にあるステップ1によって投げられる(スローされる)場合のある一部例外を捕捉する為に選択されます。</p>
    <h3 id="15-2-4-6-object-prototype-isprototypeof-v-">15.2.4.6 Object.prototype.isPrototypeOf (V)</h3>
    <p>　isPrototypeOfメソッドが、引数 V を伴って呼ばれる際には、次のステップが取られます。</p>
<pre><code>1. V が、オブジェクトではない場合、false を返す
    2. O は、引数として this 値を渡して ToObject を呼んだ結果とする
    3.繰り返す
    a. V は、V の内部プロパティ[[Prototype]]の値とする
    b. V が、nullである場合、 false を返す
    c. O と V が、同一のオブジェクトを参照する場合、true を返す
</code></pre><p>[注釈]</p>
    <p>　ステップ1と2の順に関しては、Vがオブジェクトではなく、 this 値が、undefined や null である場合においてこの仕様上の前の版(エディション)によって指定した動作を保持する(何らかの事情で使われないように温存しておく)為に選択されます。</p>
    <h3 id="15-2-4-7-object-prototype-propertyisenumerable-v-">15.2.4.7 Object.prototype.propertyIsEnumerable (V)</h3>
    <p>　propertyIsEnumerableメソッドが、引数 V を伴って呼ばれる際には、次のステップが取られます。</p>
<pre><code>1. P は、 ToString(V) とする
    2. O は、引数として this 値を渡してToObjectを呼んだ結果とする
    3. desc は、引数として P を渡して O の内部メソッド[[GetOwnProperty]]を呼んだ結果とする
    4. desc が、undefinedである場合、falseを返す
    5. desc.[[Enumerable]]の値を返す
</code></pre><p>[注釈 1]</p>
    <p>　このメソッドは、プロトタイプチェーン内のオブジェクトとはみなされません。</p>
    <p>[注釈 2]</p>
    <p>　ステップ1と2の順に関しては、 this 値が、undefined や nullである場合でさえ、 continue が投げられる(スローされる)この仕様上の前の版(エディション)にあるステップ1によって投げられる(スローされる)場合のある一部例外を捕捉する為に選択されます。</p>
    <h2 id="15-2-5-object-properties-of-object-instances-standard-ecma-262-5-1-edition">15.2.5 Objectインスタンスのプロパティ / Properties of Object Instances / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="15-ecmascript-">15 標準組み込みECMAScriptオブジェクト</h3>
    <h3 id="15-2-object-">15.2 Objectオブジェクト</h3>
    <h3 id="15-2-5-object-">15.2.5 Objectインスタンスのプロパティ</h3>
    <p>　Objectのインスタンスは、Objectのprototypeオブジェクトからこれらの継承を超える特別なプロパティは何も持ちません。</p>
    <h2 id="15-3-function-function-objects-standard-ecma-262-5-1-edition">15.3 Function オブジェクト / Function Objects / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="15-ecmascript-">15 標準組み込みECMAScriptオブジェクト</h3>
    <h3 id="15-3-function-">15.3 Function オブジェクト</h3>
    <h2 id="15-3-1-function-the-function-constructor-called-as-a-function-standard-ecma-262-5-1-edition">15.3.1 関数として呼んだ Function コンストラクタ / The Function Constructor Called as a Function / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="15-ecmascript-">15 標準組み込みECMAScriptオブジェクト</h3>
    <h3 id="15-3-function-">15.3 Function オブジェクト</h3>
    <h3 id="15-3-1-function-">15.3.1 関数として呼んだ Function コンストラクタ</h3>
    <p>　Functionが、コンストラクタとしてではなく、関数として呼ばれる場合、新たなFunctionオブジェクトを生成、初期化します。 このような関数呼び出し Function(…) は、同一の引数を伴うオブジェクト生成式 new Function(…) と等価です。</p>
    <h3 id="15-3-1-1-function-p1-p2-pn-body-">15.3.1.1 Function (p1, p2, … , pn, body)</h3>
    <p>　Function関数が、( nは、0になる場合があり、つまり、それは引数 “p”が何もないことを意味し、bodyは、提供されない場合もある)引数 p1, p2, … , pn、body を伴って呼ばれる際には、次のステップが取られます。</p>
<pre><code>1.同一の引数を伴う new 式で使用された標準組み込みコンストラクタであるかのように新たなFunctionオブジェクトを生成し、返す(15.3.2.1)
</code></pre><h2 id="15-3-2-function-the-function-constructor-standard-ecma-262-5-1-edition">15.3.2 Functionコンストラクタ / The Function Constructor / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="15-ecmascript-">15 標準組み込みECMAScriptオブジェクト</h3>
    <h3 id="15-3-function-">15.3 Function オブジェクト</h3>
    <h3 id="15-3-2-function-">15.3.2 Functionコンストラクタ</h3>
    <p>　Functionが、 new 式の一部として呼ばれる場合、それはコンストラクタであり、それは、新たに生成したオブジェクトを初期化します。</p>
    <h3 id="15-3-2-1-new-function-p1-p2-pn-body-">15.3.2.1 new Function (p1, p2, … , pn, body)</h3>
    <p>　最後の引数は、関数の(実行コード)本体を指定し、先行する引数は正規のパラメータを指定します。 Functionコンストラクタが、( nは、0になる場合があり、つまり、それは引数 “p”が何もないことを意味し、bodyは、提供されない場合もある)引数 p1, p2, … , pn、body を伴って呼ばれる際には、次のステップが取られます。</p>
<pre><code>1. argCount は、この関数呼び出しに渡した引数の総数とする
    2. P は、カラの文字列とする
    3. argCount = 0である場合、 body は、カラの文字列とする
    4. argCount = 1である場合、 body は、その引数とする
    5. argCount &gt; 1である場合、
    a. firstArg は、1つめの引数とする
    b. P は、 ToString(firstArg) とする
    c. k は、 2 とする
    d. while k &lt; argCount (の条件下で)繰り返す
    i. nextArg は、k 番めの引数とする
    ii. P は、P の前の値、文字&quot;,&quot;、 ToString(nextArg) を連結した結果とする
    iii. kを1で増分する
    e. body は、k 番めの引数とする
    6. body は、 ToString(body) とする
    7. P が、FormalParameterList opt として解析不能な場合、SyntaxError例外を投げる(スローする)
    8. body が、FunctionBodyとして解析不能な場合、SyntaxError例外を投げる(スローする)
    9. body が、strictモードのコードである場合、 strict は、true、それ以外の場合、 strict は、falseとする
    10. strict が、 trueである場合、 13.1 で適用する指定した例外を投げる(スローする)
    11. FormalParameterListopt として P  そして FunctionBody として body を渡して 13.2 で指定したように生成した新たな Function オブジェクトを返す
    Scope パラメータとして Global 環境、Strict フラグとして strict を渡す
</code></pre><p>　prototypeプロパティは、コンストラクタとして使用される可能性において提供する為に関数ごとに自動的に生成されます。</p>
    <p>[注釈]</p>
    <p>　それは、許容はされるものの必ずしも記述される正規のパラメータごとに1つの引数を持つ必要はありません。 例えば、次の3つの全ての式は、同じ結果を生成します。</p>
<pre><code>new Function(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;return a+b+c&quot;)
    new Function(&quot;a, b, c&quot;, &quot;return a+b+c&quot;)
    new Function(&quot;a,b&quot;, &quot;c&quot;, &quot;return a+b+c&quot;)
</code></pre><h2 id="15-3-3-function-properties-of-the-function-constructor-standard-ecma-262-5-1-edition">15.3.3 Functionコンストラクタのプロパティ / Properties of the Function Constructor / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="15-ecmascript-">15 標準組み込みECMAScriptオブジェクト</h3>
    <h3 id="15-3-function-">15.3 Function オブジェクト</h3>
    <h3 id="15-3-3-function-">15.3.3 Functionコンストラクタのプロパティ</h3>
    <p>　Functionコンストラクタは、Functionオブジェクト自身であり、その(内部プロパティ)[[Class]]は、“Function”です。</p>
    <p>　Functionコンストラクタの内部ロパティ[[Prototype]]は、標準組み込みFunctionのprototypeオブジェクト(15.3.4)です。</p>
    <p>　Functionコンストラクタの内部ロパティ[[Extensible]]は、trueです。</p>
    <p>　Functionコンストラクタは、次のプロパティを持ちます。</p>
    <h3 id="15-3-3-1-function-prototype">15.3.3.1 Function.prototype</h3>
    <p>　Function.prototypeの初期値は、標準組み込みFunctionのprototypeオブジェクト(15.3.4)です。 このプロパティは、属性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false } を持ちます。</p>
    <h3 id="15-3-3-2-function-length">15.3.3.2 Function.length</h3>
    <p>　これ( Function.length プロパティ)は、値が1であるデータプロパティです。 このプロパティは、属性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false } を持ちます。</p>
    <h2 id="15-3-4-function-properties-of-the-function-prototype-object-standard-ecma-262-5-1-edition">15.3.4 Functionプロトタイプオブジェクトのプロパティ / Properties of the Function Prototype Object / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="15-ecmascript-">15 標準組み込みECMAScriptオブジェクト</h3>
    <h3 id="15-3-function-">15.3 Function オブジェクト</h3>
    <h3 id="15-3-4-function-">15.3.4 Functionプロトタイプオブジェクトのプロパティ</h3>
    <p>　Functionのprototypeオブジェクトは、Functionオブジェクト自身(、その[[Class]] が“Function”)であり、呼び出される場合、引数を許容し、undefinedを返します。</p>
    <p>　Functionのprototypeオブジェクトの内部プロパティ[[Prototype]]の値は、標準組み込みObjectのprototypeオブジェクト(15.2.4)です。</p>
    <p>　Functionのprototypeオブジェクトの内部プロパティ[[Extensible]]の初期値は、trueです。</p>
    <p>　Functionのprototypeオブジェクトは、それ自身の valueOf プロパティを持たず、Objectのprototypeオブジェクトからの valueOf プロパティを継承します。</p>
    <p>　Functionのprototypeオブジェクトの length プロパティは、0です。</p>
    <h3 id="15-3-4-1-function-prototype-constructor">15.3.4.1 Function.prototype.constructor</h3>
    <p>　 Function.prototype.constructor の初期値は、組み込みFunctionコンストラクタです。</p>
    <h3 id="15-3-4-2-function-prototype-tostring-">15.3.4.2 Function.prototype.toString ( )</h3>
    <p>　(toStringは、)関数の実装依存の表現が返されます。 この表現は、FunctionDeclarationの構文を持ちます。</p>
    <p>　特筆すべきは、その利用と表示文字内のホワイトスペース、行終端、セミコロンの配置は、実装依存であるということです。 toString関数は、一般的ではなく、その this 値が、Functionオブジェクトではない場合、TypeError例外を投げます(スローします)。 その為、メソッドとしての利用における他の種類のオブジェクトに転送することができません。</p>
    <h3 id="15-3-4-3-function-prototype-apply-thisarg-argarray-">15.3.4.3 Function.prototype.apply (thisArg, argArray)</h3>
    <p>　applyメソッドが、引数 thisArg と argArray を伴ってオブジェクト func 上で呼ばれる際には、次のステップが取られます。</p>
<pre><code>1. IsCallable(func) が、 falseである場合、TypeError例外を投げる(スローする)
    2. argArray が、null または、 undefinedである場合、
    a. this 値と引数のカラのリストとして thisArg を提供して func の内部メソッド[[Call]]を呼んだ結果を返す
    3. Type(argArray) が、 Objectではない場合、TypeError例外を投げる(スローする)
    4. len は、引数&quot;length&quot;を伴う argArray の内部メソッド[[Get]]を呼んだ結果とする
    5. n は、 ToUint32(len) とする
    6. argList は、カラのリストとする
    7. index は、0とする
    8. while index &lt; n という条件下で繰り返す
    a. indexName は、 ToString(index) とする
    b. nextArg は、引数として indexName を伴う argArray の内部メソッド[[Get]]を呼んだ結果とする
    c.  argList の最後の要素として nextArg を付加する
    d. index に index + 1 を設定する
    9.引数のリストとして this 値と  argList としての thisArg を提供して func の内部メソッド[[Call]]を呼んだ結果を返す
</code></pre><p>　適用するメソッドの length プロパティは、2です。</p>
    <p>[注釈]</p>
    <p>　 thisArg 値は、 this 値として変更・修正なしで渡されます。 これは、 undefined や null である場合、 thisArg が、グローバルオブジェクトを伴って置換され、 ToObject が、他の値全てに適用され、その結果が this 値として渡されることになっている第3版から変更されています。</p>
    <h3 id="15-3-4-4-function-prototype-call-thisarg-arg1-arg2-">15.3.4.4 Function.prototype.call (thisArg [ , arg1 [ , arg2, … ] ] )</h3>
    <p>　callメソッドが、引数 thisArg と オプションの引数 arg1, arg2 …を伴ってオブジェクト func 上で呼ばれる際には、次のステップが取られます。</p>
<pre><code>1. IsCallable(func) が、 falseである場合、TypeError例外を投げる(スローする)
    2. argList は、カラのリストとする
    3. このメソッドが、引数を1つ以上伴って呼ばれる場合、 arg1 で始まり、左から右に順に argList の最後の要素として各引数を付加する
    4.引数のリストして this 値、 argList として thisArg を提供して func の内部メソッド[[Call]]を呼んだ結果を返す
</code></pre><p>　call メソッドの length プロパティは、1です。</p>
    <p>[注釈]</p>
    <p>　 thisArg 値は、 this 値として変更・修正なく渡されます。 これは、 undefined や null である場合、 thisArg が、グローバルオブジェクトを伴って置換され、 ToObject が、他の値全てに適用され、その結果が this 値として渡されることになっている第3版から変更されています。</p>
    <h3 id="15-3-4-5-function-prototype-bind-thisarg-arg1-arg2-">15.3.4.5 Function.prototype.bind (thisArg [, arg1 [, arg2, …]])</h3>
    <p>　 thisArg、(他にオプションとして) arg1, arg2,…と1つ以上引数を取る bindメソッドは、 次のステップを実行することにより、新たな関数オブジェクトを返します。</p>
<pre><code>1. Target は、 this 値とする
    2. IsCallable(Target) が、 falseである場合、TypeError例外を投げる(スローする)
    3. A は、順に thisArg (arg1, arg2...) の後に提供した引数値の全てから成る新しい(カラも可能な)内部リストとする
    4. F は、新しいネイティブECMAScriptオブジェクトとする
    5. 8.12で記述したように F の[[Get]]を除き、全ての内部メソッドを設定する
    6. 15.3.5.4 で記述したように F の内部プロパティ[[Get]]を設定する
    7. F の内部プロパティ[[TargetFunction]]に Target を設定する
    8. F の内部プロパティ[[BoundThis]]に thisArg の値を設定する
    9. F の内部プロパティ[[BoundArgs]]に A を設定する
    10. F の内部プロパティ[[Class]]に&quot;Function&quot;を設定する
    11. 15.3.3.1 で記述したように F の内部プロパティ[[Prototype]]に標準組み込みFunctionプロトタイプオブジェクトを設定する
    12. 15.3.4.5.1 で説明したように F の内部プロパティ[[Call]]を設定する
    13. 15.3.4.5.2 で説明したように F の内部プロパティ[[Construct]]を設定する
    14. 15.3.4.5.3 で説明したように F の内部プロパティ[[HasInstance]]を設定する
    15. Target の内部プロパティ[[Class]]が、&quot;Function&quot;である場合、
    a. L は、 Target の length プロパティから A の長さを引いたものとする
    b. 0または、Lの大きい方を F 自身の length プロパティに設定する
    16.それ以外の場合、 F 自身の length プロパティに0を設定する
    17. F 自身の length プロパティの属性に 15.3.5.1で記述した値を設定する
    18. F の内部プロパティ[[Extensible]]に true を設定する
    19. thrower は、関数オブジェクト(13.2.3)[[ThrowTypeError]]とする
    20.引数 &quot;caller&quot;、PropertyDescriptor {[[Get]]: thrower, [[Set]]: thrower, [[Enumerable]]: false, [[Configurable]]: false}、falseを伴う F の内部メソッド[[DefineOwnProperty]]を呼ぶ
    21.引数 &quot;arguments&quot;、PropertyDescriptor  {[[Get]]: thrower, [[Set]]: thrower, [[Enumerable]]: false, [[Configurable]]: false}、falseを伴う F の内部メソッド[[DefineOwnProperty]]を呼ぶ
    22. F を返す
</code></pre><p>　bindメソッドの length プロパティは、1です。</p>
    <p>[注釈]</p>
    <p>　 Function.prototype.bindを使って生成したFunctionオブジェクトは、prototypeプロパティや内部プロパティ[[Code]]、[[FormalParameters]]、[[Scope]]を持ちません。</p>
    <h3 id="15-3-4-5-1-call-">15.3.4.5.1 [[Call]]</h3>
    <p>　バインド関数を使って生成された F という関数オブジェクトの内部メソッド[[Call]]が、引数 this 値と ExtraArgs のリストを伴って呼ばれる際には、次のステップが取られます。</p>
<pre><code>1. boundArgs は、 F の[[BoundArgs]]内部プロパティの値とする
    2. boundThis は、 F の[[BoundThis]]内部プロパティの値とする
    3. target は、F の[[TargetFunction]]内部プロパティとする
    4. args は、同じ順のリスト ExtraArgs と同じ値によって続く、同じ順のリスト boundArgs と同じ値を含んだ新たなリストとする
    5.引数として args 、this 値として boundThis を提供して target の内部メソッド[[Call]]を呼んだ結果を返す
</code></pre><h3 id="15-3-4-5-2-construct-">15.3.4.5.2 [[Construct]]</h3>
    <p>　バインド関数を使って生成された F という関数オブジェクトの内部メソッド[[Construct]]が、引数 ExtraArgs のリストを伴って呼ばれる際には、次のステップが取られます。</p>
<pre><code>1. target は、 F の[[TargetFunction]]内部プロパティの値とする
    2. target が、[[Construct]]内部メソッドを一切持たない場合、TypeError例外が投げられる(スローされる)
    3. boundArgs は、F の[[BoundArgs]]内部プロパティとする
    4. args は、同じ順のリスト ExtraArgs と同じ値によって続く、同じ順のリスト boundArgs と同じ値を含んだ新たなリストとする
    5.引数として args を提供して target の内部メソッド[[Construct]]を呼んだ結果を返す
</code></pre><h3 id="15-3-4-5-3-hasinstance-v-">15.3.4.5.3 [[HasInstance]] (V)</h3>
    <p>　バインド関数を使用して生成された関数オブジェクト F の内部メソッド[[HasInstance]]が、引数 V を伴って呼ばれる際には、次のステップが取られます。</p>
<pre><code>1. target は、F の[[TargetFunction]]内部プロパティの値とする
    2. target が、[[HasInstance]]内部メソッドを一切持たない場合、TypeError例外が投げられる(スローされる)
    3. 引数として V を提供して target の内部メソッド[[HasInstance]]を呼んだ結果を返す
</code></pre><h2 id="15-3-5-function-properties-of-function-instances-standard-ecma-262-5-1-edition">15.3.5 Functionインスタンスのプロパティ / Properties of Function Instances / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="15-ecmascript-">15 標準組み込みECMAScriptオブジェクト</h3>
    <h3 id="15-3-function-">15.3 Function オブジェクト</h3>
    <h3 id="15-3-5-function-">15.3.5 Functionインスタンスのプロパティ</h3>
    <p>　内部プロパティについて追記すると、全ての関数のインスタンスは、内部プロパティ[[Call]]を持ち、多くの場合、内部プロパティ[[Get]]の異なるバージョンを使用します。 どのように生成されるか( 8.6.2, 13.2, 15, 15.3.4.5 各項参照)によって関数のインスタンスは、[[HasInstance]]内部プロパティ、[[Scope]]内部プロパティ、[[Construct]]内部プロパティ、[[FormalParameters]]内部プロパティ、[[Code]]内部プロパティ、[[TargetFunction]]内部プロパティ、[[BoundThis]]内部プロパティ、[[BoundArgs]]内部プロパティを持つ場合があります。</p>
    <p>　内部プロパティ[[Class]]の値は、“Function”です。</p>
    <p>　 strict モードの関数 (13.2) と一致する関数のインスタンスとFunction.prototype.bind メソッド (15.3.4.5)を使って生成した関数のインスタンスは、TypeError例外を投げる(スローする)“caller”、“arguments”という名のプロパティを持ちます。 ECMAScriptの実装は、strict モードの関数からこれらのプロパティのアクセスを伴う任意の実装仕様上の動作と関連付けてはいけません。</p>
    <h3 id="15-3-5-1-length">15.3.5.1 length</h3>
    <p>　 length プロパティの値は、関数によって期待される引数の“一般的な(典型的な・typical)”数を示す整数です。 しかしながら、言語は、任意の他の引数の数を伴って呼び出される関数を許容します。 当該 length プロパティによって記述した数ではなく、引数の数について呼び出す際の当該関数の動作については、その関数に依存します。 このプロパティは、属性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false } を持ちます。</p>
    <h3 id="15-3-5-2-prototype">15.3.5.2 prototype</h3>
    <p>　 prototypeプロパティは、新たに生成したオブジェクトにおけるコンストラクタのように呼び出されるFunctionオブジェクトの前に新たに生成したオブジェクトの内部プロパティ[[Prototype]]を初期化する為に使用されます。 このプロパティは、属性 { [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false } を持ちます。</p>
    <p>[注釈]</p>
    <p>　 Function.prototype.bindを使用して生成した関数オブジェクトは、prototypeプロパティを持ちません。</p>
    <h3 id="15-3-5-3-hasinstance-v-">15.3.5.3 [[HasInstance]] (V)</h3>
    <p>　関数オブジェクトであるFを呼び出します。</p>
    <p>　 F の内部メソッド[[HasInstance]]が、値 V を伴って呼ばれる際には、次のステップが取られます。</p>
<pre><code>1. V が、オブジェクトではない場合、falseを返す
    2. O は、プロパティ名&quot;prototype&quot;を伴う F の内部メソッド[[Get]]を呼んだ結果とする
    3. Type(O) が、 Objectではない場合、TypeError例外を投げる(スローする)
    4.繰り返す
    a. V は、V の内部プロパティ[[Prototype]]の値とする
    b. V が、 nullである場合、falseを返す
    c. O と V が、同一のオブジェクトを参照する場合、trueを返す
</code></pre><p>[注釈]</p>
    <p>　 Function.prototype.bindを使って生成した関数オブジェクトは、 15.3.4.5.3 で定義した[[HasInstance]]の異なる実装を持ちます。</p>
    <h3 id="15-3-5-4-get-p-">15.3.5.4 [[Get]] (P)</h3>
    <p>　Functionオブジェクトは、他のネイティブECMAScriptオブジェクト(8.12.3)において使用した内部メソッド[[Get]]のバリエーションを使用します。 F は、Functionオブジェクトであると仮定します。</p>
    <p>　 F の内部メソッド[[Get]]が、プロパティ名 P を伴って呼ばれる際には、次のステップが取られます。</p>
<pre><code>1. v は、プロパティ名の引数として P を渡して F 上にある既定の内部メソッド[[Get]](8.12.3)を呼んだ結果とする
    2. P が、 &quot;caller&quot;で且つ、v が、strict モードのFunctionオブジェクトである場合、TypeError例外を投げる(スローする)
    3. v を返す
</code></pre><p>[注釈]</p>
    <p>　 Function.prototype.bindを使って生成したFunctionオブジェクトは、既定の[[Get]]内部メソッドを使用します。</p>
    <h2 id="15-4-array-array-objects-standard-ecma-262-5-1-edition">15.4 Arrayオブジェクト / Array Objects / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="15-ecmascript-">15 標準組み込みECMAScriptオブジェクト</h3>
    <h3 id="15-4-array-">15.4 Arrayオブジェクト</h3>
    <p>　Arrayオブジェクトは、特定のプロパティ名のクラスに特別な待遇を与えます。 (String値の書式において)プロパティ名 P は、 ToString(ToUint32(P)) が、Pと等しく、 ToUint32(P) が、2の32乗-1と等しくない場合に限り、配列インデックスです。 property名を持つプロパティは、要素を呼ぶこともある配列インデックスでもあります。 全てのArrayオブジェクトは、値が常に2の32乗より小さい非負の整数である length プロパティを持ちます。 length プロパティの値は、配列インデックスを持つプロパティごとの名称よりも数値的に大きくなります。 Arrayオブジェクトのプロパティは、常に生成または変更され、他のプロパティは、この不変性を維持する必要がある場合に調整されます。 特に名前付きで追加されるプロパティは、常に配列インデックスであり、必要があれば、その配列インデックスの数値以上にする為に length プロパティが変更されます。 また、length プロパティは、自動的に削除される新たな長さよりも小さくならない値を持つ配列インデックスである名称を持つプロパティごとに常に 変更されます。 この制約は、Arrayオブジェクトの自身のプロパティにだけ適用されるものであり、その prototype から継承される場合がある length や配列インデックスによって影響を受けることはありません。</p>
    <p>　次のアルゴリズムがtrueを返す場合、オブジェクト O は、希薄(sparse)になると言われます。</p>
<pre><code>1. len は、引数&quot;length&quot;を伴う O の内部メソッド[[Get]]を呼んだ結果とする
    2. 0≦i&lt;ToUint32(len) の範囲内にある整数 i ごとに
    a. elem は、引数 ToString(i) を伴う O の内部メソッド[[GetOwnProperty]]を呼んだ結果とする
    b. elem が、undefinedである場合、trueを返す
    3.falseを返す
</code></pre><h2 id="15-4-1-array-the-array-constructor-called-as-a-function-standard-ecma-262-5-1-edition">15.4.1 関数として呼んだ Array コンストラクタ / The Array Constructor Called as a Function / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="15-ecmascript-">15 標準組み込みECMAScriptオブジェクト</h3>
    <h3 id="15-4-array-">15.4 Arrayオブジェクト</h3>
    <h3 id="15-4-1-array-">15.4.1 関数として呼んだ Array コンストラクタ</h3>
    <p>　Arrayが、コンストラクタではなく関数として呼ばれる際には、新たなArrayオブジェクトを生成、初期化します。 このように関数呼び出し Array(…) は、同じ引数を伴うオブジェクト生成式 new Array(…) と等価です。</p>
    <h3 id="15-4-1-1-array-item1-item2-">15.4.1.1 Array ( [ item1 [ , item2 [ , … ] ] ] )</h3>
    <p>　Array関数が呼ばれる際には、次のステップが取られます。</p>
<pre><code>1.標準組み込みコンストラクタ Array が、同じ引数を伴って new 式(15.4.2)内で使用されたかのように正確に新たなArrayオブジェクトを生成し、返す
</code></pre><h2 id="15-4-2-array-the-array-constructor-standard-ecma-262-5-1-edition">15.4.2 Array コンストラクタ / The Array Constructor / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="15-ecmascript-">15 標準組み込みECMAScriptオブジェクト</h3>
    <h3 id="15-4-array-">15.4 Arrayオブジェクト</h3>
    <h3 id="15-4-2-array-">15.4.2 Array コンストラクタ</h3>
    <p>　Arrayが、new 式の一部として呼ばれる際には、それはコンストラクタであり、新たに生成したオブジェクトを初期化します。</p>
    <h3 id="15-4-2-1-new-array-item0-item1-">15.4.2.1 new Array ( [ item0 [ , item1 [ , … ] ] ] )</h3>
    <p>　Array コンストラクタが、引数が全くないか、少なくとも2つの引数を伴う場合、この説明が適用されます。</p>
    <p>　新たに構築したオブジェクトの内部プロパティ[[Prototype]]には、 Array.prototype (15.4.3.1)の初期値であるオリジナルの Array プロトタイプオブジェクトが設定されます。</p>
    <p>　新たに構築したオブジェクトの内部プロパティ[[Class]]には、“Array”が設定されます。</p>
    <p>　新たに構築したオブジェクトの内部プロパティ[[Extensible]]には、trueが設定されます。</p>
    <p>　新たに構築したオブジェクトのlengthプロパティには、引数の数が設定されます。</p>
    <p>　新たに構築したオブジェクトのプロパティ 0 には、(提供された場合) item0 、新たに構築したオブジェクトのプロパティ 1 には、(提供された場合) item1 が設定され、一般的には、複数の引数が存在するものとして、1つめの引数が、引数番号 0 となると考えられる場合には、新たに構築したオブジェクトのプロパティ k には、引数 k が設定されます。 これらのプロパティの全ては、属性 {[[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true} を持ちます。</p>
    <h3 id="15-4-2-2-new-array-len-">15.4.2.2 new Array (len)</h3>
    <p>　新たに構築したオブジェクトの内部プロパティ[[Prototype]]には、 Array.prototype (15.4.3.1)の初期値であるオリジナルのArrayプロトタイプオブジェクトが設定されます。 新たに構築したオブジェクトの内部プロパティ[[Class]]には、“Array”が設定されます。 新たに構築したオブジェクトの内部プロパティ[[Extensible]]には、trueが設定されます。</p>
    <p>　引数 lenが、 len と等しい Number であり、 ToUint32(len) (が、真)である場合、新たに構築したオブジェクトのlengthプロパティには、ToUint32(len)が設定されます。 引数 lenが、 len と等しくない Number であり、 ToUint32(len) (が、真)である場合、RangeError例外が投げられます(スローされます)。</p>
    <p>　引数 lenが、Numberではない場合、新たに構築したオブジェクトのlengthプロパティには、1が、新たに構築したオブジェクトのプロパティ 0 には、属性 {[[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true} を伴う len が設定されます。</p>
    <h2 id="15-4-3-array-properties-of-the-array-constructor-standard-ecma-262-5-1-edition">15.4.3 Array コンストラクタのプロパティ / Properties of the Array Constructor / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="15-ecmascript-">15 標準組み込みECMAScriptオブジェクト</h3>
    <h3 id="15-4-array-">15.4 Arrayオブジェクト</h3>
    <h3 id="15-4-3-array-">15.4.3 Array コンストラクタのプロパティ</h3>
    <p>　Array コンストラクタの内部プロパティ[[Prototype]]の値は、Functionプロトタイプオブジェクト(15.3.4)です。 更に内部プロパティと(値が1である)lengthプロパティの他、Array コンストラクタは、次のプロパティを持ちます。</p>
    <h3 id="15-4-3-1-array-prototype">15.4.3.1 Array.prototype</h3>
    <p>　Array.prototypeの初期値は、Arrayプロトタイプオブジェクト(15.4.4)です。 このプロパティは、属性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false } を持ちます。</p>
    <h3 id="15-4-3-2-array-isarray-arg-">15.4.3.2 Array.isArray ( arg )</h3>
    <p>　 isArray関数は、1つの引数を取り、引数が内部プロパティ class が“Array”であるオブジェクトである場合、Boolean値のtrueを返し、それ以外の場合、falseを返します。 (isArray関数は、)次のステップが取られます。</p>
<pre><code>1. Type(arg) が、 Objectではない場合、falseを返す
    2. arg の内部プロパティ[[Class]]の値が、&quot;Array&quot;である場合、trueを返す
    3. falseを返す
</code></pre><h2 id="15-4-4-array-properties-of-the-array-prototype-object-standard-ecma-262-5-1-edition">15.4.4 Arrayプロトタイプオブジェクトのプロパティ / Properties of the Array Prototype Object / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="15-ecmascript-">15 標準組み込みECMAScriptオブジェクト</h3>
    <h3 id="15-4-array-">15.4 Arrayオブジェクト</h3>
    <h3 id="15-4-4-array-">15.4.4 Arrayプロトタイプオブジェクトのプロパティ</h3>
    <p>　Arrayプロトタイプオブジェクトの内部プロパティ[[Prototype]]の値は、標準組み込みObjectプロトタイプオブジェクト(15.2.4)です。</p>
    <p>　Arrayプロトタイプオブジェクトは、それ自身の配列であり、その(内部プロパティ)[[Class]]が、“Array”で且つ、(初期値が+0である)lengthプロパティと 15.4.5.1 で説明した特殊な[[DefineOwnProperty]]内部メソッドを持ちます。</p>
    <p>　次のArrayプロトタイプオブジェクトのプロパティである関数の説明については、フレーズ「 this オブジェクト」は、関数の呼び出しにおいて this 値であるオブジェクトを参照します。 内部プロパティ[[Class]]の値が、“Array”ではないオブジェクトとする為に this が許容されます。</p>
    <p>[注釈]</p>
    <p>　Arrayプロトタイプオブジェクトは、その自身の valueOf プロパティは持ちませんが、標準組み込みObjectプロトタイプオブジェクトから valueOf プロパティを継承します。</p>
    <h3 id="15-4-4-1-array-prototype-constructor">15.4.4.1 Array.prototype.constructor</h3>
    <p>　Array.prototype.constructorの初期値は、標準組み込みArrayコンストラクタです。</p>
    <h3 id="15-4-4-2-array-prototype-tostring-">15.4.4.2 Array.prototype.toString ( )</h3>
    <p>　toStringメソッドが呼ばれる際には、次のステップが取られます。</p>
<pre><code>1. array は、this 値上でToObjectを呼んだ結果とする
    2. func は、引数&quot;join&quot;を伴う内部メソッド[[Get]]を呼んだ結果とする
    3. IsCallable(func) が、 falseである場合、 func は、標準組み込みメソッド Object.prototype.toString (15.2.4.2)とする
    4. this 値とカラの引数のリストとして array を提供して func の内部メソッド[[Call]]を呼んだ結果を返す
</code></pre><p>[注釈]</p>
    <p>　toString関数は、汎用的であることが意図され、その this 値がArrayオブジェクトとなることは要求されません。 その為、メソッドとしての使用において他の種類のオブジェクトに転送することができます。 toString関数が、ホストオブジェクトにうまく適用することが可能かどうかについては、実装依存です。</p>
    <h3 id="15-4-4-3-array-prototype-tolocalestring-">15.4.4.3 Array.prototype.toLocaleString ( )</h3>
    <p>　配列の要素は、それらの toLocaleString メソッド、そしてまた実装定義のロケール仕様の方法の中で使用されている文字列の区切りの出現によって連結、分割される場合のこれら文字列を使用して文字列に変換されます。 この関数を呼んだ結果は、ロケール仕様になることが意図されるこの関数の結果を除き、toStringの結果と類似したものになることが意図されます。 結果は、次のように計算されます。</p>
<pre><code>1. array は、引数として this 値を渡して ToObject を呼んだ結果とする
    2. arrayLen は、引数&quot;length&quot;を伴う配列の内部メソッド[[Get]]を呼んだ結果とする
    3. len は、 ToUint32(arrayLen) とする
    4. separator は、ホスト環境の(実装定義による方法で使用される)現在のロケールにおいて適切なリストセパレータ文字列におけるString値とする
    5. len が、ゼロである場合、カラの文字列を返す
    6. firstElement は、引数&quot;0&quot;を伴う array の内部メソッド[[Get]]を呼んだ結果とする
    7. firstElement が、 undefined や nullである場合、
    a. R は、カラの文字列とする
    8.それ以外の場合、
    a. elementObj は、 ToObject(firstElement) とする
    b. func は、引数&quot;toLocaleString&quot;を伴う elementObj の内部メソッド[[Get]]を呼んだ結果とする
    c. IsCallable(func) が、 falseである場合、TypeError例外を投げる(スローする)
    d. R は、this 値として elementObj とカラの引数リストを提供して func の内部メソッド[[Call]]を呼んだ結果とする
    9.  k は、1とする
    10. while k &lt; len という条件下で繰り返す
    a. S は、R とセパレータを連結することによって生成したString値とする
    b. nextElement は、引数ToString(k)を伴う array の内部メソッド[[Get]]を呼んだ結果とする
    c. nextElement が、 undefined または、 nullである場合、
    i. R は、カラの文字列とする
    d.それ以外の場合、
    i. elementObj は、 ToObject(nextElement) とする
    ii. func は、引数&quot;toLocaleString&quot;を伴う elementObj の内部メソッド[[Get]]を呼んだ結果とする
    iii. IsCallable(func) が、 falseである場合、TypeErrorを投げる(スローする)
    iv. R は、this値として elementObj とカラの引数リストを提供して funcの内部メソッド[[Call]]を呼んだ結果とする
    e. R は、S と R を連結することによって生成した文字列値とする
    f. k を1で増分する
    11. R を返す
</code></pre><p>[注釈 1]</p>
    <p>　この関数の1つめのパラメータは、この標準仕様の将来バージョンで使用されることになるかもしれません。 つまり、実装は、いかなる場合にもこのパラメータ位置を使用しないことが推奨されます。</p>
    <p>[注釈 2]</p>
    <p>　toLocaleString関数は、汎用化されることが意図され、その this 値がArrayオブジェクトとなることは要求されません。 その為、メソッドとしての使用においては、他の種類のオブジェクトに転送することが可能です。 toLocaleString関数が、うまくホストオブジェクトに適用されることが可能か否かについては、実装依存です。</p>
    <h3 id="15-4-4-4-array-prototype-concat-item1-item2-">15.4.4.4 Array.prototype.concat ( [ item1 [ , item2 [ , … ] ] ] )</h3>
    <p>　concatメソッドは、ゼロ個以上の引数 item1, item2,…を伴って呼ばれる際には、順番に引数ごとの配列要素によって続くオブジェクトの配列要素を連結した配列を返します。 (concatメソッドでは、)次のステップが取られます。</p>
<pre><code>1. O は、引数として this 値を渡して ToObject を呼んだ結果とする
    2. A は、その名を持つ標準組み込みコンストラクタであるArrayを式 new Array() によるものであるかのように新たに生成した配列とする
    3. n は、0とする
    4. items は、この関数呼び出しについて渡された引数を左から右の順に1つめの要素が0である次の要素を持つ内部リストとする。
    5. items がカラでない間、繰り返す
    a. items から1つめの要素を削除し、 E は、当該要素の値とする
    b. E の内部プロパティ[[Class]]の値が、&quot;Array&quot;である場合、
    i. k は、 0とする
    ii. len は、引数&quot;length&quot;を伴う E の内部メソッド[[Get]]を呼んだ結果とする
    iii. while k &lt; len という条件下で繰り返す
    1. P は、 ToString(k) とする
    2. exists は、 P を伴う E の内部メソッド[[HasProperty]]を呼んだ結果とする
    3. exists が、 trueである場合、
    a subElement は、引数 P を伴う E の内部メソッド[[Get]]を呼んだ結果とする
    b 引数ToString(n)、プロパティ記述子 {[[Value]]: subElement, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}、 falseを伴う A の内部メソッド[[DefineOwnProperty]]を呼ぶ
    4. nを1で増分する
    5. kを1で増分する
    c. E が、 Arrayではない場合、
    i.引数ToString(n)、プロパティ記述子 {[[Value]]: E, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}、 falseを伴う A の内部メソッド[[DefineOwnProperty]]を呼ぶ
    ii. nを1で増分する
    6. A を返す
</code></pre><p>　concatメソッドのlength プロパティは、1です。</p>
    <p>[注釈]</p>
    <p>　concat関数は、汎用化されることが意図され、その this 値がArrayオブジェクトとなることを要求しません。 その為、メソッドとしての利用においてオブジェクトの他の種類に転送されることが可能です。 concat関数が、ホストオブジェクトにうまく適用されることが可能か否かについては、実装依存です。</p>
    <h3 id="15-4-4-5-array-prototype-join-separator-">15.4.4.5 Array.prototype.join (separator)</h3>
    <p>　配列の要素は、文字列に変換され、これらの文字列は、セパレータの出現によって連結、分割されます。 セパレータが一切提供されない場合、1つのカンマが、セパレータとして利用されます。</p>
    <p>　 joinメソッドは、1つの引数とセパレータを取り、次のステップを実行します。</p>
<pre><code>1. O は、引数として this 値を渡して ToObject を呼んだ結果とする
    2. lenVal は、引数&quot;length&quot;を伴う O　の内部メソッド[[Get]]を呼んだ結果とする
    3. len は、 ToUint32(lenVal) とする
    4. separator が、 undefinedである場合、separator は、1文字の文字列&quot;,&quot;とする
    5. sep は、 ToString(separator) とする
    6. len が、ゼロである場合、カラの文字列を返す
    7. element0 は、引数&quot;0&quot;を伴う O の内部メソッド[[Get]]を呼んだ結果とする
    8. element0 が、undefined または nullである場合、 R は、カラの文字列とし、それ以外の場合、R は、 ToString(element0) とする
    9. k は、 1とする
    10. while k &lt; len という条件下で繰り返す
    a. S は、 R と sep を連結することによって生成したString値とする
    b. element は、引数 ToString(k) を伴う O の内部メソッド[[Get]]を呼んだ結果とする
    c. element が、undefined または、 nullである場合、 next は、カラの文字列とし、それ以外の場合、next は、ToString(element) とする
    d. R は、 S と next を連結することによって生成した文字列値とする
    e. kを1で増分する
    11. R を返す
</code></pre><p>　 joinメソッドのlengthプロパティは、1です。</p>
    <p>[注釈]</p>
    <p>　 join関数は、汎用的であることが意図され、その this 値をArrayオブジェクトとすることは要求されません。 その為、メソッドとしての使用においてオブジェクトの他の種類に転送することが可能です。 join関数がホストオブジェクトにうまく適用されることが可能か否かについては、実装依存です。</p>
    <h3 id="15-4-4-6-array-prototype-pop-">15.4.4.6 Array.prototype.pop ( )</h3>
    <p>　配列の最後の要素が、配列から削除されて返されます。</p>
<pre><code>1. O は、引数として this 値を渡して ToObject を呼んだ結果とする
    2. lenVal は、引数&quot;length&quot;を伴う O の内部メソッド[[Get]]を呼んだ結果とする
    3. len は、ToUint32(lenVal) とする
    4. len がゼロである場合、
    a.引数&quot;length&quot;、0、trueを伴う O の内部メソッド[[Put]]を呼ぶ
    b. undefinedを返す
    5.それ以外の場合、 len &gt; 0 という条件を満たし
    a. indx は、 ToString(len-1) とする
    b. elementは、引数 indx を伴う O の内部メソッド[[Get]]を呼んだ結果とする
    c.引数 &quot;length&quot; と indx 、trueを伴う O の内部メソッド[[Delete]]を呼ぶ
    d.引数 &quot;length&quot; と indx 、trueを伴う O の内部メソッド[[Put]]を呼ぶ
    e. element を返す
</code></pre><p>[注釈]</p>
    <p>　 pop関数は、汎用的であることが意図され、その this 値がArrayオブジェクトとなることを要求しません。 その為、メソッドとしての使用においてオブジェクトの他の種類に転送することが可能です。 pop関数がホストオブジェクトにうまく適用されることが可能か否かについては、実装依存です。</p>
    <h3 id="15-4-4-7-array-prototype-push-item1-item2-">15.4.4.7 Array.prototype.push ( [ item1 [ , item2 [ , … ] ] ] )</h3>
    <p>　引数が、現れる順に配列の最後尾に追加されます。 新たな配列の長さが、呼んだ結果として返されます。</p>
    <p>　pushメソッドが、ゼロ個以上の引数 item1, item2,…を伴って呼ばれる場合、次のステップが取られます。</p>
<pre><code>1. O は、引数として this 値を渡して ToObject を呼んだ結果とする
    2. lenVal は、引数&quot;length&quot;を伴う O の内部メソッド[[Get]]を呼んだ結果とする
    3. n は、 ToUint32(lenVal) とする
    4. items は、左から右の順にこの関数呼び出しの為に渡された引数を要素として持つ内部リストとする
    5. items がカラでない間、繰り返す
    a.  itemsから1つめの要素を削除し、E は、要素の値とする
    b.引数ToString(n)、E、trueを伴う O の内部メソッド[[Put]]を呼ぶ
    c. n を1で増分する
    6.引数&quot;length&quot;、n、trueを伴う O の内部メソッド[[Put]]を呼ぶ
    7. n を返す
</code></pre><p>　pushメソッドの length プロパティは1です。</p>
    <p>[注釈]</p>
    <p>　push関数は、汎用的であることが意図され、その this 値がArrayオブジェクトとなることを要求しません。 その為、メソッドとしての使用においてオブジェクトの他の種類に転送することが可能です。 push関数が、ホストオブジェクトにうまく適用されることが可能か否かについては、実装依存です。</p>
    <h3 id="15-4-4-8-array-prototype-reverse-">15.4.4.8 Array.prototype.reverse ( )</h3>
    <p>　配列の要素が、その逆順であるものとして再編成(並び替え)されます。 オブジェクトは、呼んだ結果として返されます。</p>
<pre><code>1. O は、引数として this 値を渡して ToObject を呼んだ結果とする
    2. lenVal は、引数&quot;length&quot;を伴う O の内部メソッド[[Get]]を呼んだ結果とする
    3. len は、 ToUint32(lenVal) とする
    4. middle は、 floor(len/2) とする
    5. lower は、 0 とする
    6. lower ≠ middleである間、繰り返す
    a. upper は、len-lower-1 とする
    b. upperP は、 ToString(upper) とする
    c. lowerP は、 ToString(lower) とする
    d. lowerValue は、引数 lowerP を伴う O の内部メソッド[[Get]]を呼んだ結果とする
    e. upperValue は、引数 upperP を伴う O の内部メソッド[[Get]]を呼んだ結果とする
    f. lowerExists は、引数 lowerP を伴う O の内部メソッド[[HasProperty]]を呼んだ結果とする
    g. upperExists は、引数 upperP を伴う O の内部メソッド[[HasProperty]]を呼んだ結果とする
    h. lowerExists が、true で且つ、 upperExists が、trueである場合、
    i.引数 lowerP、upperValue、trueを伴う O の内部メソッド[[Put]]を呼ぶ
    ii.引数 upperP、lowerValue、trueを伴う O の内部メソッド[[Put]]を呼ぶ
    i. lowerExists が、 false 且つ、 upperExists が、trueである場合、
    i.引数 lowerP、upperValue、trueを伴う O の内部メソッド[[Put]]を呼ぶ
    ii.引数 upperP、trueを伴う O の内部メソッド[[Delete]]を呼ぶ
    j. lowerExists が、 true 且つ、 upperExists が、 falseである場合、
    i.引数 lowerP、trueを伴う O の内部メソッド[[Delete]]を呼ぶ
    ii.引数 upperP、lowerValue、trueを伴う O の内部メソッド[[Put]]を呼ぶ
    k.それ以外の場合、 lowerExists と upperExists は共にfalseであり、
    i.要求される動作は何もない
    l.lower を1で増分する
    7. O を返す
</code></pre><p>[注釈]</p>
    <p>　reverse関数は、汎用的であることが意図され、その this 値がArrayオブジェクトとなることを要求しません。 その為、メソッドとしての使用においてオブジェクトの他の種類に転送することが可能です。 reverse関数が、ホストオブジェクトにうまく適用されることが可能か否かについては、実装依存です。</p>
    <h3 id="15-4-4-9-array-prototype-shift-">15.4.4.9 Array.prototype.shift ( )</h3>
    <p>　配列の先頭の要素が、当該配列から削除されて返されます。</p>
<pre><code>1. O は、引数としてその this 値を渡して ToObject を呼んだ結果とする
    2. lenVal は引数&quot;length&quot;を伴う O の内部メソッド[[Get]]を呼んだ結果とする
    3. len は、 ToUint32(lenVal) とする
    4. len がゼロである場合、
    a.引数&quot;length&quot;、0、trueを伴う O の内部メソッド[[Put]]を呼ぶ
    b. undefined を返す
    5. first は、引数&quot;0&quot;を伴う O の内部メソッド[[Get]]を呼んだ結果とする
    6. k は、1とする
    7. while k &lt; len という条件下で繰り返す
    a. from は、 ToString(k) とする
    b. to は、 ToString(k-1) とする
    c. fromPresent は、引数 fromを伴う O の内部メソッド[[HasProperty]]を呼んだ結果とする
    d. fromPresent が、 trueである場合、
    i. fromVal は、引数 from を伴う O の内部メソッド[[Get]]を呼んだ結果とする
    ii.引数 to、fromVal、trueを伴う O の内部メソッド[[Put]]を呼ぶ
    e.それ以外の場合、 fromPresent は、 falseであり、
    i.引数 to と trueを伴う O の内部メソッド[[Delete]]を呼ぶ
    f. k を1で増分する
    8.引数 ToString(len-1) と true を伴う O の内部メソッド[[Delete]]を呼ぶ
    9.引数&quot;length&quot;、(len-1)、trueを伴う O の内部メソッド[[Put]]を呼ぶ
    10. first を返す
</code></pre><p>[注釈]</p>
    <p>　 shift関数は、汎用的であることが意図され、その this 値がArrayオブジェクトとなることを要求しません。 その為、メソッドとしての使用においてオブジェクトの他の種類に転送することが可能です。 shift関数が、ホストオブジェクトにうまく適用されることが可能か否かについては、実装依存です。</p>
    <h3 id="15-4-4-10-array-prototype-slice-start-end-">15.4.4.10 Array.prototype.slice (start, end)</h3>
    <p>　sliceメソッドは、 start と end という2つの引数を取り、配列の要素の(文字位置) start から最後(文字位置 end )までを含んでいる配列の要素全てを返しますが、要素が含まれていない場合には末尾の要素(、最後尾がundefinedである場合、配列の末尾まで)を返します。 startが、負の値である場合、配列の長さである length は、 length + start として扱われます。 endが、負の値である場合、配列の長さである length は、 length + end として扱われます。</p>
    <p>　(sliceメソッドは、)次のステップを取ります。</p>
<pre><code>1. O は、引数としてその this 値を渡して ToObject を呼んだ結果とする
    2. A は、その名を伴う標準組み込みコンストラクタであるArrayを式 new Array() によるかのように生成した新たな配列とする
    3. lenVal は、引数&quot;length&quot;を伴う O の内部メソッド[[Get]]を呼んだ結果とする
    4. len は、 ToUint32(lenVal) とする
    5. relativeStart は、 ToInteger(start) とする
    6. relativeStart が、負の値である場合、 k は、 max((len + relativeStart),0) とし、それ以外の場合、k は、 min(relativeStart, len) とする
    7. end が、 undefinedである場合、 relativeEnd は、 len とし、それ以外の場合、 relativeEnd は、 ToInteger(end) とする
    8. relativeEnd が、負の値である場合、 final は、max((len + relativeEnd),0) とし、それ以外の場合、final は、 min(relativeEnd, len) とする
    9. n は、0 とする
    10. while k &lt; final という条件下で繰り返す
    a. Pk は、 ToString(k) とする
    b. kPresent は、引数 Pk を伴う O の内部メソッド[[HasProperty]]を呼んだ結果とする
    c. kPresent が、 trueである場合、
    i. kValue は、引数 Pk を伴う O の内部メソッド[[Get]]を呼んだ結果とする
    ii 引数 ToString(n)、プロパティ記述子 {[[Value]]: kValue, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}、 falseを伴う A の内部メソッド[[DefineOwnProperty]]を呼ぶ
    d. k を1で増分する
    e. n を1で増分する
    11. A を返す
</code></pre><p>　sliceメソッドのlengthプロパティは、2です。</p>
    <p>[注釈]</p>
    <p>　slice関数は、汎用的であることが意図され、その this 値がArrayオブジェクトとなることを要求しません。 その為、メソッドとしての使用においてオブジェクトの他の種類に転送することが可能です。 slice関数が、ホストオブジェクトにうまく適用されることが可能か否かについては、実装依存です。</p>
    <h3 id="15-4-4-11-array-prototype-sort-comparefn-">15.4.4.11 Array.prototype.sort (comparefn)</h3>
    <p>　この配列の要素が、並べ替えられます(ソートされます)。 sortは、安定している必要はありません。(つまり、それは、等価性を比較する要素が、元の順番のままである必要はないということです。) comparefn が、undefinedである場合、 x と y という2つの引数を許容し、 x \&lt; y である場合、負の値、 x = y である場合、ゼロ、または、 x > y である場合、正の値を返すような関数とすべきです。</p>
    <p>　 obj は、引数として this 値を渡して ToObject を呼んだ結果とします。 len は、引数“length”を伴う obj の内部メソッド[[Get]]を呼んだ結果をUint32に適用した結果とします。</p>
    <p>　 comparefn が、undefinedではない場合、この配列(以下参照)の要素として一貫性のない比較関数におけるソートの動作は、実装定義です。</p>
    <p>　 proto は、 obj の内部プロパティ[[Prototype]]の値とします。 proto が、 nullでなく、且つ、以下の条件の全てが満たされるような整数 j が存在する場合、ソートの動作は、実装定義です。</p>
    <ul>
        <li>obj が、 sparse (15.4)</li>
        <li>0 ≦ j \&lt; len</li>
        <li>引数 ToString(j) が、 proto の内部メソッド[[HasProperty]]を呼んだ結果が、true</li>
    </ul>
    <p>　ソートの動作は、obj が、sparse で且つ、次の条件の一部が、trueである場合も実装定義とされます。</p>
    <ul>
        <li>obj の内部プロパティ[[Extensible]]が、false</li>
        <li>[[Configurable]]属性を持つデータプロパティである len より小さい非負の整数である名称を持つ obj の配列インデックスプロパティの一部が、false</li>
    </ul>
    <p>　ソートの動作は、アクセサプロパティまたは、[[Writable]]属性を持つデータプロパティである len より小さい非負の整数である名称を持つ obj の配列インデックスプロパティの一部が、falseである場合にも実装定義とされます。</p>
    <p>　それ以外の場合には、次のステップが取られます。</p>
<pre><code>1. obj の内部メソッド[[Get]]、[[Put]]や[[Delete]]と(以下で説明した) SortCompare を呼ぶ実装定義の並びを実行
    SortCompare は、len より小さく、内部メソッド[[Get]]を呼ぶ前の結果である SortCompare を呼ぶ為の引数である非負の整数である[[Get]]、[[Put]]や[[Delete]]を呼ぶごとの最初の引数
    obj が、 sparse ではない場合、[[Delete]]は、呼ばれてはいけない
    2. obj を返す
</code></pre><p>　返したオブジェクトは、次の2つのプロパティを持っていなければいけません。</p>
    <ul>
        <li>これらは、len よりも小さい非負の整数 j ごとに、といった場合に len より小さい非負の整数として任意の数学的な順列 π にしなければならず、プロパティ old[ j ] が、存在する場合、 new[π( j )] は、old[ j ],と全く同一。しかし、一方でプロパティ old[ j ] が、存在しない場合、 new[π( j )] も存在しない。</li>
        <li>その場合、 len より小さい全ての非負の整数 j と k において SortCompare( j , k ) \&lt; 0 (下記 SortCompare 参照)である場合、 π( j ) \&lt; π( k ) である</li>
    </ul>
    <p>　これは、表記法 old[ j ] は、この関数が実行される前に引数 j を伴う obj の内部メソッド[[Get]]を呼んだ結果と仮定して参照する為に使用され、表記法 new[ j ] は、この関数が実行された後、引数 j を伴う obj の内部メソッド[[Get]]を呼んだ結果と仮定して参照する為に使用されるということです。</p>
    <p>　関数 comparefn は、以下の要求の全てが、集合 S にある(可能な限り同じ値である)a、b、cという値全てに遭遇する場合、 表記法 a \&lt; CF b は、comparefn( a , b ) \&lt; 0 を a = CF b は、 comparefn( a , b ) = 0 (何れかの符号の0)を意味し、 また、 a > CF b は、 comparefn( a , b ) > 0 を意味します。</p>
    <ul>
        <li>その2つの引数として値 a と b という組みの指定が与えられる場合、呼び出し comparefn( a , b ) は、常に同じ値 v を返します。更に Type(v) は、 Numberであり、 v は、NaN ではありません。この意味するところを注記すると a \&lt; CF b、a = CF b、 a > CF b の何れか1つは、 a と b という組み合わせが与えられる場合、確実にtrueになります。</li>
        <li>呼び出し comparefn(a,b) は、this オブジェクトを修正しない</li>
        <li>a = CF a (reflexivity・反射性)</li>
        <li>a = CF b である場合、 b = CF a (symmetry・対称性)</li>
        <li>a = CF b 且つ b = CF c である場合 a = CF c ( = CF の推移性)</li>
        <li>a \&lt; CF b 且つ b \&lt;CF c である場合 a \&lt; CF c ( \&lt; CF の推移性)</li>
        <li>a > CF b 且つ b >CF c である場合 a > CF c ( > CF の推移性)</li>
    </ul>
    <p>[注釈]</p>
    <p>　上記条件は、等価クラスと完全に順序づけされる等価クラスにおける集合 S を分割する comparefn を確保するに当たり必要十分です。</p>
    <p>　SortCompare抽象操作は、j と k という2つの引数を伴って呼ばれる際には、次のステップが取られます。</p>
<pre><code>1. jString は、 ToString(j) とする
    2. kString は、 ToString(k) とする
    3. hasj  は、引数 jStringを伴う obj の内部メソッド[[HasProperty]]を呼んだ結果とする
    4. hask  は、引数 kStringを伴う obj の内部メソッド[[HasProperty]]を呼んだ結果とする
    5. hasj と hask が、共に falseである場合、+0を返す
    6. hasj が、 falseである場合、1を返す
    7. hask が、 falseである場合、-1を返す
    8. x は、引数 jStringを伴う obj の内部メソッド[[Get]]を呼んだ結果とする
    9. y は、引数 kStringを伴う obj の内部メソッド[[Get]]を呼んだ結果とする
    10. x と y が共に undefined である場合、+0を返す
    11. x が、 undefinedである場合、1を返す
    12. y が、 undefinedである場合、-1を返す
    13.引数 comparefn が、undefinedではない場合、
    a. IsCallable(comparefn) が、 falseである場合、TypeError例外を投げる(スローする)
    b. this 値として undefined と引数 x と y を渡して comparefn の内部メソッド[[Call]]を呼んだ結果を返す
    14. xString は、 ToString(x) とする
    15. yString は、 ToString(y) とする
    16. xString &lt; yStringである場合、-1を返す
    17. xString &gt; yStringである場合、1を返す
    18. +0を返す
</code></pre><p>[注釈 1]</p>
    <p>　存在しないプロパティ値は、常に undefined プロパティ値よりも大きいものとして比較し、 undefined は、常に他のいかなる値より大きいものとして比較する為、 undefined プロパティ値は、常に存在しないプロパティ値が続いた結果の終わりまでソートします。</p>
    <p>[注釈 2]</p>
    <p>　sort関数は、汎用的であることが意図され、その this 値がArrayオブジェクトとなることを要求しません。 その為、メソッドとしての使用においてオブジェクトの他の種類に転送することが可能です。 sort関数が、ホストオブジェクトにうまく適用されることが可能か否かについては、実装依存です。</p>
    <h3 id="15-4-4-12-array-prototype-splice-start-deletecount-item1-item2-">15.4.4.12 Array.prototype.splice (start, deleteCount [ , item1 [ , item2 [ , … ] ] ] )</h3>
    <p>　spliceメソッドが、 start、deleteCount、(オプションとして) item1、item2… のように2つ以上の引数を伴って呼ばれる際には、配列インデックスの start (位置)で始まる配列の deleteCount 要素は、引数 item1、item2…等々によって置換されます。 削除済み要素を含んでいるArrayオブジェクトは、(もし、何かあれば)返されます。</p>
    <p>　(spliceメソッドは、)次のステップが取られます。</p>
<pre><code>1. O は、引数としてその this 値を渡して ToObject を呼んだ結果とする
    2. A は、その名を持つ標準組み込みコンストラクタである Array を式 new Array() によるかのように生成した新たな配列とする
    3. lenVal は、引数&quot;length&quot;を伴う O の内部メソッド[[Get]]を呼んだ結果とする
    4. len は、 ToUint32(lenVal) とする
    5. relativeStart は、 ToInteger(start) とする
    6. relativeStart が、負の値である場合、 actualStart は、 max((len + relativeStart),0) とし、それ以外の場合、 actualStart は、 min(relativeStart, len) とする
    7. actualDeleteCount は、 min(max(ToInteger(deleteCount),0), len - actualStart) とする
    8. k は、0とする
    9. while k &lt; actualDeleteCount の条件下で繰り返す
    a. from は、 ToString(actualStart+k) とする
    b. fromPresent は、引数 from を伴う O の内部メソッド[[HasProperty]]を呼んだ結果とする
    c. fromPresent が、 trueである場合、
    i. fromValue は、引数 from を伴う O の内部メソッド[[Get]]を呼んだ結果とする
    ii.引数 ToString(k) 、プロパティ記述子 {[[Value]]: fromValue, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}、 falseを伴う A の内部メソッド[[DefineOwnProperty]]を呼ぶ
    d. kを1で増分する
    10. items は、item1を伴う実際の配列リストの開始の位置において左から右への順とした要素を持つ内部リストとし、list は、そのような items が何も存在しない場合、カラとする
    11. itemCount は、 items にある要素数とする
    12. itemCount &lt; actualDeleteCount である場合、
    a. k は、 actualStart とする
    b. while k &lt; (len - actualDeleteCount) という条件下で繰り返す
    i. from は、 ToString(k+actualDeleteCount) とする
    ii. to は、 ToString(k+itemCount) とする
    iii. fromPresent は、引数 from を伴う O の内部メソッド[[HasProperty]]を呼んだ結果とする
    iv. fromPresent が、 trueである場合、
    1. fromValue は、引数 from を伴う O の内部メソッド[[Get]]を呼んだ結果とする
    2.引数 to、fromValue、true を伴う O の内部メソッド[[Put]]を呼ぶ
    v.それ以外の場合、 fromPresent は、 false であり、
    1.引数 to、true を伴う O の内部メソッド[[Delete]]を呼ぶ
    vi. k を1で増分する
    c. k は、len とする
    d. while k &gt; (len - actualDeleteCount + itemCount) という条件下で繰り返す
    i.引数 ToString(k-1)、true を伴う O の内部メソッド[[Delete]]を呼ぶ
    ii. k を1で減分する
    13. itemCount &gt; actualDeleteCount である場合、
    a. k は、 (len - actualDeleteCount) とする
    b. while k &gt; actualStart という条件下で繰り返す
    i. from は、 ToString(k + actualDeleteCount - 1) とする
    ii. to は、 ToString(k + itemCount - 1) とする
    iii. fromPresent は、引数 from を伴う O の内部メソッド[[HasProperty]]を呼んだ結果とする
    iv. fromPresent が、 true である場合、
    1. fromValue は、引数 from を伴う O の内部メソッド[[Get]]を呼んだ結果とする
    2.引数 to、fromValue、true を伴う O の内部メソッド[[Put]]を呼ぶ
    v.それ以外の場合、 fromPresent は、 false であり、
    1.引数 to と trueを伴う O の内部メソッド[[Delete]]を呼ぶ
    vi. k を1で減分する
    14. k は、 actualStart とする
    15. items がカラでない間、繰り返す
    a. items から1つめの要素を削除し、 E は、当該要素の値とする
    b.引数 ToString(k)、E、true を伴う O の内部メソッド[[Put]]を呼ぶ
    c. k を1で増分する
    16.引数 &quot;length&quot;、(len - actualDeleteCount + itemCount)、true を伴う O の内部メソッド[[Put]]を呼ぶ
    17. A を返す
</code></pre><p>　spliceメソッドの length プロパティは、2です。</p>
    <p>[注釈]</p>
    <p>　splice関数は、汎用的であることが意図され、その this 値がArrayオブジェクトとなることを要求しません。 その為、メソッドとしての使用においてオブジェクトの他の種類に転送することが可能です。 splice関数が、ホストオブジェクトにうまく適用されることが可能か否かについては、実装依存です。</p>
    <h3 id="15-4-4-13-array-prototype-unshift-item1-item2-">15.4.4.13 Array.prototype.unshift ( [ item1 [ , item2 [ , … ] ] ] )</h3>
    <p>　引数が、引数リスト内に現れるのと同じ順である配列内でそのようなそれらの順である配列の先頭に付加されます。</p>
    <p>　unshiftメソッドが、 item1、item2…といったゼロ個以上の引数を伴って呼ばれる際には、次のステップが取られます。</p>
<pre><code>1. O は、引数として this 値を渡して ToObject を呼んだ結果とする
    2. lenVal は、引数&quot;length&quot;を伴う O の内部メソッド[[Get]]を呼んだ結果とする
    3. len は、 ToUint32(lenVal) とする
    4. argCount は、実際の引数の数とする
    5. k は、 len とする
    6. while k &gt; 0 という条件下で繰り返す
    a. from は、 ToString(k-1) とする
    b. to は、 ToString(k+argCount - 1) とする
    c. fromPresent は、引数 from を伴う O の内部メソッド[[HasProperty]]を呼んだ結果とする
    d. fromPresent が、 trueである場合、
    i. fromValue は、引数 from を伴う O の内部メソッド[[Get]]を呼んだ結果とする
    ii.引数 to、fromValue、true を伴う O の内部メソッド[[Put]]を呼ぶ
    e.それ以外の場合、 fromPresent は、 false であり、
    i.引数 to、true を伴う O の内部メソッド[[Delete]]を呼ぶ
    f. k を1で減分する
    7. j は、0とする
    8. items は、呼び出されるこの関数を渡された引数を左から右の順とした要素を持つ内部リストとする
    9. items がカラでない間、繰り返す
    a. items から1つめの要素を削除し、 E は、当該要素の値とする
    b.引数 ToString(j)、E、trueを伴う O の内部メソッド[[Put]]を呼ぶ
    c. j を1で増分する
    10.引数&quot;length&quot;、len+argCount、trueを伴う O の内部メソッド[[Put]]を呼ぶ
    11. len+argCount を返す
</code></pre><p>　unshiftメソッドの length プロパティは、1です。</p>
    <p>[注釈]</p>
    <p>　unshift関数は、汎用的であることが意図され、その this 値がArrayオブジェクトとなることを要求しません。 その為、メソッドとしての使用においてオブジェクトの他の種類に転送することが可能です。 unshift関数が、ホストオブジェクトにうまく適用されることが可能か否かについては、実装依存です。</p>
    <h3 id="15-4-4-14-array-prototype-indexof-searchelement-fromindex-">15.4.4.14 Array.prototype.indexOf ( searchElement [ , fromIndex ] )</h3>
    <p>　 indexOf は、内部Strict Equality Comparison Algorithm／厳密等価比較アルゴリズム (11.9.6)を使用して1つ以上の位置を見つけた場合、昇順で searchElement と配列の要素を比較し、そのような位置の最初のインデックスを返し、それ以外は、-1を返します。 オプションである2つめの引数 fromIndex の既定値は、0 (配列全体は検索済みの状態)です。 (indexOfの結果が、)配列の大きさより大きいか等しい場合、-1が返され、この時、配列は検索済みではないでしょう。 それ(結果)が、負の値である場合、オフセット値として fromIndex を算出する為、配列の末尾から使用されます。 算出したインデックス値が、0より小さい場合、配列全体は、検索済みでしょう。</p>
    <p>　indexOfメソッドが、1つまたは2つの引数を伴って呼ばれる際には、次のステップが取られます。</p>
<pre><code>1. O は、引数として this 値を渡して ToObject を呼んだ結果とする
    2. lenValue は、引数&quot;length&quot;を伴う O の内部メソッド[[Get]]を呼んだ結果とする
    3. len は、 ToUint32(lenValue) とする
    4. len が、 0である場合、-1 を返す
    5.引数 fromIndex が、解析された場合、n は、 ToInteger(fromIndex) とし、それ以外の場合、n は、0とする
    6. n ≧ len である場合、 -1 を返す
    7. n ≧ 0 である場合、
    a. k は、 n とする
    8.それ以外の場合、  n &lt; 0 であり、
    a. k は、 len - abs(n) とする
    b. k が、0よりも小さい場合、k は、0とする
    9. while k &lt; len という条件下で繰り返す
    a. kPresent は、引数 ToString(k) を伴う O の内部メソッド[[HasProperty]]を呼んだ結果とする
    b. kPresent が、 trueである場合、
    i. elementK は、引数 ToString(k)  を伴う O の内部メソッド[[Get]]を呼んだ結果とする
    ii. same は、 searchElement と elementK に厳密等価比較アルゴリズムを適用した結果とする
    iii. same が、 trueである場合、 k を返す
    c. k を1で増分する
    10. -1 を返す
</code></pre><p>　indexOfメソッドの length プロパティは、1です。</p>
    <p>[注釈]</p>
    <p>　indexOf関数は、汎用的であることが意図され、その this 値がArrayオブジェクトとなることを要求しません。 その為、メソッドとしての使用においてオブジェクトの他の種類に転送することが可能です。 indexOf関数が、ホストオブジェクトにうまく適用されることが可能か否かについては、実装依存です。</p>
    <h3 id="15-4-4-15-array-prototype-lastindexof-searchelement-fromindex-">15.4.4.15 Array.prototype.lastIndexOf ( searchElement [ , fromIndex ] )</h3>
    <p>　 lastIndexOf は、内部Strict Equality Comparison Algorithm／厳密等価比較アルゴリズム (11.9.6)を使用して1つ以上の位置を見つけた場合、降順で searchElement と配列の要素を比較し、そのような位置の最後のインデックスを返し、それ以外は、-1を返します。 オプションである2つめの引数 fromIndex の既定値は、配列の大きさ - 1 (配列全体は検索済みの状態)です。 (lastIndexOfの結果が、)配列の大きさより大きいか等しい場合、配列全体が検索されます。 それ(結果)が、負の値である場合、オフセット値として fromIndex を算出する為、配列の末尾から使用されます。 算出したインデックス値が、0より小さい場合、-1が返されます。</p>
    <p>　lastIndexOfメソッドが、1つまたは2つの引数を伴って呼ばれる際には、次のステップが取られます。</p>
<pre><code>1. O は、引数として this 値を渡して ToObject を呼んだ結果とする
    2. lenValue は、引数&quot;length&quot;を伴う O の内部メソッド[[Get]]を呼んだ結果とする
    3. len は、 ToUint32(lenValue) とする
    4. len が、 0 である場合、-1 を返す
    5.引数 fromIndex が解析された場合、n は、ToInteger(fromIndex) とし、それ以外の場合、n は、len-1 とする
    6. n ≧ 0 である場合、 k は、 min(n, len - 1) とする
    7.それ以外の場合、 n &lt; 0 であり、
    a. k は、 len - abs(n) とする
    8. while k ≧ 0 という条件下で繰り返す
    a. kPresent は、引数 ToString(k) を伴う O の内部メソッド[[HasProperty]]を呼んだ結果とする
    b. kPresent が、 true である場合、
    i. elementK は、引数 ToString(k) を伴う O の内部メソッド[[Get]]を呼んだ結果とする
    ii. same は、 searchElement と elementK に厳密等価比較アルゴリズムを適用した結果とする
    iii. same が、 true である場合、k を返す
    c. k を1で減分する
    9. -1 を返す
</code></pre><p>　lastIndexOfメソッドの length プロパティは 1です。</p>
    <p>[注釈]</p>
    <p>　lastIndexOf関数は、汎用的であることが意図され、その this 値がArrayオブジェクトとなることを要求しません。 その為、メソッドとしての使用においてオブジェクトの他の種類に転送することが可能です。 lastIndexOf関数が、ホストオブジェクトにうまく適用されることが可能か否かについては、実装依存です。</p>
    <h3 id="15-4-4-16-array-prototype-every-callbackfn-thisarg-">15.4.4.16 Array.prototype.every ( callbackfn [ , thisArg ] )</h3>
    <p>　 callbackfn は、3つの引数を許容する関数とすべきであり、Boolean値 true、または、false に強制変換する値を返します。 every(メソッド) は、 falseを返す callbackfn を見つけるまで、昇順で、配列内にある要素ごとに1度 callbackfn を呼びます。 そのような要素が見つけられるごとに every(メソッド) は、すぐに falseを返します。 それ以外の場合、 callbackfn が、全ての要素において trueを返す場合には、 every(メソッド) は、 trueを返すでしょう。 callbackfn は、実際に存在する配列の要素についてのみ呼ばれ、欠落した配列の要素については呼ばれません。</p>
    <p>　 thisArg パラメータが提供される場合、それは、 callbackfn として呼び出されるごとに this 値として使用されるでしょう。 それが提供されない場合には、代わりに undefined が使用されます。</p>
    <p>　 callbackfn は、要素の値、要素のインデックス、走査中のオブジェクトの3つの引数を伴って呼ばれます。</p>
    <p>　 every(メソッド) は、 callbackfn を呼ぶことによって、呼ばれつつもオブジェクトが変異する可能性がある場合、当該オブジェクトを直接変異させることはありません。</p>
    <p>　 every(メソッド)によって処理した要素の範囲は、 callbackfn を最初に呼ぶ前に設定されます。 every(メソッド)の開始をコールした後、配列に追加される要素には、もう callbackfn が訪れることはありません。 存在する配列の要素が、変更される場合、 callbackfn を解析したものとしたそれらの値は、 every(メソッド)がそれらを訪れる時点での値となるでしょう。 every(メソッド)の開始呼び出しの後や訪問される前に削除される要素は、もう訪問されることはありません。 every(メソッド)は、数学上の量指定子“for all”のように動作します。 特にカラの配列については、それは、trueを返します。</p>
    <p>　 every メソッドが1つまたは2つの引数を伴って呼ばれる際には、次のステップが取られます。</p>
<pre><code>1. O は、引数として this 値を渡して ToObject を呼んだ結果とする
    2. lenValue は、引数&quot;length&quot;を伴う O の内部メソッド[[Get]]を呼んだ結果とする
    3. len は、 ToUint32(lenValue) とする
    4. IsCallable(callbackfn) が、 falseである場合、TypeError例外を投げる(スローする)
    5. thisArg が提供される場合、 T は、 thisArg とし、それ以外の場合、 T は、undefinedとする
    6. k は、 0 とする
    7. while k &lt; len という条件下で繰り返す
    a. Pk は、 ToString(k) とする
    b. kPresent は、引数 Pk を伴う O の内部メソッド[[HasProperty]]を呼んだ結果とする
    c. kPresent が、 trueである場合、
    i. kValue は、引数 Pk を伴う O の内部メソッド[[Get]]を呼んだ結果とする
    ii. testResult は、 this 値としての T と kValue、k、O を含む引数リストを伴う callbackfn の内部メソッド[[Call]]を呼んだ結果とする
    iii. ToBoolean(testResult) が、 false である場合、falseを返す
    d. kを1で増分する
    8. true を返す
</code></pre><p>　 everyメソッドの length プロパティは、1です。</p>
    <p>[注釈]</p>
    <p>　every関数は、汎用的であることが意図され、その this 値がArrayオブジェクトとなることを要求しません。 その為、メソッドとしての使用においてオブジェクトの他の種類に転送することが可能です。 every関数が、ホストオブジェクトにうまく適用されることが可能か否かについては、実装依存です。</p>
    <h3 id="15-4-4-17-array-prototype-some-callbackfn-thisarg-">15.4.4.17 Array.prototype.some ( callbackfn [ , thisArg ] )</h3>
    <p>　 callbackfn は、3つの引数を許容する関数とすべきであり、Boolean値 true、または、false に強制変換する値を返します。 some(メソッド) は、 trueを返す callbackfn を見つけるまで、昇順で、配列内にある要素ごとに1度 callbackfn を呼びます。 そのような要素が見つけられるごとに some(メソッド) は、すぐに trueを返します。 それ以外の場合、 some(メソッド) は、 falseを返します。 callbackfn は、実際に存在する配列の要素についてのみ呼ばれ、欠落した配列の要素については呼ばれません。</p>
    <p>　 thisArg パラメータが提供される場合、それは、 callbackfn として呼び出されるごとに this 値として使用されるでしょう。 それが提供されない場合には、代わりに undefined が使用されます。</p>
    <p>　 callbackfn は、要素の値、要素のインデックス、走査中のオブジェクトの3つの引数を伴って呼ばれます。</p>
    <p>some(メソッド) は、 callbackfn を呼ぶことによって、呼ばれつつもオブジェクトが変異する可能性がある場合、当該オブジェクトを直接変異させることはありません。</p>
    <p>　 some(メソッド)によって処理した要素の範囲は、 callbackfn を最初に呼ぶ前に設定されます。 some(メソッド)の開始をコールした後、配列に追加される要素には、もう callbackfn が訪れることはありません。 存在する配列の要素が、変更される場合、 callbackfn を解析したものとしたそれらの値は、 some(メソッド)がそれらを訪れる時点での値となるでしょう。 some(メソッド)の開始呼び出しの後や訪問される前に削除される要素は、もう訪問されることはありません。 some(メソッド)は、数学上の量指定子“exists”のように動作します。 特にカラの配列については、それは、falseを返します。</p>
    <p>　 someメソッドが1つまたは2つの引数を伴って呼ばれる際には、次のステップが取られます。</p>
<pre><code>1. O は、引数として this 値を渡して ToObject を呼んだ結果とする
    2. lenValue は、引数&quot;length&quot;を伴う O の内部メソッド[[Get]]を呼んだ結果とする
    3. len は、 ToUint32(lenValue) とする
    4. IsCallable(callbackfn) が、 falseである場合、TypeError例外を投げる(スローする)
    5. thisArg が提供された場合、 T は、 thisArg とし、それ以外の場合、 T は、undefinedとする
    6. k は、 0 とする
    7. while k &lt; len という条件下で繰り返す
    a. Pk は、 ToString(k) とする
    b. kPresent は、引数 Pk を伴う O の内部メソッド[[HasProperty]]を呼んだ結果とする
    c. kPresent が、 trueである場合、
    i. kValue は、引数 Pk を伴う O の内部メソッド[[Get]]を呼んだ結果とする
    ii. testResult は、 this 値としての T と kValue、k、O を含む引数リストを伴う callbackfn の内部メソッド[[Call]]を呼んだ結果とする
    iii. ToBoolean(testResult) が、 true である場合、trueを返す
    d. kを1で増分する
    8. false を返す
</code></pre><p>　someメソッドの length プロパティは、1です。</p>
    <p>[注釈]</p>
    <p>　 some関数は、汎用的であることが意図され、その this 値がArrayオブジェクトとなることを要求しません。 その為、メソッドとしての使用においてオブジェクトの他の種類に転送することが可能です。 some関数が、ホストオブジェクトにうまく適用されることが可能か否かについては、実装依存です。</p>
    <h3 id="15-4-4-18-array-prototype-foreach-callbackfn-thisarg-">15.4.4.18 Array.prototype.forEach ( callbackfn [ , thisArg ] )</h3>
    <p>　 callbackfn は、3つの引数を許容する関数とすべきです。 forEach(メソッド) は、昇順で配列内にある要素ごとに1度 callbackfn を呼びます。 callbackfn は、実際に存在する配列の要素についてのみ呼ばれ、欠落した配列の要素については呼ばれません。</p>
    <p>　 thisArg パラメータが提供される場合、それは、 callbackfn として呼び出されるごとに this 値として使用されるでしょう。 それが提供されない場合には、代わりに undefined が使用されます。</p>
    <p>　 callbackfn は、要素の値、要素のインデックス、走査中のオブジェクトの3つの引数を伴って呼ばれます。</p>
    <p>　 forEach(メソッド) は、 callbackfn を呼ぶことによって、呼ばれつつもオブジェクトが変異する可能性がある場合、当該オブジェクトを直接変異させることはありません。</p>
    <p>　 forEach(メソッド)によって処理した要素の範囲は、 callbackfn を最初に呼ぶ前に設定されます。 forEach(メソッド)の開始をコールした後、配列に追加される要素には、もう callbackfn が訪れることはありません。 存在する配列の要素が、変更される場合、 コールバック(他の関数を呼び出し、実行する際に実行されるように引数として渡されるサブルーチン) を解析したものとしたそれらの値は、 forEach(メソッド)がそれらを訪れる時点での値となるでしょう。 forEach(メソッド)の開始呼び出しの後や訪問される前に削除される要素は、もう訪問されることはありません。</p>
    <p>　 forEachメソッドが1つまたは2つの引数を伴って呼ばれる際には、次のステップが取られます。</p>
<pre><code>1. O は、引数として this 値を渡して ToObject を呼んだ結果とする
    2. lenValue は、引数&quot;length&quot;を伴う O の内部メソッド[[Get]]を呼んだ結果とする
    3. len は、 ToUint32(lenValue) とする
    4. IsCallable(callbackfn) が、 falseである場合、TypeError例外を投げる(スローする)
    5. thisArg が提供された場合、 T は、 thisArg とし、それ以外の場合、 T は、undefinedとする
    6. k は、 0 とする
    7. while k &lt; len という条件下で繰り返す
    a. Pk は、 ToString(k) とする
    b. kPresent は、引数 Pk を伴う O の内部メソッド[[HasProperty]]を呼んだ結果とする
    c. kPresent が、 trueである場合、
    i. kValue は、引数 Pk を伴う O の内部メソッド[[Get]]を呼んだ結果とする
    ii.this 値としての T と kValue、k、O を含む引数リストを伴う callbackfn の内部メソッド[[Call]]を呼ぶ
    d. kを1で増分する
    8. undefined を返す
</code></pre><p>　forEachメソッドの length プロパティは、1です。</p>
    <p>[注釈]</p>
    <p>　 forEach関数は、汎用的であることが意図され、その this 値がArrayオブジェクトとなることを要求しません。 その為、メソッドとしての使用においてオブジェクトの他の種類に転送することが可能です。 forEach関数が、ホストオブジェクトにうまく適用されることが可能か否かについては、実装依存です。</p>
    <h3 id="15-4-4-19-array-prototype-map-callbackfn-thisarg-">15.4.4.19 Array.prototype.map ( callbackfn [ , thisArg ] )</h3>
    <p>　 callbackfn は、3つの引数を許容する関数とすべきです。 map(メソッド) は、昇順で配列内にある要素ごとに1度 callbackfn を呼び、結果から新たな Array を構成します。 callbackfn は、実際に存在する配列の要素についてのみ呼ばれ、欠落した配列の要素については呼ばれません。</p>
    <p>　 thisArg パラメータが提供される場合、それは、 callbackfn として呼び出されるごとに this 値として使用されるでしょう。 それが提供されない場合には、代わりに undefined が使用されます。</p>
    <p>　 callbackfn は、要素の値、要素のインデックス、走査中のオブジェクトの3つの引数を伴って呼ばれます。</p>
    <p>　 map(メソッド) は、 callbackfn を呼ぶことによって、呼ばれつつもオブジェクトが変異する可能性がある場合、当該オブジェクトを直接変異させることはありません。</p>
    <p>　 map(メソッド)によって処理した要素の範囲は、 callbackfn を最初に呼ぶ前に設定されます。 map(メソッド)の開始をコールした後、配列に追加される要素には、もう callbackfn が訪れることはありません。 存在する配列の要素が、変更される場合、 callbackfn を解析したものとしたそれらの値は、 map(メソッド)がそれらを訪れる時点での値となるでしょう。 map の開始呼び出しの後や訪問される前に削除される要素は、もう訪問されることはありません。</p>
    <p>　 mapメソッドが1つまたは2つの引数を伴って呼ばれる際には、次のステップが取られます。</p>
<pre><code>1. O は、引数として this 値を渡して ToObject を呼んだ結果とする
    2. lenValue は、引数&quot;length&quot;を伴う O の内部メソッド[[Get]]を呼んだ結果とする
    3. len は、 ToUint32(lenValue) とする
    4. IsCallable(callbackfn) が、 falseである場合、TypeError例外を投げる(スローする)
    5. thisArg が提供された場合、 T は、 thisArg とし、それ以外の場合、 T は、undefinedとする
    6. A は、Array が、その名と len の値である lenを持つ標準組み込みコンストラクタである場合、式 new Array(len) によるかのように生成した新たな配列とする
    7. k は、0とする
    8. while k &lt; len という条件下で繰り返す
    a. Pk は、 ToString(k) とする
    b. kPresent は、引数 Pk を伴う O の内部メソッド[[HasProperty]]を呼んだ結果とする
    c. kPresent が、 trueである場合、
    i. kValue は、引数 Pk を伴う O の内部メソッド[[Get]]を呼んだ結果とする
    ii. mappedValue は、this 値としての T と kValue、k、O を含む引数リストを伴う callbackfn の内部メソッド[[Call]]を呼んだ結果とする
    iii.引数 Pk 、プロパティ記述子 {[[Value]]: mappedValue, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}、 false を伴う A の内部メソッド[[DefineOwnProperty]]を呼ぶ
    d. kを1で増分する
    9. A を返す
</code></pre><p>　 mapメソッドの length プロパティは、1です。</p>
    <p>[注釈]</p>
    <p>　 map関数は、汎用的であることが意図され、その this 値がArrayオブジェクトとなることを要求しません。 その為、メソッドとしての使用においてオブジェクトの他の種類に転送することが可能です。 map関数が、ホストオブジェクトにうまく適用されることが可能か否かについては、実装依存です。</p>
    <h3 id="15-4-4-20-array-prototype-filter-callbackfn-thisarg-">15.4.4.20 Array.prototype.filter ( callbackfn [ , thisArg ] )</h3>
    <p>　 callbackfn は、3つの引数を許容する関数とすべきであり、Boolean値 true、または、false に強制変換する値を返します。 filter(メソッド) は、昇順で、配列内にある要素ごとに1度 callbackfn を呼び、 callbackfn が、 trueを返す場合の全ての値を含む新たな配列を構築します。 callbackfn は、実際に存在する配列の要素についてのみ呼ばれ、欠落した配列の要素については呼ばれません。</p>
    <p>　 thisArg パラメータが提供される場合、それは、 callbackfn として呼び出されるごとに this 値として使用されるでしょう。 それが提供されない場合には、代わりに undefined が使用されます。</p>
    <p>　 callbackfn は、要素の値、要素のインデックス、走査中のオブジェクトの3つの引数を伴って呼ばれます。</p>
    <p>　 filter(メソッド) は、 callbackfn を呼ぶことによって、呼ばれつつもオブジェクトが変異する可能性がある場合、当該オブジェクトを直接変異させることはありません。</p>
    <p>　 filter(メソッド)によって処理した要素の範囲は、 callbackfn を最初に呼ぶ前に設定されます。 filter(メソッド)の開始呼び出しの後、配列に追加される要素には、もう callbackfn が訪れることはありません。 配列の既存の要素が、 callbackfn に渡したのと同じ値に変更される場合、 filter(メソッド)がそれらを訪れる時点での値となるでしょう。 filter(メソッド)の開始呼び出しの後や訪問される前に削除される要素は、もう訪問されることはありません。</p>
    <p>　 filterメソッドが1つまたは2つの引数を伴って呼ばれる際には、次のステップが取られます。</p>
<pre><code>1. O は、引数として this 値を渡して ToObject を呼んだ結果とする
    2. lenValue は、引数&quot;length&quot;を伴う O の内部メソッド[[Get]]を呼んだ結果とする
    3. len は、 ToUint32(lenValue) とする
    4. IsCallable(callbackfn) が、 falseである場合、TypeError例外を投げる(スローする)
    5. thisArg が提供された場合、 T は、 thisArg とし、それ以外の場合、 T は、undefinedとする
    6. A は、その名を持つ標準組み込みコンストラクタである Array を式 new Array() によるかのように生成した新たな配列とする
    7. k は、0とする
    8. to は、0とする
    8. while k &lt; len という条件下で繰り返す
    a. Pk は、 ToString(k) とする
    b. kPresent は、引数 Pk を伴う O の内部メソッド[[HasProperty]]を呼んだ結果とする
    c. kPresent が、 trueである場合、
    i. kValue は、引数 Pk を伴う O の内部メソッド[[Get]]を呼んだ結果とする
    ii. selected は、this 値としての T と kValue、k、O を含む引数リストを伴う callbackfn の内部メソッド[[Call]]を呼んだ結果とする
    iii. ToBoolean(selected) が、 trueである場合、
    1.引数 ToString(to) 、プロパティ記述子 {[[Value]]: kValue, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}、falseを伴う A の内部メソッド[[DefineOwnProperty]]を呼ぶ
    2. to を1で増分する
    d. kを1で増分する
    10. A を返す
</code></pre><p>　 filterメソッドの length プロパティは、1です。</p>
    <p>[注釈]</p>
    <p>　 filter関数は、汎用的であることが意図され、その this 値がArrayオブジェクトとなることを要求しません。 その為、メソッドとしての使用においてオブジェクトの他の種類に転送することが可能です。 filter関数が、ホストオブジェクトにうまく適用されることが可能か否かについては、実装依存です。</p>
    <h3 id="15-4-4-21-array-prototype-reduce-callbackfn-initialvalue-">15.4.4.21 Array.prototype.reduce ( callbackfn [ , initialValue ] )</h3>
    <p>　 callbackfn は、4つの引数を取る関数とするべきです。 reduce(メソッド)は、昇順で配列内にある要素ごとに1度、関数としてcallbackを呼びます。</p>
    <p>　 callbackfn は、previousValue (または、callbackfnを呼ぶ前からある値)、 currentValue (現在の要素の値)、currentIndex 、走査中のオブジェクトの4つの引数を伴って呼ばれます。 callback が、最初に呼ばれる際には、 previousValue と currentValue は、2つの内1つの値とすることができます。 reduce(メソッド)を呼ぶ際に initialValue が提供された場合、 previousValue は、 initialValue と等しくなり、currentValue は、当該配列内の最初の値と等しくなります。 提供されたinitialValue が何もない場合、 previousValue は、当該配列内の最初の値と等しくなり、 currentValue は、2つめと等しくなります。 配列が何も含まない場合、且つ、 initialValue が提供されない場合、それは、TypeErrorです。</p>
    <p>　 reduce(メソッド)は、callbackfnを呼ぶことによって呼ばれつつもオブジェクトが変異する可能性がある場合、当該オブジェクトを直接変異させることはありません。</p>
    <p>　 reduce(メソッド)によって処理した要素の範囲は、最初に callbackfnを呼ぶ前に設定されます。 reduce(メソッド)の開始をコールした後に配列に追加される要素は、もう、callbackfnが訪れることはありません。 配列の既存の要素が変更される場合、 callbackfn に渡したのと同じそれらの値は、 reduce(メソッド)がそれらを訪れる時点での値となるでしょう。 reduce(メソッド)の開始呼び出しの後や訪れる前に削除される要素には、もう、訪れることはありません。</p>
    <p>　 reduce(メソッド)が、1つまたは、2つの引数を伴って呼ばれる際には、次のステップが取られます。</p>
<pre><code>1. O は、引数として this 値を渡して ToObject を呼んだ結果とする
    2. lenValue は、引数&quot;length&quot;を伴う O の内部メソッド[[Get]]を呼んだ結果とする
    3. len は、 ToUint32(lenValue) とする
    4. IsCallable(callbackfn) が、 falseである場合、TypeError例外を投げる(スローする)
    5. len が、 0 且つ、 initialValue が存在しない場合、TypeError例外を投げる(スローする)
    6. k は、0とする
    7. initialValue が存在する場合、
    a. accumulator に initialValue を設定する
    8. それ以外の場合、 initialValue は、存在せず、
    a. kPresent は、 false とする
    b. kPresent が、 false且つ、 k &lt; len である場合、繰り返す
    i. Pk は、 ToString(k) とする
    ii. kPresent は、引数  Pk を伴う O の内部メソッド[[HasProperty]]を呼んだ結果とする
    iii. kPresent が、 trueである場合、
    1. accumulator は、引数  Pk を伴う O の内部メソッド[[Get]]を呼んだ結果とする
    iv. k を1で増分する
    c. kPresent が、 falseである場合、TypeError例外を投げる(スローする)
    9. while k &lt; len という条件下で繰り返す
    a. Pk は、 ToString(k) とする
    b. kPresent は、引数  Pk を伴う O の内部メソッド[[HasProperty]]を呼んだ結果とする
    c. kPresent が、 trueである場合、
    i. kValue は、引数  Pk を伴う O の内部メソッド[[Get]]を呼んだ結果とする
    ii. accumulator は、this 値として undefined と accumulator、 kValue、k、O を含む引数リストを伴う callbackfn の内部メソッド[[Call]]を呼んだ結果とする
    d. k を1で増分する
    10. accumulator を返す
</code></pre><p>　 reduceメソッドの length プロパティは、1です。</p>
    <p>[注釈]</p>
    <p>　 reduce関数は、汎用的であることが意図され、その this 値がArrayオブジェクトとなることを要求しません。 その為、メソッドとしての使用においてオブジェクトの他の種類に転送することが可能です。 reduce関数が、ホストオブジェクトにうまく適用されることが可能か否かについては、実装依存です。</p>
    <h3 id="15-4-4-22-array-prototype-reduceright-callbackfn-initialvalue-">15.4.4.22 Array.prototype.reduceRight ( callbackfn [ , initialValue ] )</h3>
    <p>　 callbackfn は、4つの引数を取る関数とするべきです。 reduceRight(メソッド)は、降順で配列内にある要素ごとに1度、関数としてcallbackを呼びます。</p>
    <p>　 callbackfn は、previousValue (または、callbackfnを呼ぶ前からある値)、 currentValue (現在の要素の値)、currentIndex (現在の要素のインデックス)、走査中のオブジェクトの4つの引数を伴って呼ばれます。 その関数(callback)が、最初に呼ばれる際には、 previousValue と currentValue は、2つの内1つの値とすることができます。 reduceRight(メソッド)を呼ぶ際に initialValue が提供された場合、 previousValue は、 initialValue と等しくなり、currentValue は、当該配列内の最後の値と等しくなります。 提供されたinitialValue が何もない場合、 previousValue は、当該配列内の最後の値と等しくなり、 currentValue は、最後から2つめの値と等しくなります。 配列が何も含まない場合、且つ、 initialValue が提供されない場合、それは、TypeErrorです。</p>
    <p>　 reduceRight(メソッド)は、callbackfnを呼ぶことによって、呼ばれつつもオブジェクトが変異する可能性がある場合、当該オブジェクトを直接変異させることはありません。</p>
    <p>　 reduceRight(メソッド)によって処理した要素の範囲は、最初に callbackfnを呼ぶ前に設定されます。 reduceRight(メソッド)の開始をコールした後に配列に追加される要素は、もう、callbackfnが訪れることはありません。 配列の既存の要素が変更される場合、 callbackfn に渡したもの同じそれらの値は、 reduceRight(メソッド)がそれらを訪れる時点での値となるでしょう。 reduceRight(メソッド)の開始呼び出しの後や訪れる前に削除される要素には、もう、訪れることはありません。</p>
    <p>　 reduce(メソッド)が、1つまたは、2つの引数を伴って呼ばれる際には、次のステップが取られます。</p>
<pre><code>1. O は、引数として this 値を渡して ToObject を呼んだ結果とする
    2. lenValue は、引数&quot;length&quot;を伴う O の内部メソッド[[Get]]を呼んだ結果とする
    3. len は、 ToUint32(lenValue) とする
    4. IsCallable(callbackfn) が、 falseである場合、TypeError例外を投げる(スローする)
    5. len が、 0 且つ、 initialValue が存在しない場合、TypeError例外を投げる(スローする)
    6. k は、len-1とする
    7. initialValue が存在する場合、
    a. accumulator に initialValue を設定する
    8. それ以外の場合、 initialValue は、存在せず、
    a. kPresent は、 false とする
    b. kPresent が、 false且つ、  k ≧ 0 である場合、繰り返す
    i. Pk は、 ToString(k) とする
    ii. kPresent は、引数  Pk を伴う O の内部メソッド[[HasProperty]]を呼んだ結果とする
    iii. kPresent が、 trueである場合、
    1. accumulator は、引数  Pk を伴う O の内部メソッド[[Get]]を呼んだ結果とする
    iv. k を1で減分する
    c. kPresent が、 falseである場合、TypeError例外を投げる(スローする)
    9. while k ≧ 0 という条件下で繰り返す
    a. Pk は、 ToString(k) とする
    b. kPresent は、引数  Pk を伴う O の内部メソッド[[HasProperty]]を呼んだ結果とする
    c. kPresent が、 trueである場合、
    i. kValue は、引数  Pk を伴う O の内部メソッド[[Get]]を呼んだ結果とする
    ii. accumulator は、this 値として undefined と accumulator、 kValue、k、O を含む引数リストを伴う callbackfn の内部メソッド[[Call]]を呼んだ結果とする
    d. k を1で減分する
    10. accumulator を返す
</code></pre><p>　 reduceRightメソッドの length プロパティは、1です。</p>
    <p>[注釈]</p>
    <p>　 reduceRight関数は、汎用的であることが意図され、その this 値がArrayオブジェクトとなることを要求しません。 その為、メソッドとしての使用においてオブジェクトの他の種類に転送することが可能です。 reduceRight関数が、ホストオブジェクトにうまく適用されることが可能か否かについては、実装依存です。</p>
    <h2 id="15-4-5-array-properties-of-array-instances-standard-ecma-262-5-1-edition">15.4.5 Arrayインスタンスのプロパティ / Properties of Array Instances / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="15-ecmascript-">15 標準組み込みECMAScriptオブジェクト</h3>
    <h3 id="15-4-array-">15.4 Arrayオブジェクト</h3>
    <h3 id="15-4-5-array-">15.4.5 Arrayインスタンスのプロパティ</h3>
    <p>　Arrayインスタンスは、Arrayプロトタイプオブジェクトからプロパティを継承し、それらの内部プロパティ[[Class]]の値は、“Array”です。 Arrayインスタンスはまた、次のプロパティも持ちます。</p>
    <h3 id="15-4-5-1-defineownproperty-p-desc-throw-">15.4.5.1 [[DefineOwnProperty]] ( P, Desc, Throw )</h3>
    <p>　Arrayオブジェクトは、他のネイティブなECMAScriptのオブジェクト(8.12.9)の為に使用した内部メソッド[[DefineOwnProperty]]のバリエーションを使用します。 仮に A が、Arrayオブジェクトであると仮定した場合、Desc は、プロパティ記述子であり、 Throw は、Boolean値のフラグです。 次のアルゴリズム内では、用語“Reject”は、“Throwが、trueである場合、TypeError例外を投げ(スローし)、それ以外の場合、falseを返す”ということを意味します。</p>
    <p>　A の内部メソッド[[DefineOwnProperty]]が、プロパティ P、プロパティ記述子 Desc、Booleanフラグ Throwを伴って呼ばれる際には、次のステップが取られます。</p>
<pre><code>1. oldLenDesc は、引数として&quot;length&quot;を渡して A の内部メソッド[[GetOwnProperty]]を呼んだ結果とする
    その結果は、削除されたり、再構成されたりするデータプロパティ length を伴って生成されるArrayオブジェクトである為、決してundefinedまたは、アクセサ記述子になることはない
    2. oldLen は、 oldLenDesc.[[Value]] とする
    3. P が、 &quot;length&quot;である場合、
    a. Desc の[[Value]]項目が、ない場合、
    i.引数として&quot;length&quot;、Desc、Throw を渡して A 上で既定の内部メソッド[[DefineOwnProperty]](8.12.9)を呼んだ結果を返す
    b. newLenDesc は、 Desc のコピーとする
    c. newLen は、 ToUint32(Desc.[[Value]]) とする
    d. newLen が、 ToNumber( Desc.[[Value]]) と等しくない場合、RangeError例外を投げる(スローする)
    e. newLenDesc.[[Value] に newLen を設定する
    f.  newLen ≧ oldLen である場合、
    i.引数として&quot;length&quot;、newLenDesc、Throw を渡して A 上で既定の内部メソッド[[DefineOwnProperty]](8.12.9)を呼んだ結果を返す
    g. oldLenDesc.[[Writable]] が、 false である場合、Reject
    h. newLenDesc.[[Writable]] が、ないか、または、値 trueを持つ場合、 newWritable は、 trueとする
    i.それ以外の場合、
    i.一部の要素において[[Writable]]属性への false の設定を延期する必要がある場合、削除することはできない
    ii. newWritable は、falseとする
    iii. newLenDesc.[[Writable] に trueを設定する
    j. succeeded は、引数として&quot;length&quot;、newLenDesc、Throw を渡して A 上で既定の内部メソッド[[DefineOwnProperty]](8.12.9)を呼んだ結果とする
    k. succeeded が、 falseである場合、 falseを返す
    l. newLen &lt; oldLen である間、繰り返す
    i. oldLen は、oldLen - 1 とする
    ii. deleteSucceeded は、引数として ToString(oldLen) と false を渡して A の内部メソッド[[Delete]]を呼んだ結果とする
    iii. deleteSucceeded が、 falseである場合、
    1. newLenDesc.[[Value] に oldLen+1 を設定する
    2. newWritable が、 falseである場合、 newLenDesc.[[Writable] に false を設定する
    3.引数として&quot;length&quot;、newLenDesc、false を渡して A 上で既定の内部メソッド[[DefineOwnProperty]](8.12.9)を呼ぶ
    4.Reject
    m. newWritable が、 false である場合、
    i.引数として&quot;length&quot;、プロパティ記述子 {[[Writable]]: false}、false を渡して A 上で既定の内部メソッド[[DefineOwnProperty]](8.12.9)を呼ぶ、この呼び出しは、常にtrueを返す
    n. true を返す
    4. P iが、配列インデックス (15.4) である場合、
    a. index は、 ToUint32(P) とする
    b. index ≧ oldLen 且つ、 oldLenDesc.[[Writable]] が、 false である場合、Reject
    c. succeeded は、引数として P、Desc、falseを渡して A 上で既定の内部メソッド[[DefineOwnProperty]](8.12.9)を呼んだ結果とする
    d. succeeded が、 falseである場合、Reject
    e. index ≧ oldLen である場合、
    i. oldLenDesc.[[Value]] に index + 1 を設定する
    ii.引数として&quot;length&quot;、oldLenDesc、false を渡して A 上で既定の内部メソッド[[DefineOwnProperty]](8.12.9)を呼ぶ、この呼び出しは、常にtrueを返すでしょう
    f. trueを返す
    5.引数として P、Desc、Throwを渡して A 上で既定の内部メソッド[[DefineOwnProperty]](8.12.9)を呼んだ結果を返す
</code></pre><h3 id="15-4-5-2-length">15.4.5.2 length</h3>
    <p>　 this Arrayオブジェクトの length プロパティは、配列インデックスである名称を持つ毎回削除可能なプロパティの名称よりも数値的に常に大きい値であるデータプロパティです。 length プロパティは、最初、属性 { [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false } を持ちます。</p>
    <p>[注釈]</p>
    <p>　配列の非削除プロパティをインデックスした既存の配列の最大の数値プロパティ名より小さいか等しい数値である値を任意のArrayオブジェクトのlengthプロパティに設定しようとするとその最大の数字のプロパティ名より1大きい数値に設定されている長さになるでしょう。</p>
    <h2 id="15-5-string-string-objects-standard-ecma-262-5-1-edition">15.5 String オブジェクト / String Objects / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="15-ecmascript-">15 標準組み込みECMAScriptオブジェクト</h3>
    <h3 id="15-5-string-">15.5 String オブジェクト</h3>
    <h2 id="15-5-1-string-the-string-constructor-called-as-a-function-standard-ecma-262-5-1-edition">15.5.1 関数として呼ばれる String コンストラクタ / The String Constructor Called as a Function / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="15-ecmascript-">15 標準組み込みECMAScriptオブジェクト</h3>
    <h3 id="15-5-string-">15.5 String オブジェクト</h3>
    <h3 id="15-5-1-string-">15.5.1 関数として呼ばれる String コンストラクタ</h3>
    <p>　Stringが、コンストラクタではなく関数として呼ばれる際には、型変換が実行されます。</p>
    <h3 id="15-5-1-1-string-value-">15.5.1.1 String ( [ value ] )</h3>
    <p>　( String ( [ value ] ) は、) ToString(value) によって算出・生成した(Stringオブジェクトではなく)String値を返します。 value が提供されない場合、カラの文字列 “” が返されます。</p>
    <h2 id="15-5-2-string-the-string-constructor-standard-ecma-262-5-1-edition">15.5.2 String コンストラクタ / The String Constructor / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="15-ecmascript-">15 標準組み込みECMAScriptオブジェクト</h3>
    <h3 id="15-5-string-">15.5 String オブジェクト</h3>
    <h3 id="15-5-2-string-">15.5.2 String コンストラクタ</h3>
    <p>　Stringが、 new 式の一部として呼ばれる場合には、それはコンストラクタであり、新たに生成したオブジェクトを初期化します。</p>
    <h3 id="15-5-2-1-new-string-value-">15.5.2.1 new String ( [ value ] )</h3>
    <p>　新たに生成したオブジェクトの内部プロパティ[[Prototype]]は、 String.prototype (15.5.3.1) の初期値である標準組み込みStringプロトタイプオブジェクトに設定されます。</p>
    <p>　新たに生成したオブジェクトの内部プロパティ[[Class]]は、 “String”に設定されます。</p>
    <p>　新たに生成したオブジェクトの内部プロパティ[[Extensible]]は、 trueに設定されます。</p>
    <p>　新たに生成したオブジェクトの内部プロパティ[[Extensible]]は、 ToString(value) 、 value が提供されない場合、カラの文字列が設定されます。</p>
    <h2 id="15-5-3-string-properties-of-the-string-constructor-standard-ecma-262-5-1-edition">15.5.3 String コンストラクタのプロパティ / Properties of the String Constructor / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="15-ecmascript-">15 標準組み込みECMAScriptオブジェクト</h3>
    <h3 id="15-5-string-">15.5 String オブジェクト</h3>
    <h3 id="15-5-3-string-">15.5.3 String コンストラクタのプロパティ</h3>
    <p>　String コンストラクタの内部プロパティ[[Prototype]]の値は、標準組み込みFunctionプロトタイプオブジェクト(15.3.4)です。 更にその内部プロパティと(値が1である)lengthプロパティ、String コンストラクタは、次のプロパティも持ちます。</p>
    <h3 id="15-5-3-1-string-prototype">15.5.3.1 String.prototype</h3>
    <p>　 String.prototype の初期値は、標準組み込みStringプロトタイプオブジェクト(15.5.4)です。 このプロパティは、属性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false } を持ちます。</p>
    <h3 id="15-5-3-2-string-fromcharcode-char0-char1-">15.5.3.2 String.fromCharCode ( [ char0 [ , char1 [ , … ] ] ] )</h3>
    <p>　引数の数と同数の文字を含んでいるString値を返します。 各引数は、左から右に向かって最初の引数が1つめの文字を記述、次が…といった具合に結果となるStringの1文字を指定します。 引数は、操作 ToUint16 (9.7) を適用すると文字のコードユニット値として得られた16ビット整数とみなされる文字に変換されます。 引数が、提供されない場合、その結果は、カラの文字列です。</p>
    <p>　 fromCharCode関数の length プロパティの値は、1です。</p>
    <h2 id="15-5-4-string-properties-of-the-string-prototype-object-standard-ecma-262-5-1-edition">15.5.4 Stringプロトタイプオブジェクトのプロパティ / Properties of the String Prototype Object / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="15-ecmascript-">15 標準組み込みECMAScriptオブジェクト</h3>
    <h3 id="15-5-string-">15.5 String オブジェクト</h3>
    <h3 id="15-5-4-string-">15.5.4 Stringプロトタイプオブジェクトのプロパティ</h3>
    <p>　 Stringプロトタイプオブジェクトは、値がカラの文字列であるStringオブジェクト自身(その[[Class]] は“String”)です。 Stringプロトタイプオブジェクトの内部プロパティ[[Prototype]]の値は、標準組み込みObjectプロトタイプオブジェクト(15.2.4)です。</p>
    <h3 id="15-5-4-1-string-prototype-constructor">15.5.4.1 String.prototype.constructor</h3>
    <p>　 String.prototype.constructor の初期値は、組み込みStringコンストラクタです。</p>
    <h3 id="15-5-4-2-string-prototype-tostring-">15.5.4.2 String.prototype.toString ( )</h3>
    <p>　this String値を返します。(注釈としては、任意のStringオブジェクトにおいて toString メソッドは、 valueOf メソッドと同じものを返すというようなことが起こります。)</p>
    <p>　 toString関数は、汎用的ではありません。 つまり、この値が、文字列やStringオブジェクトではない場合、TypeError例外を投げます(スローします)。 その為、メソッドとしての使用においてオブジェクトの他の種類への転送はできません。</p>
    <h3 id="15-5-4-3-string-prototype-valueof-">15.5.4.3 String.prototype.valueOf ( )</h3>
    <p>　this String値を返します。</p>
    <p>　 valueOf関数は、汎用的ではありません。 つまり、この値が、文字列やStringオブジェクトではない場合、TypeError例外を投げます(スローします)。 その為、メソッドとしての使用においてオブジェクトの他の種類への転送はできません。</p>
    <h3 id="15-5-4-4-string-prototype-charat-pos-">15.5.4.4 String.prototype.charAt (pos)</h3>
    <p>　このオブジェクトをStringに変換して得られた文字列内の位置 pos にある文字を含む文字列を返します。 その位置に文字が何もない場合、その結果は、カラの文字列です。 その結果は、String値であってStringオブジェクトではありません。 pos が、整数であるNumber型の値である場合、 x.charAt(pos) の結果は、 x.substring(pos, pos+1) の結果と等しくなります。</p>
    <p>　 charAt メソッドが引数 pos を1つ伴って呼ばれる際には、次のステップがとられます。</p>
<pre><code>1.その引数として this 値を渡してCheckObjectCoercibleを呼ぶ
    2. S は、その引数として this 値を提供してToStringを呼んだ結果とする
    3. position は、 ToInteger(pos) とする
    4. size は、 S 内の文字の数とする
    5. position &lt; 0 または、 position ≧ size である場合、カラの文字列を返す
    6. 位置0、次が位置1...のように考えられる S にある(最も左の)最初の文字において S から、すなわち、位置 position にある文字である長さ 1 の文字列を返す
</code></pre><p>[注釈]</p>
    <p>　 charAt関数は、汎用的であることが意図され、その this 値が、Stringオブジェクトとなる事を要求しません。 その為、メソッドとしての使用においてオブジェクトの他の種類に転送することが可能です。</p>
    <h3 id="15-5-4-5-string-prototype-charcodeat-pos-">15.5.4.5 String.prototype.charCodeAt (pos)</h3>
    <p>　このオブジェクトをStringに変換することで得られる文字列内の位置 pos にある文字である表示中のコードユニット値を表している(2の16乗よりも小さい非負の整数である)Numberを返します。 その位置にそのような文字が何もない場合、その結果は、NaNです。</p>
    <p>　 charCodeAtメソッドは、引数 pos を1つ伴って呼ばれる際には、次のステップが取られます。</p>
<pre><code>1.その引数として this 値を渡してCheckObjectCoercibleを呼ぶ
    2. S は、その引数として this 値を提供してToStringを呼んだ結果とする
    3. position は、 ToInteger(pos) とする
    4. size は、S にある文字の数とする
    5. position &lt; 0 または、 position ≧ size である場合、 NaN を返す
    6.位置0、次が位置1のように考えられる S にある(最も左の)最初の文字において文字列 S 内の位置 position にある文字の値が文字のコードユニット値であるNumber型の値を返す
</code></pre><p>[注釈]</p>
    <p>　 charCodeAt関数は、汎用的であることが意図され、this値がStringオブジェクトとなることを要求しません。 その為、メソッドとしての使用においてはオブジェクトの他の種類に転送することが可能です。</p>
    <h3 id="15-5-4-6-string-prototype-concat-string1-string2-">15.5.4.6 String.prototype.concat ( [ string1 [ , string2 [ , … ] ] ] )</h3>
    <p>　 concatメソッドが、ゼロ個以上の string1, string2, …といった引数を伴って呼ばれる際には、(各引数が文字列に変換される場合に)string1, string2…のそれぞれの文字で続く(文字列に変換した)このオブジェクトの文字を構成するStringを返します。 その結果は、String値であって、Stringオブジェクトではありません。</p>
    <p>　(concatメソッドは、)次のステップが取られます。</p>
<pre><code>1.その引数として this 値を渡してCheckObjectCoercibleを呼ぶ
    2. S は、その引数として this 値を提供して ToString を呼んだ結果とする
    3. args は、この関数を渡して引数リストのコピーである内部リストとする
    4. R は、 S とする
    5. args がカラではない場合、繰り返す
    a. args から最初の要素を削除し、 next は、その要素の値とする
    b. ToString(next) の文字によって続く R の前の値にある文字で構成されるString値とする
    6. R を返す
</code></pre><p>　concatメソッドの length プロパティの値は、1です。</p>
    <p>[注釈]</p>
    <p>　 concat関数は、汎用的であることが意図され、その this 値をStringオブジェクトとすることを要求しません。 その為、メソッドとしての使用においてはオブジェクトの他の種類に転送することが可能です。</p>
    <h3 id="15-5-4-7-string-prototype-indexof-searchstring-position-">15.5.4.7 String.prototype.indexOf (searchString, position)</h3>
    <p>　 searchString が、 position より大きいか等しい1個所以上の位置にあるこのオブジェクトを文字列に変換した結果の部分文字列として現れる場合、このような位置の最も小さいインデックスが返され、それ以外の場合、-1が返されます。 position が、 undefinedである場合、0 と仮定され、よって文字列全てを検索することになります。</p>
    <p>　 indexOfメソッドは、 searchString と position という2つの引数を取り、次のステップを実行します。</p>
<pre><code>1.その引数として this 値を渡してCheckObjectCoercibleを呼ぶ
    2. S は、その引数として this 値を提供して ToString を呼んだ結果とする
    3. searchStr は、 ToString(searchString) とする
    4. pos は、 ToInteger(position) とする( position が、undefinedである場合、このステップは値0を生成)
    5. len は、 S 内の文字の数とする
    6. start は、 min(max(pos, 0), len) とする
    7. searchLen は、 searchStr 内にある文字の数とする
    8. len よりも大きくならない k + searchLen のような start よりも小さくならない可能な限り最も小さい整数 k を返し、 searchLen よりも小さい非負の整数 j 全てにおいて S の位置 k+j にある文字は、 searchStr の位置 j にある文字と同一だが、そのような整数 k がない場合には、値 -1 を返す
</code></pre><p>　 indexOfメソッドの length プロパティの値は、1です。</p>
    <p>[注釈]</p>
    <p>　 indexOf関数は、汎用的であることが意図され、その this 値をStringオブジェクトとすることを要求しません。 その為、メソッドとしての使用においてはオブジェクトの他の種類に転送することが可能です。</p>
    <h3 id="15-5-4-8-string-prototype-lastindexof-searchstring-position-">15.5.4.8 String.prototype.lastIndexOf (searchString, position)</h3>
    <p>　 searchString が、 position より小さいか、または等しい位置であり、1つ以上の位置にある文字列が、このオブジェクトに変換した結果の部分文字列として現れる場合、そのような位置における最大のインデックスが、返され、それ以外の場合、-1が返されます。 position が、 undefinedである場合、String値の length は、文字列の全てを検索するものとして想定されます。</p>
    <p>　 lastIndexOfメソッドは、 searchString と positionという2つの引数を取り、次のステップを実行します。</p>
<pre><code>1.その引数として this 値を渡してCheckObjectCoercibleを呼ぶ
    2. S は、その引数として this 値を提供してToStringを呼んだ結果とする
    3. searchStr は、 ToString(searchString) とする
    4. numPos は、 ToNumber(position) とする( position が、 undefinedである場合、値 NaNを生成)
    5. numPos が、 NaN である場合、 pos は、+∞ とし、それ以外の場合、 pos は、 ToInteger(numPos) とする
    6. len は、 S にある文字の数とする
    7. start は、 min(max(pos, 0), len) とする
    8. searchLen は、 searchStr にある文字の数とする
    9. len よりも大きくならない k + searchLen のような start よりも大きくならない可能な限り最も大きい整数 k を返し、 searchLen よりも小さい非負の整数 j 全てにおいて S の位置 k+j にある文字は、 searchStr の位置 j にある文字と同一だが、そのような整数 k がない場合には、値 -1 を返す
</code></pre><p>　 lastIndexOfメソッドの length プロパティの値は、1です。</p>
    <p>[注釈]</p>
    <p>　 lastIndexOf関数は、汎用的であることが意図され、その this 値をStringオブジェクトとすることを要求しません。 その為、メソッドとしての使用においてはオブジェクトの他の種類に転送することが可能です。</p>
    <h3 id="15-5-4-9-string-prototype-localecompare-that-">15.5.4.9 String.prototype.localeCompare (that)</h3>
    <p>　 localeCompareメソッドが、引数1つを伴って呼ばれる際には、(文字列に変換した) that を伴う(文字列に変換した)この値のロケール依存の文字列比較の結果を表す NaN ではない Numberを返します。 2つの文字列は、S と Thatとします。 2つの文字列は、実装定義の方法で比較されます。 その結果は、ソート順で That の前に来る S 、文字列が等しい、または、再帰的にソート順で That の後に来る S かどうかに依存する負、0、または正であり、システム既定のロケールによって指定したソート順でString値を指定することが意図されます。</p>
    <p>　その比較を実行する前に文字列を準備する為、次のステップが、実行されます。</p>
<pre><code>1.その引数として this 値を渡してCheckObjectCoercibleを呼ぶ
    2. S は、その引数として this 値を提供してToStringを呼んだ結果とする
    3. That は、 ToString(that) とする
</code></pre><p>　 localeCompareメソッドは、this と that の2つの引数から成る関数と考えられる場合、それは、全ての文字列の集合について( 15.4.4.11 で定義したように)一貫性のある比較関数です。 実際に返す値は、値中にあるエンコードのオプション情報の実装を許可する為に実装定義となっていますが、関数は、Unicode標準規格によって正規に等価であると考えられる文字列を比較する場合、全ての文字列についてまとめて命令を定義し、0を返します。 ホスト環境から利用可能である全てにおいて言語依存の比較がない場合、この関数は、ビット単位の比較を実行する場合があります。</p>
    <p>[注釈 1]</p>
    <p>　 localeCompareメソッドそれ自身は、後者が2つの引数から成る関数を要求する為、直接 Array.prototype.sort を引数とすることは適切ではありません。</p>
    <p>[注釈 2]</p>
    <p>　この関数は、ホスト環境からECMAScript環境を利用可能である比較機能であり、ホスト環境の現在のロケールの規則による比較といった何らかの言語依存によることが意図されます。 同一であるものとしてUnicode標準規格による正規に等価である文字列を扱う(、言い換えるとそれらが共に正規化書式 C や D に最初に変換されているかのように文字列を比較する、)この関数を強く推奨します。 それはまた、等価性や分解といったUnicode互換性を遵守しないこの関数であっても推奨されます。</p>
    <p>[注釈 3]</p>
    <p>　この関数の2つめのパラメータは、この標準規格の将来のバージョンで使用されるかもしれません。 つまり、実装は、いかなる場合においてもこのパラメータ位置を使用しないことが推奨されます。</p>
    <p>[注釈 4]</p>
    <p>　 localeCompare関数は、汎用的であることが意図され、その this 値をStringオブジェクトとすることを要求しません。 その為、メソッドとしての使用においてはオブジェクトの他の種類に転送することが可能です。</p>
    <h3 id="15-5-4-10-string-prototype-match-regexp-">15.5.4.10 String.prototype.match (regexp)</h3>
    <p>　 matchメソッドは、引数 regexp を伴って呼ばれる際には、次のステップが取られます。</p>
<pre><code>1.その引数として this 値を渡してCheckObjectCoercibleを呼ぶ
    2. S は、その引数として this 値を提供してToStringを呼んだ結果とする
    3. Type(regexp) が、 Objectであり且つ、 regexp の内部プロパティ[[Class]]の値が、&quot;RegExp&quot;である場合、 rx は、 regexp とする
    4.それ以外の場合、 rx は、 RegExp が、その名を持つ標準組み込みコンストラクタである場合、式 new RegExp(regexp) によるかのように生成した新たな RegExp オブジェクトとする
    5. global は、引数&quot;global&quot;を伴う rx の内部メソッド[[Get]]を呼んだ結果とする
    6. exec は、標準組み込み関数 RegExp.prototype.exec ( 15.10.6.2 参照)とする
    7. global が、 trueではない場合、
    a. this 値としての rx と S を含む引数リストを伴う exec の内部メソッド[[Call]]を呼んだ結果を返す
    8.それ以外の場合、 global は、 trueであり、
    a.引数&quot;lastIndex&quot; と 0を伴う rx の内部メソッド[[Put]]を呼ぶ
    b. A は、 Array が、その名を伴う標準組み込みコンストラクタである場合、式 new Array() によるかのように生成した新たな配列とする
    c. previousLastIndex は、 0 とする
    d. n は、 0 とする
    e. lastMatch は、 true とする
    f. lastMatch が、trueである間、繰り返す
    i. result は、 this 値としての rx と S を含む引数リストを伴う exec の内部メソッド[[Call]]を呼んだ結果とする
    ii. result が、 nullである場合、 lastMatch に falseを設定する
    iii.それ以外の場合、 result は、 null ではなく、
    1. thisIndex は、引数&quot;lastIndex&quot;を伴う rx の内部メソッド[[Get]]を呼んだ結果とする
    2. thisIndex = previousLastIndex である場合、
    a 引数&quot;lastIndex&quot;と thisIndex+1 を伴う rx の内部メソッド[[Put]]を呼ぶ
    b  previousLastIndex に thisIndex+1 を設定する
    3.それ以外の場合、 previousLastIndex に thisIndex を設定する
    4. matchStr は、引数&quot;0&quot;を伴う result の内部メソッド[[Get]]を呼んだ結果とする
    5.引数 ToString(n) 、プロパティ記述子 {[[Value]]: matchStr, [[Writable]]: true, [[Enumerable]]: true, [[configurable]]: true}、falseを伴う A の内部メソッド[[DefineOwnProperty]]を呼ぶ
    6. n を増分する
    g. n = 0 である場合、 nullを返す
    h. A を返す
</code></pre><p>[注釈]</p>
    <p>　 match関数は、汎用的であることが意図され、その this 値をStringオブジェクトとすることを要求しません。 その為、メソッドとしての使用においてはオブジェクトの他の種類に転送することが可能です。</p>
    <h3 id="15-5-4-11-string-prototype-replace-searchvalue-replacevalue-">15.5.4.11 String.prototype.replace (searchValue, replaceValue)</h3>
    <p>　まず、次のステップによって文字列を設定します。</p>
<pre><code>1.その引数として this 値を渡してCheckObjectCoercibleを呼ぶ
    2. string は、その引数として this 値を提供してToStringを呼んだ結果とする

    searchValue が、正規表現(オブジェクトの内部プロパティ[[Class]]が&quot;RegExp&quot;)である場合、次を実行する
    searchValue.global が、 falseである場合、正規表現 searchValue と最初にマッチする文字列を検索する
    searchValue.global が、 trueである場合、正規表現 searchValue とマッチする全ての文字列を検索する
    searchValue.lastIndex の更新を含め、 String.prototype.match 内と同じ方法で検索を実行する
    m は、( 15.10.2.1 で記述したように NcapturingParens を使用して) searchValue 内のキャプチャーした左カッコの数とする

    searchValue が、正規表現ではない場合、 searchString は、 ToString(searchValue) とし、 searchString の最初に出現する文字列を検索する
    m は、 0 とする

    replaceValue が、関数である場合、マッチした部分文字列ごとに次の引数 m + 3 を伴う関数を呼ぶ
    引数1は、マッチした部分文字列とする
    searchValue が、正規表現である場合、次の引数 m は、 MatchResult ( 15.10.2.1 参照)内でキャプチャーしたもの全てとする
    引数 m + 2 は、マッチが発生した場所の文字列内のオフセット、引数 m + 3 は、文字列とする
    その結果は、必要に応じて文字列に変換した対応する関数呼び出しの戻り値を伴うマッチした部分文字列ごとに置換することによってオリジナルの入力から派生したString値とする

    それ以外の場合、 newstring は、 replaceValue を文字列に変換した結果を示すものとする
    その結果は、Table 22で記述したように置換テキストによって newstring 内で文字を置換することによって newstring から派生した文字列を伴うマッチした部分文字列ごとに置換することによってオリジナルの入力文字列から派生したString値とする
    これらの $ 置換は、左から右へ実行され、1度だけそのような置換が実行され、新たな置換テキストは、もう置換されることはない
    例えば、 &quot;$1,$2&quot;.replace(/(\$(\d))/g, &quot;$$1-$1$2&quot;) は、 &quot;$1$11,$1-$22&quot; を返す
    newstring にある1つの $ は、左側にある下記フォームの何れともマッチしない

    Table 22 -- 置換テキスト記号の代入
    ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    文字      置換テキスト
    ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    $$      $
    $&amp;      マッチした部分文字列
    $`      マッチした部分文字列に先行する部分文字列
    $&#39;      マッチした部分文字列に後続する部分文字列
    $n      n番めのキャプチャ、n は、1から9までの範囲の1ケタで且つ、$n は、10進数字によって続くことはない
    n≦m 且つ、n番めのキャプチャが、undefinedである場合、代わりにカラの文字列を使用
    n&gt;mである場合、その結果は、実装定義
    $nn     nn番めのキャプチャ、nn は、01から99までの2ケタの10進数値。nn≦m 且つ、nn番めのキャプチャが、undefinedである場合、代わりにカラの文字列を使用
    nn&gt;mである場合、その結果は、実装定義
    ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    [注記]$&amp;,$`,$&#39;,$nはPerlと同様
</code></pre><p>[注釈]</p>
    <p>　 replace関数は、汎用的であることが意図され、その this 値をStringオブジェクトとすることを要求しません。 その為、メソッドとしての使用においてはオブジェクトの他の種類に転送することが可能です。</p>
    <h3 id="15-5-4-12-string-prototype-search-regexp-">15.5.4.12 String.prototype.search (regexp)</h3>
    <p>　 searchメソッドは、引数 regexp を伴って呼ばれる際には、次のステップが取られます。</p>
<pre><code>1.その引数として this 値を渡してCheckObjectCoercibleを呼ぶ
    2. string は、その引数として this 値を提供してToStringを呼んだ結果とする
    3. Type(regexp) が、 Objectであり、 regexp の内部プロパティ[[Class]]の値が、&quot;RegExp&quot;である場合、 rx は、 regexp とする
    4.それ以外の場合、rx は、その名を伴う標準組み込みコンストラクタである RegExp を式 new RegExp(regexp) によるかのように生成した新たな RegExp オブジェクトとする
    5.正規表現パターン rx の出現におけるその開始から値 string を検索する
    result は、マッチした文字列内のオフセットまたは、マッチしなかった場合 -1 を示す Number とする
    lastIndex と regexp のグローバルプロパティは、検索を実行する際に無視される
    regexp の lastIndex プロパティは、変更されない
    6. result を返す
</code></pre><p>[注釈]</p>
    <p>　 search関数は、汎用的であることが意図され、その this 値をStringオブジェクトとすることを要求しません。 その為、メソッドとしての使用においてはオブジェクトの他の種類に転送することが可能です。</p>
    <h3 id="15-5-4-13-string-prototype-slice-start-end-">15.5.4.13 String.prototype.slice (start, end)</h3>
    <p>　 sliceメソッドは、 start と end という2つの引数を取り、このオブジェクトをStringに変換した結果である部分文字列を返し、文字位置 start から開始し、含まれはしませんが、文字位置 end (、または、end が undefined(未定義)である場合、String の末尾)まで実行されます。 start が負数である場合、それは、文字列の長さが sourceLength である場合、 sourceLength + start として扱われます。 end が負数である場合、それは、文字列の長さが sourceLength である場合、 sourceLength + end として扱われます。 その結果は、String値であってStringオブジェクトではありません。</p>
    <p>　(sliceメソッドは、)次のステップが取られます。</p>
<pre><code>1.その引数として this 値を渡してCheckObjectCoercibleを呼ぶ
    2. S は、その引数として this 値を提供してToStringを呼んだ結果とする
    3. len は、Sにある文字の数とする
    4. intStart は、 ToInteger(start) とする
    5. end が、undefinedである場合、 intEnd は、 len とし、それ以外の場合、 intEnd は、ToInteger(end) とする
    6. intStart が負数である場合、 from は、 max(len + intStart,0) とし、それ以外の場合、 from は、 min(intStart, len) とする
    7. intEnd が負数である場合、 to は、 max(len + intEnd,0)とし、それ以外の場合、 to は、 min(intEnd, len) とする
    8. span は、 max(to - from,0) とする
    9.位置 from にある文字を伴って始まる S から連続した複数文字の範囲を含む文字列を返す
</code></pre><p>　 sliceメソッドの length プロパティは、2です。</p>
    <p>[注釈]</p>
    <p>　 slice関数は、汎用的であることが意図され、その this 値をStringオブジェクトとすることを要求しません。 その為、メソッドとしての使用においてはオブジェクトの他の種類に転送することが可能です。</p>
    <h3 id="15-5-4-14-string-prototype-split-separator-limit-">15.5.4.14 String.prototype.split (separator, limit)</h3>
    <p>　 this オブジェクトを文字列に変換した結果としての部分文字列が保持されている場合、Array オブジェクトを返します。 部分文字列は、separatorの出現において左から右に検索することによって決められます。 これらの出現は、返した配列内の部分文字列の一部ではありませんが、String値を分割する為に提供されます。 separatorの値は、任意の長さの文字列である場合やRegExpオブジェクトである場合があります。(例：あるオブジェクトの内部プロパティ[[Class]] が“RegExp” 、 15.10参照)</p>
    <p>　 separatorの値は、カラの文字列、カラの正規表現、カラの文字列にマッチする正規表現である場合もあります。 これらのケースにおいては、 separator は、入力文字列の開始位置や終了位置にあるカラの部分文字列にマッチするわけでも、マッチする separator の前の終了位置にあるカラの部分文字列にマッチするわけでもありません(。例えば、 separator がカラの文字列である場合、文字列は、個別の文字になるまで分割されます。その結果となる配列の大きさは、文字列の長さと等しく、各部分文字列は1つの文字を含みます)。 separator が、正規表現である場合、 後戻りすることによって、その位置でマッチするカラではない部分文字列を得ることが可能な場合でさえ、与えられた this String の位置でマッチするのは最初だけであると考えられます(。例えば、“ab”.split(/a*?/) は、配列 [“”,“b”] を評価してから配列 [“a”,“b”] を評価します)。</p>
    <p>　当該 this オブジェクトが、カラの文字列(、または、それを変換したもの)である場合、その結果は、カラの文字列とマッチすることが可能な separator か否かに依存します。 可能である場合、その結果となる配列は、要素を何も含みません。 それ以外の場合、その結果となる配列は、カラの文字列である1つの要素を含みます。</p>
    <p>　 separator が、キャプチャするカッコを含む正規表現である場合、 separator が、キャプチャしたカッコである(undefinedという結果を含む)その結果とマッチさせる時点ごとに出力する配列についてスプライスされます。 例えば、</p>
<pre><code>&quot;A&lt;B&gt;bold&lt;/B&gt;and&lt;CODE&gt;coded&lt;/CODE&gt;&quot;.split(/&lt;(\/)?([^&lt;&gt;]+)&gt;/)
</code></pre><p>は、配列</p>
<pre><code>[&quot;A&quot;, undefined, &quot;B&quot;, &quot;bold&quot;, &quot;/&quot;, &quot;B&quot;, &quot;and&quot;, undefined, &quot;CODE&quot;, &quot;coded&quot;, &quot;/&quot;, &quot;CODE&quot;, &quot;&quot;]
</code></pre><p>と評価します。</p>
    <p>　 separator が、 undefinedである場合、ちょうど1つの文字を含む結果となる配列は、(文字列に変換した) this 値です。 limit が、undefinedではない場合、その出力となる配列は、いかなる limit 要素も含まないものとして切り詰め(切り捨て)られます。</p>
    <p>　 splitメソッドが呼ばれる際には、次のステップが取られます。</p>
<pre><code>1.その引数として this 値を渡してCheckObjectCoercibleを呼ぶ
    2. S は、その引数として this 値を提供してToStringを呼んだ結果とする
    3. A は、その名を伴う標準組み込みコンストラクタである Array を式 new Array() によるかのように生成した新たな配列とする
    4. lengthA は、 0 とする
    5. limit が、 undefined である場合、 lim = 2の32乗-1 とし、それ以外の場合、 lim = ToUint32(limit) とする
    6. s は、S にある文字数とする
    7. p = 0 とする
    8. separator が、 RegExpオブジェクト(、その[[Class]]が、&quot;RegExp&quot;)である場合、 R = separator とし、それ以外の場合、 R = ToString(separator) とする
    9. lim = 0 である場合、 A を返す
    10. separator が、 undefined である場合
    a.引数&quot;0&quot;、プロパティ記述子 {[[Value]]: S, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}、false を伴う A の内部メソッド[[DefineOwnProperty]]を呼ぶ
    b. A を返す
    11. s = 0 である場合、
    a. SplitMatch(S, 0, R) を呼び、z は、その MatchResult 結果とする
    b. z が、 failure ではない場合、 A を返す
    c.引数&quot;0&quot;、プロパティ記述子 {[[Value]]: S, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}、 falseを伴う A の内部メソッド[[DefineOwnProperty]]を呼ぶ
    d. A を返す
    12. q = p とする
    13. while q ≠ s という条件下で繰り返す
    a. SplitMatch(S, q, R) を呼び、z は、その MatchResult 結果とする
    b. z が、 failure である場合、 q = q+1 とする
    c.それ以外の場合、 z が、 failure ではなく、
    i. z は、State としなければならない
    e は、 z の endIndex とし、 cap は、 z のキャプチャした配列とする
    ii. e = p である場合、  q = q+1 とする
    iii.それ以外の場合、  e ≠ p であり、
    1. T は、 p (を包む p )から q (を含まない q )までの位置にある文字を含む S の部分文字列と等しいString値とする
    2.引数 ToString(lengthA) 、プロパティ記述子 {[[Value]]: T, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}、 false を伴う A の内部メソッド[[DefineOwnProperty]]を呼ぶ
    3. lengthA を 1で増分する
    4. lengthA = lim である場合、 A を返す
    5. p = e とする
    6. i = 0 とする
    7. i が、cap にある要素数と等しくない間、繰り返す
    a  i = i+1 とする
    b 引数 ToString(lengthA) 、プロパティ記述子 {[[Value]]: cap[i], [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}、false を伴う A の内部メソッド[[DefineOwnProperty]]を呼ぶ
    c lengthA を 1 で増分する
    d lengthA = lim である場合、 A を返す
    8. q = p とする
    14. T は、 p (を包む p )から s (を含まない s )までの位置にある文字を含む S の部分文字列と等しいString値とする
    15.引数 ToString(lengthA) 、プロパティ記述子 {[[Value]]: T, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}、 false を伴う A の内部メソッド[[DefineOwnProperty]]を呼ぶ
    16. A を返す
</code></pre><p>　抽象操作SplitMatchは、文字列 S 、整数 q 、Stringまたは、RegExpであるRといった3つのパラメータを取り、 MatchResult ( 15.10.2.1 参照)を返す為に次を実行します。</p>
<pre><code>1. R が、 RegExp オブジェクト(、その[[Class]]が、&quot;RegExp&quot;)である場合、
    a.引数 S と q を与えられる R の内部メソッド[[Match]]を呼び、MatchResult 結果を返す
    2. Type(R) は、String にしなければならない
    r は、R 内の文字数とする
    3. s は、S 内の文字数とする
    4. q+r &gt; s である場合、MatchResult failureを返す
    5. R の位置 i にある文字とは異なる S の位置 q+1 にある文字のように 0 (を含む 0 ) と r (を含まない r ) との間に整数 i が存在する場合、failureを返す
    6. cap は、キャプチャしたカラの配列 ( 15.10.2.1 参照)とする
    7. State (q+r, cap) を返す( 15.10.2.1 参照)
</code></pre><p>　 splitメソッドの length プロパティは、2です。</p>
    <p>[注釈 1]</p>
    <p>　 splitメソッドは、 RegExp オブジェクトであるセパレータにおける separator.globalの値を無視します。</p>
    <p>[注釈 2]</p>
    <p>　 split関数は、汎用的であることが意図され、その this 値をStringオブジェクトとすることを要求しません。 その為、メソッドとしての使用においてはオブジェクトの他の種類に転送することが可能です。</p>
    <h3 id="15-5-4-15-string-prototype-substring-start-end-">15.5.4.15 String.prototype.substring (start, end)</h3>
    <p>　 substringメソッドは、start と endという2つの引数を取り、当該文字列の位置 start で始まり、含まれはしませんが、位置 end の文字(、または、 end が、undefinedである場合、文字列の末尾)まで実行して this オブジェクトを文字列に変換した結果としての部分文字列を返します。 その結果は、String値であってStringオブジェクトではありません。 引数が、NaNまたは負数の何れかである場合、ゼロを伴って置換され、何らかの引数が文字列の長さより大きい場合、その文字列の長さで置換されます。 start が、 end よりも大きい場合、それらは入れ替えられ(スワップされ)ます。</p>
    <p>　(substringメソッドは、)次のステップが取られます。</p>
<pre><code>1.その引数として this 値を渡してCheckObjectCoercibleを呼ぶ
    2. S は、その引数として this 値を提供してToStringを呼んだ結果とする
    3. len は、 S 内の文字数とする
    4. intStart は、 ToInteger(start) とする
    5. end が、 undefined である場合、 intEnd は、 len とし、それ以外の場合、 intEnd は、 ToInteger(end) とする
    6. finalStart は、 min(max(intStart, 0), len) とする
    7. finalEnd は、 min(max(intEnd, 0), len) とする
    8. from は、 min(finalStart, finalEnd) とする
    9. to は、 max(finalStart, finalEnd) とする
    10.含んでいる S から成る文字、すなわち、昇順で -1 までのインデックスを持つ文字から成る複数文字から - となる length を持つ任意の文字列を返す
</code></pre><p>　substringメソッドの length プロパティは、2です。</p>
    <p>[注釈]</p>
    <p>　 substring関数は、汎用的であることが意図され、その this 値をStringオブジェクトとすることを要求しません。 その為、メソッドとしての使用においてはオブジェクトの他の種類に転送することが可能です。</p>
    <h3 id="15-5-4-16-string-prototype-tolowercase-">15.5.4.16 String.prototype.toLowerCase ( )</h3>
    <p>　(toLowerCaseは、)次のステップが取られます。</p>
<pre><code>1.その引数として this 値を渡してCheckObjectCoercibleを呼ぶ
    2. S は、その引数として this 値を提供してToStringを呼んだ結果とする
    3. L は、S から成る文字と一致するものと等しいUnicode小文字、または、Unicode小文字と等価のものがない場合、 S から成る実際に一致する文字の何れかである L の各文字である文字列とする
    4. L を返す
</code></pre><p>　この操作の目的において当該文字列の16ビットコードユニットは、UnicodeのBasic Multilingual Plane(略称：BMP、基本多言語水準／基本多言語レベル)内のコードポイントとして扱われます。 サロゲートコードポイントは、なんらマッピングすることなく S から L に直接転送されます。</p>
    <p>　その結果は、Unicode文字データベース内でケースマッピングによって派生されなければいけません(。これは、 UnicodeData.txt ファイルばかりでなく、 Unicode 2.1.8 とそれ以降でそれに付随する SpecialCasings.txt ファイルを明示的に含みます)。</p>
    <p>[注釈 1]</p>
    <p>　一部の文字のケースマッピングにおいては、複数文字を生成する場合があります。 このケースにおいて、その結果となる文字列は、ソース文字列と同じ長さにならない場合もあります。 なぜなら、 toUpperCase と toLowerCase の双方は、内容依存(context-sensitive)の動作を持ち、当該関数は、対称的ではない(つり合わない)からです。 言い換えると s.toUpperCase().toLowerCase() は、 s.toLowerCase() と等しくなる必要はありません。</p>
    <p>[注釈 2]</p>
    <p>　 toLowerCase関数は、汎用的であることが意図され、その this 値をStringオブジェクトとすることを要求しません。 その為、メソッドとしての使用においてはオブジェクトの他の種類に転送することが可能です。</p>
    <h3 id="15-5-4-17-string-prototype-tolocalelowercase-">15.5.4.17 String.prototype.toLocaleLowerCase ( )</h3>
    <p>　この関数は、その結果が、ロケール独自の結果ではなく、ホスト環境の現在のロケールにおいて正しい結果を得ることが意図されるという点を除き、toLowerCaseと全く同じように作用します。</p>
    <p>正規のUnicodeのケースマッピングを伴う言語的な齟齬におけるルールについては、(トルコ語のような)いくつかの状況でのみ異なる場合があるでしょう。</p>
    <p>[注釈 1]</p>
    <p>　当該関数への1つめのパラメータは、この標準の将来のバージョンで使用されるかもしれません。 それは、つまり、実装は、いかなる場合においてもこのパラメータ位置を使用しないことが推奨されるということです。</p>
    <p>[注釈 2]</p>
    <p>　 toLocaleLowerCase関数は、汎用的であることが意図され、その this 値をStringオブジェクトとすることを要求しません。 その為、メソッドとしての使用においてはオブジェクトの他の種類に転送することが可能です。</p>
    <h3 id="15-5-4-18-string-prototype-touppercase-">15.5.4.18 String.prototype.toUpperCase ( )</h3>
    <p>　この関数は、Unicode文字データベース内で記述したようにそれらの大文字と等価であるものとマップされるという点をを除き、 String.prototype.toLowerCaseと全く同じように動作します。</p>
    <p>[注釈]</p>
    <p>　 toUpperCase関数は、汎用的であることが意図され、その this 値をStringオブジェクトとすることを要求しません。 その為、メソッドとしての使用においてはオブジェクトの他の種類に転送することが可能です。</p>
    <h3 id="15-5-4-19-string-prototype-tolocaleuppercase-">15.5.4.19 String.prototype.toLocaleUpperCase ( )</h3>
    <p>　この関数は、その結果が、ロケール依存による結果ではなく、ホスト環境の現在のロケールにおける正しい結果を得ることを意図されるという点を除き、 toUpperCase と全く同じように作用します。 正規のUnicodeケースマッピングを伴う言語的な齟齬における規則については、(トルコ語)のようないくつかのケースでのみ異なるものになるでしょう。</p>
    <p>[注釈 1]</p>
    <p>　当該関数の1つめのパラメータは、この標準規格の将来のバージョンで使用されるかもしれません。 それは、つまり、実装は、いかなる場合においてもこのパラメータ位置を使用しないことが推奨されるという事です。</p>
    <p>[注釈 2]</p>
    <p>　 toLocaleUpperCase関数は、汎用的であることが意図され、その this 値をStringオブジェクトとすることを要求しません。 その為、メソッドとしての使用においてはオブジェクトの他の種類に転送することが可能です。</p>
    <h3 id="15-5-4-20-string-prototype-trim-">15.5.4.20 String.prototype.trim ( )</h3>
    <p>　(trimは、)次のステップが取られます。</p>
<pre><code>1.その引数として this 値を渡してCheckObjectCoercibleを呼ぶ
    2. S は、その引数として this 値を提供してToStringを呼んだ結果とする
    3. T は、先行と後続するホワイトスペースを共に削除した S のコピーであるString値とする
    ホワイトスペースの定義は、WhiteSpace(空白) と LineTerminator(行終端)の和集合である。
    4. T を返す
</code></pre><p>[注釈]</p>
    <p>　 trim関数は、汎用的であることが意図され、その this 値をStringオブジェクトとすることを要求しません。 その為、メソッドとしての使用においてはオブジェクトの他の種類に転送することが可能です。</p>
    <h2 id="15-5-5-string-properties-of-string-instances-standard-ecma-262-5-1-edition">15.5.5 String インスタンスのプロパティ / Properties of String Instances / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="15-ecmascript-">15 標準組み込みECMAScriptオブジェクト</h3>
    <h3 id="15-5-string-">15.5 String オブジェクト</h3>
    <h3 id="15-5-5-string-">15.5.5 String インスタンスのプロパティ</h3>
    <p>　 Stringインスタンスは、Stringプロトタイプオブジェクトとそれらの内部メソッドで値が“String”である[[Class]]からプロパティを継承します。 Stringインスタンスはまた、内部プロパティ[[PrimitiveValue]]、 length プロパティ、配列インデックス名を伴う列挙プロパティの集合も持ちます。</p>
    <p>　内部プロパティ[[PrimitiveValue]]は、 this Stringオブジェクトによって表されるString値です。 配列インデックス名付きプロパティは、String値の当該個別の文字と一致します。 特殊な内部メソッド[[GetOwnProperty]]は、数、値、配列インデックス名付きプロパティの属性を指定する為に利用されます。</p>
    <h3 id="15-5-5-1-length">15.5.5.1 length</h3>
    <p>　this Stringオブジェクトによって表したString値内の文字数。</p>
    <p>　一度、Stringオブジェクトが生成されると、このプロパティは、変更されることはありません。 それは、属性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false } を持ちます。</p>
    <h3 id="15-5-5-2-getownproperty-p-">15.5.5.2 [[GetOwnProperty]] ( P )</h3>
    <p>　 Stringオブジェクトは、他のネイティブなECMAScriptオブジェクト( 8.12.1 )において使用した内部メソッド[[GetOwnProperty]]のバリエーションを使用します。 この特別な内部メソッドは、Stringオブジェクトの個別の文字と一致する名前付きプロパティへのアクセスを提供します。</p>
    <p>　 S は、Stringオブジェクトであり、P は文字列であると仮定します。 S の内部メソッド[[GetOwnProperty]]は、プロパティ名 P を伴って呼ばれる際には、次のステップが取られます。</p>
<pre><code>1. desc は、引数 P を伴う S において既定の内部メソッド[[GetOwnProperty]] ( 8.12.1 )を呼んだ結果とする
    2. desc が、 undefined ではない場合、 desc を返す
    3. ToString(abs(ToInteger(P))) が、 P と同じ値ではない場合、undefined を返す
    4. str は、 S の内部プロパティ[[PrimitiveValue]]のString値とする
    5. index は、 ToInteger(P) とする
    6. len は、 str 内の文字数とする
    7. len ≦ index である場合、 undefined を返す
    8. resultStr は、位置0、位置1...のようになると考えられる str 内の最初の(最も左の)文字における位置インデックスにある特殊な文字 str から1文字を含む長さ 1 の文字列とする
    9.プロパティ記述子 { [[Value]]: resultStr, [[Enumerable]]: true, [[Writable]]: false, [[Configurable]]: false } を返す
</code></pre><h2 id="15-6-boolean-boolean-objects-standard-ecma-262-5-1-edition">15.6 Booleanオブジェクト / Boolean Objects / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="15-ecmascript-">15 標準組み込みECMAScriptオブジェクト</h3>
    <h3 id="15-6-boolean-">15.6 Booleanオブジェクト</h3>
    <h3 id="15-6-1-boolean-">15.6.1 関数として呼ぶBooleanコンストラクタ</h3>
    <p>　 Booleanが、コンストラクタではなく、関数として呼ばれる際には、型変換を実行します。</p>
    <h3 id="15-6-1-1-boolean-value-">15.6.1.1 Boolean (value)</h3>
    <p>　 ToBoolean(value) によって算出したBoolean値を返します。</p>
    <h3 id="15-6-2-boolean-">15.6.2 Boolean コンストラクタ</h3>
    <p>　 Booleanが、new 式の一部として呼ばれる場合、それはコンストラクタであり、新たに生成したオブジェクトを初期化します。</p>
    <h3 id="15-6-2-1-new-boolean-value-">15.6.2.1 new Boolean (value)</h3>
    <p>　新たに構成したオブジェクトの内部プロパティ[[Prototype]]は、 Boolean.prototype (15.6.3.1)の初期値であるオリジナルのBooleanプロトタイプオブジェクトに設定されます。</p>
    <p>　新たに構成したBoolean型オブジェクトの内部プロパティ[[Class]]は、“Boolean”に設定されます。</p>
    <p>　新たに構成したBoolean型オブジェクトの内部プロパティ[[PrimitiveValue]]は、 ToBoolean(value) に設定されます。</p>
    <p>　新たに構成したBoolean型オブジェクトの内部プロパティ[[Extensible]]は、 trueに設定されます。</p>
    <h3 id="15-6-3-boolean-">15.6.3 Boolean コンストラクタのプロパティ</h3>
    <p>　 Booleanコンストラクタの内部プロパティ[[Prototype]]の値は、Functionプロトタイプオブジェクト(15.3.4)です。 更に内部プロパティと(値が1である)lengthプロパティ、Booleanコンストラクタは、次のプロパティも持ちます。</p>
    <h3 id="15-6-3-1-boolean-prototype">15.6.3.1 Boolean.prototype</h3>
    <p>　 Boolean.prototype の初期値は、Booleanプロトタイプオブジェクト(15.6.4)です。 このプロパティは、属性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false } を持ちます。</p>
    <h3 id="15-6-4-boolean-">15.6.4 Booleanプロトタイプオブジェクトのプロパティ</h3>
    <p>　 Booleanプロトタイプオブジェクトは、値がfalseであるそれ自身の(その[[Class]]が“Boolean”である)Booleanオブジェクトです。 Booleanプロトタイプオブジェクトの内部プロパティ[[Prototype]]の値は、標準組み込みObjectプロトタイプオブジェクト(15.2.4)です。</p>
    <h3 id="15-6-4-1-boolean-prototype-constructor">15.6.4.1 Boolean.prototype.constructor</h3>
    <p>　 Boolean.prototype.constructor の初期値は、組み込みBooleanコンストラクタです。</p>
    <h3 id="15-6-4-2-boolean-prototype-tostring-">15.6.4.2 Boolean.prototype.toString ( )</h3>
    <p>　(toStringは、)次のステップが取られます。</p>
<pre><code>1. B は、 this 値とする
    2. Type(B) が、 Boolean である場合、 b は、 B とする
    3. Type(B) が、 Object 且つ、B の内部プロパティ[[Class]]の値が&quot;Boolean&quot;である場合、b は、B の内部プロパティ[[PrimitiveValue]]の値とする
    4.それ以外の場合、TypeError例外を投げる(スローする)
    5. b が、 true である場合、&quot;true&quot;を返し、それ以外の場合、&quot;false&quot;を返す
</code></pre><h3 id="15-6-4-3-boolean-prototype-valueof-">15.6.4.3 Boolean.prototype.valueOf ( )</h3>
    <p>　(valueOfは、)次のステップが取られます。</p>
<pre><code>1. B は、 this 値とする
    2. Type(B) が、 Boolean である場合、 b は、 B とする
    3. Type(B) が、 Object 且つ、B の内部プロパティ[[Class]]の値が&quot;Boolean&quot;である場合、b は、B の内部プロパティ[[PrimitiveValue]]の値とする
    4.それ以外の場合、TypeError例外を投げる(スローする)
    5. b を返す
</code></pre><h3 id="15-6-5-boolean-">15.6.5 Boolean インスタンスのプロパティ</h3>
    <p>　 Booleanインスタンスは、Booleanプロトタイプオブジェクトと値が、“Boolean”であるそれらの内部プロパティ[[Class]]からプロパティを継承します。 Booleanインスタンスは、内部プロパティ[[PrimitiveValue]]も持ちます。 内部プロパティ[[PrimitiveValue]]は、このBooleanオブジェクトによって表したBoolean値です。</p>
    <h2 id="15-7-number-number-objects-standard-ecma-262-5-1-edition">15.7 Number オブジェクト / Number Objects / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="15-ecmascript-">15 標準組み込みECMAScriptオブジェクト</h3>
    <h3 id="15-7-number-">15.7 Number オブジェクト</h3>
    <h2 id="15-7-1-number-the-number-constructor-called-as-a-function-standard-ecma-262-5-1-edition">15.7.1 関数として呼ぶ Number コンストラクタ / The Number Constructor Called as a Function / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="15-ecmascript-">15 標準組み込みECMAScriptオブジェクト</h3>
    <h3 id="15-7-number-">15.7 Number オブジェクト</h3>
    <h3 id="15-7-1-number-">15.7.1 関数として呼ぶ Number コンストラクタ</h3>
    <p>　 Numberが、コンストラクタとしてではなく、関数として呼ばれる際には、型変換を実行します。</p>
    <h3 id="15-7-1-1-number-value-">15.7.1.1 Number ( [ value ] )</h3>
    <p>　 value が提供された場合、 ToNumber(value) によって算出した(Numberオブジェクトではなく)Number値を返し、それ以外の場合には、+0を返します。</p>
    <h2 id="15-7-2-number-the-number-constructor-standard-ecma-262-5-1-edition">15.7.2 Number コンストラクタ / The Number Constructor / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="15-ecmascript-">15 標準組み込みECMAScriptオブジェクト</h3>
    <h3 id="15-7-number-">15.7 Number オブジェクト</h3>
    <h3 id="15-7-2-number-">15.7.2 Number コンストラクタ</h3>
    <p>　Numberが、 new 式の一部として呼ばれる場合には、それは、コンストラクタであり、新たに生成したオブジェクトを初期化します。</p>
    <h3 id="15-7-2-1-new-number-value-">15.7.2.1 new Number ( [ value ] )</h3>
    <p>　新たに構成したオブジェクトの内部プロパティ[[Prototype]]は、 Number.prototype (15.7.3.1)の初期値であるオリジナルのNumberプロトタイプオブジェクトに設定されます。</p>
    <p>　新たに構成したオブジェクトの内部プロパティ[[Class]]は、“Number”に設定されます。</p>
    <p>　新たに構成したオブジェクトの内部プロパティ[[PrimitiveValue]]は、 value が提供された場合、 ToNumber(value) に、それ以外の場合、+0に設定されます。</p>
    <p>　新たに構成したオブジェクトの内部プロパティ[[Extensible]]は、 trueに設定されます。</p>
    <h2 id="15-7-3-number-properties-of-the-number-constructor-standard-ecma-262-5-1-edition">15.7.3 Number コンストラクタのプロパティ / Properties of the Number Constructor / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="15-ecmascript-">15 標準組み込みECMAScriptオブジェクト</h3>
    <h3 id="15-7-number-">15.7 Number オブジェクト</h3>
    <h3 id="15-7-3-number-">15.7.3 Number コンストラクタのプロパティ</h3>
    <p>　 Numberコンストラクタの内部プロパティ[[Prototype]]の値は、Functionプロトタイプオブジェクト(15.3.4)です。 更に内部プロパティと(値が1である)lengthプロパティ、Numberコンストラクタは次のプロパティも持ちます。</p>
    <h3 id="15-7-3-1-number-prototype">15.7.3.1 Number.prototype</h3>
    <p>　 Number.prototype の初期値は、Numberプロトタイプオブジェクト(15.7.4)です。 このプロパティは、属性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false } を持ちます。</p>
    <h3 id="15-7-3-2-number-max-_value">15.7.3.2 Number.MAX_VALUE</h3>
    <p>　 Number.MAX_VALUE の値は、約 1.7976931348623157 x 10の308乗であるNumber型の最大の正の有限値です。 このプロパティは、属性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false } を持ちます。</p>
    <h3 id="15-7-3-3-number-min-_value">15.7.3.3 Number.MIN_VALUE</h3>
    <p>　 Number.MIN_VALUE の値は、約 5 x 10の-324乗であるNumber型の最小の正の値です。 このプロパティは、属性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false } を持ちます。</p>
    <h3 id="15-7-3-4-number-nan">15.7.3.4 Number.NaN</h3>
    <p>　 Number.NaN の値は、 NaNです。 このプロパティは、属性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false } を持ちます。</p>
    <h3 id="15-7-3-5-number-negative-_infinity">15.7.3.5 Number.NEGATIVE_INFINITY</h3>
    <p>　 Number.NEGATIVE_INFINITY の値は、-∞です。 このプロパティは、属性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false } を持ちます。</p>
    <h3 id="15-7-3-6-number-positive-_infinity">15.7.3.6 Number.POSITIVE_INFINITY</h3>
    <p>　 Number.POSITIVE_INFINITY の値は、+∞です。 このプロパティは、属性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false } を持ちます。</p>
    <h2 id="15-7-4-number-properties-of-the-number-prototype-object-standard-ecma-262-5-1-edition">15.7.4 Numberプロトタイプオブジェクトのプロパティ / Properties of the Number Prototype Object / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="15-ecmascript-">15 標準組み込みECMAScriptオブジェクト</h3>
    <h3 id="15-7-number-">15.7 Number オブジェクト</h3>
    <h3 id="15-7-4-number-">15.7.4 Numberプロトタイプオブジェクトのプロパティ</h3>
    <p>　 Numberプロトタイプオブジェクトは、値が +0 (、その[[Class]]が、“Number”)であるそれ自身のNumberオブジェクトです。</p>
    <p>　 Numberプロトタイプオブジェクトの内部プロパティ[[Prototype]]の値は、標準組み込みObjectプロトタイプオブジェクト(15.2.4)です。</p>
    <p>　それ以外のはっきりした状態にない場合、以下で定義したNumberプロトタイプオブジェクトのメソッドは、一般的ではなく、それらに渡した this 値は、内部プロパティ[[Class]]の値が、“Number”である場合には、Number値、または、Objectの何れかにしなければいけません。</p>
    <p>　関数の次の概要については、Numberプロトタイプオブジェクトのプロパティであり、そのフレーズ“this Numberオブジェクト”は、関数の呼び出しにおける this値であるオブジェクト、または、 Type(this値) が、 Numberである場合、Numberが、その名を持つ標準組み込みコンストラクタである場合、式 new Number(this値) によるかのように生成されたオブジェクトの何れかを参照します。 また、そのフレーズ“this Number値”は、 this Numberオブジェクトによって提示したNumber値の何れかを参照し、それは、つまり、 this Numberオブジェクトの内部プロパティ[[PrimitiveValue]]の値、または、その型が、Number である場合、this 値です。 TypeError例外は、 this 値が、内部プロパティ[[Class]]の値が“Number”である場合のオブジェクト、または、型がNumberである値の何れでもない場合に投げられ(スローされ)ます。</p>
    <h3 id="15-7-4-1-number-prototype-constructor">15.7.4.1 Number.prototype.constructor</h3>
    <p>　 Number.prototype.constructor の初期値は、組み込みNumberコンストラクタです。</p>
    <h3 id="15-7-4-2-number-prototype-tostring-radix-">15.7.4.2 Number.prototype.toString ( [ radix ] )</h3>
    <p>　オプションである radix は、2から36までの範囲内の整数値とすべきです。 radix が、与えられない場合やundefined(未定義)である場合、数字10が、 radix の値として使用されます。 ToInteger(radix) が、数字10である場合、this Number値は、抽象操作ToStringへの引数として与えられ、その結果となるString値が返されます。</p>
    <p>　 ToInteger(radix) が、2と36の範囲内の整数ではない場合、RangeError例外を投げ(スローし)ます。 ToInteger(radix) が、2と36の範囲内の整数でありながらも10ではない場合、その結果は、指定した radix を使用する this Number値の文字列表現です。 文字 a-z は、値10から35という数字として使われます。 radix が10ではない場合、正確なアルゴリズムは、実装依存ですが、しかしながらそのアルゴリズムは、 9.8.1 で指定したように汎用とすべきです。</p>
    <p>　 toString関数は、汎用ではなく、その this 値が、NumberやNumberオブジェクトではない場合、TypeError例外を投げ(スローし)ます。 その為、メソッドとしての使用においてオブジェクトの他の種類への転送は不可です。</p>
    <h3 id="15-7-4-3-number-prototype-tolocalestring-">15.7.4.3 Number.prototype.toLocaleString()</h3>
    <p>　ホスト環境の現在のロケールの表記法によって書式化した this Number値を表すString値の生成。 この関数は実装依存であり、許容はされるもののtoStringと同じものを返す為にそれを使用することは推奨されません。</p>
    <p>[注釈]</p>
    <p>　この関数の1つめのパラメータは、この標準規格の将来のバージョンで使用されるかもしれません。 それは、つまり、実装は、いかなる場合においてもこのパラメータ位置を使用しないことが推奨されるという事です。</p>
    <h3 id="15-7-4-4-number-prototype-valueof-">15.7.4.4 Number.prototype.valueOf ( )</h3>
    <p>　 this Number値を返します。</p>
    <p>　 valueOf関数は、汎用ではなく、その this 値が、NumberやNumberオブジェクトではない場合、TypeError例外を投げ(スローし)ます。 その為、メソッドとしての使用においてオブジェクトの他の種類への転送は不可です。</p>
    <h3 id="15-7-4-5-number-prototype-tofixed-fractiondigits-">15.7.4.5 Number.prototype.toFixed (fractionDigits)</h3>
    <p>　小数点以下fractionDigits桁の10進固定小数点表記で表現した、 this Number値を含む文字列を返します。 fractionDigits が、undefinedである場合、0 であるものとして仮定されます。</p>
    <p>　(toFixedは、)具体的には、次のステップを実行します。</p>
<pre><code>1. f は、 ToInteger(fractionDigits) とする( fractionDigits が、 undefinedである場合、このステップは値0を生成)
    2. f &lt; 0 または、 f &gt; 20 である場合、RangeError例外を投げる(スローする)
    3. x は、 this Number値とする
    4. x が、 NaNである場合、文字列 &quot;NaN&quot; を返す
    5. s は、カラの文字列とする
    6. x &lt; 0 である場合、
    a. s は、 &quot;-&quot; とする
    b. x = -x とする
    7. x ≧ 10の21乗である場合、
    a. m = ToString(x) とする
    8.それ以外の場合、 x &lt; 10の21乗 であり、
    a. n は、限りなくゼロに近い n ÷ 10のf乗 - x の正確な数学的な値である整数とする
    n に該当するものが2つある場合、大きい方を選ぶ
    b. n = 0 である場合、 m は、文字&quot;0&quot;とし、それ以外の場合、 m は、(順にゼロが先行しない) n の10進表現の数字で構成されている文字列とする
    c. f ≠ 0 である場合、
    i. k は、m 内にある文字数とする
    ii. k ≦ f である場合、
    1. z は、文字&#39;0&#39;の f+1-k 回の出現で構成する文字列とする
    2. m は、文字列 z と m を連結したものとする
    3. k = f + 1 とする
    iii. a は、m の1つめの k-f 文字とし、 b は、 m の残りの f 文字とする
    iv. m は、 a 、&quot;.&quot; 、b という3つの文字列を連結したものとする
    9.文字列 s と m を連結したものを返す
</code></pre><p>　 toFixedメソッドのlengthプロパティは、1です。</p>
    <p>　 toFixedメソッドが、引数を1つより多く(2つ以上)伴って呼ばれる場合、その動作は、undefined(未定義)です。(第15項参照) 実装は、0より小さいか、または、20より大きいfractionDigitsの値におけるtoFixedの動作を拡張することが許容されます。 このケースにおけるtoFixedは、そのような値においてRangeErrorを投げる(スローする)必要はありません。</p>
    <p>[注釈]</p>
    <p>　 toFixedの出力は、toStringは、隣接する数値からその数字を識別するのに十分な有効桁を出力するだけなので一部の値においてはtoString以上により正確なものとなる場合があります。</p>
<pre><code>例えば、
    (1000000000000000128).toString() は、
    (1000000000000000128).toFixed(0) が、
    &quot;1000000000000000128&quot;を返すのに対し、
    &quot;1000000000000000100&quot; を返す
</code></pre><h3 id="15-7-4-6-number-prototype-toexponential-fractiondigits-">15.7.4.6 Number.prototype.toExponential (fractionDigits)</h3>
    <p>　仮数の小数点の前の1ケタと仮数の小数点の後のfractionDigits桁を伴う10進指数関数表現で表示した this Number値を含む文字列を返します。 fractionDigitsが、undefined(未定義)である場合、(Numberが常に指数関数表記で表示出力されるこのケースを除き、ToStringと同じように)必要に応じて多くの仮数の桁に一意のNumberを指定したものを含みます。</p>
    <p>　(toExponentialは、)具体的には、次のステップを実行します。</p>
<pre><code>1. x は、 this Number値とする
    2. f は、 ToInteger(fractionDigits) とする
    3. x が、 NaNである場合、文字列&quot;NaN&quot;を返す
    4. s は、カラの文字列とする
    5. x &lt; 0 である場合、
    a. s は、 &quot;-&quot; とする
    b. x = -x とする
    6. x = +∞ である場合、
    a.文字列 s と&quot;Infinity&quot;を連結したものを返す
    7. fractionDigits が、 undefined(未定義)でなく、且つ、 (f &lt; 0 または f &gt; 20) である場合、RangeError例外を投げる(スローする)
    8. x = 0 である場合、
    a. f = 0 とする
    b. m は、文字&#39;0&#39; の f+1 回の出現を構成する文字列とする
    c. e = 0 とする
    9.それ以外の場合、 x ≠ 0 であり、
    a. fractionDigits が、undefined(未定義)ではない場合、
    i. e と n は、可能な限りゼロに近いものである n x 10のe-f乗 - x の正確な数学的な値における 10のf乗 ≦ n ≦ 10のf+1乗のような整数とする
    e と n のセットのようなものが2つある場合、 n x 10のe-f乗が大きい方を選ぶ
    b.それ以外の場合、fractionDigits は、undefined(未定義)であり、
    i. e、 n、 f は、 n x 10のe-f乗が x 且つ、f が限りなく小さいという条件における数字の値である f ≧ 0 、10のf乗 ≦ n 10のf+1乗のような整数とする
    f+1 桁を持つ n の10進表現における注釈として、 n は、10で割り切れない、また、n の最小の仮数の桁は、これらの条件によって一意に決まる必要はない。
    c. m は、(順にゼロに先行されない) n の10進表現の数字で構成される文字列とする
    10. f ≠ 0 である場合、
    a. a は、m の1つめの文字とし、b は、m の残りの f 文字とする
    b. m は、文字列 a、&quot;.&quot;、b を連結したものとする
    11. e = 0 である場合、
    a. c = &quot;+&quot; とする
    b. d = &quot;0&quot; とする
    12.それ以外の場合、
    a. e &gt; 0 である場合、 c = &quot;+&quot; とする
    b.それ以外の場合、e ≦ 0 であり、
    i. c = &quot;-&quot; とする
    ii. e = -e とする
    c. d は、(順にゼロに先行されない) e の10進表現の数字で構成される文字列とする
    13. m は、文字列 m、 &quot;e&quot;、 c、 d を連結したものとする
    14.文字列 s と m を連結したものを返す
</code></pre><p>　 toExponentialメソッドのlengthプロパティは、1です。</p>
    <p>　 toExponentialメソッドが、引数を1つより多く(2つ以上)伴って呼ばれる場合、その動作はundefined(未定義)です。(第15項参照)</p>
    <p>　実装は、0より小さいか、または、20より大きいfractionDigitsの値においてtoExponentialの動作を拡張することが許容されます。 このケースにおいてtoExponentialは、そのような値についてRangeErrorを投げる(スローする)必要はありません。</p>
    <p>[注釈]</p>
    <p>　上記規則によって要求される以上のより正確な変換を提供する実装においては、次のステップ 9.b.i の代替バージョンをガイドラインとして使用されることが推奨されます。</p>
<pre><code>        i. e、 n、 f は、 n x 10のe-f乗が x 且つ、f が限りなく小さいという条件における数字の値である f ≧ 0、10のf乗 ≦ n ≦ 10のf+1乗のような整数とする
    n において利用可能なものが複数ある場合、 n x 10のe-f乗が、x という値に限りなく近くなる場合における n の値を選ぶ
    n として使用可能な値が2つある場合、偶数である方を選ぶ
</code></pre><h3 id="15-7-4-7-number-prototype-toprecision-precision-">15.7.4.7 Number.prototype.toPrecision (precision)</h3>
    <p>　仮数の小数点の前の1ケタと仮数の小数点の後の precision-1 桁、または、 precision 有効桁を伴う小数固定表記を伴う10進指数関数表記で表示した this Number値を含む文字列を返します。 precision が、 undefined(未定義)である場合、代わりに ToString (9.8.1) を呼びます。</p>
    <p>　(toPrecisionは、)具体的には、次のステップを実行します。</p>
<pre><code>1. x は、 this Number値とする
    2. precision  が、 undefined(未定義)である場合、 ToString(x) とする
    3. p は、 ToInteger(precision) とする
    4. x が、 NaN である場合、文字列&quot;NaN&quot;を返す
    5. s は、カラの文字列とする
    6. x &lt; 0 である場合、
    a. s は、 &quot;-&quot; とする
    b. x = -x とする
    7. x = +∞ である場合、
    a.文字列 s と&quot;Infinity&quot;を連結したものを返す
    8. p &lt; 1 または、 p &gt; 21 である場合、RangeError例外を投げる(スローする)
    9. x = 0 である場合、
    a. m は、 文字列&#39;0&#39;の p 回の出現で構成される文字列とする
    b. e = 0 とする
    10.それ以外の場合、 x ≠ 0であり、
    a. e と n は、10のp-1乗 ≦ n ＜ 10p乗のような、且つ、可能な限りゼロに近い n x 10のe-p+1乗の正確な数学的な値における整数とする
    e と n のようなセットが2つある場合、n x 10の e-p+1 乗が大きい方の e と n を選ぶ
    b. m は、(順にゼロで先行しない) n の 10進表記の数字で構成される文字列とする
    c. e &lt; -6 または、 e ≧ p である場合、
    i. a は、 m の1つめの文字とし、b は、 m の残りの p-1 文字とする
    ii. m は、文字列 a、 &quot;.&quot;、 b を連結したものとする
    iii. e = 0 である場合、
    1. c = &quot;+&quot; と d = &quot;0&quot; とする
    iv.それ以外の場合、e ≠ 0 であり、
    1. e &gt; 0 である場合、
    a c = &quot;+&quot; とする
    2.それ以外の場合、e &lt; 0 であり、
    a  c = &quot;-&quot; とする
    b  e = -e とする
    3. d は、(順にゼロで先行しない) e の 10進表現の数字で構成される文字列とする
    v. m は、5つの文字列 s、 m、 &quot;e&quot;、 c、 d を連結したものとする
    11. e = p-1 である場合、文字列 s と m を連結したものを返す
    12. e ≧ 0 である場合、
    a. m は、m の最初の e+1 文字、文字 &#39;.&#39;、m の残りの p-(e+1) 文字を連結したものとする
    13. e &lt; 0 である場合、
    a. m は、文字列&quot;0.&quot;、文字&#39;0&#39;の -(e+1) 回の出現、文字列 m を連結したものとする
    14.文字列 s と m を連結したものを返す
</code></pre><p>　 toPrecisionメソッドのlengthプロパティは、1です。</p>
    <p>　 toPrecisionメソッドが、引数を1つより多く(2つ以上)伴って呼ばれる場合、その動作は、undefined(未定義)です。(第15項参照) 実装は、1より小さいか、または21より大きい precision の値におけるtoPrecisionの動作を拡張することが許容されます。 このケースにおいては、toPrecisionは、このような値においてRangeErrorを投げる(スローする)必要はありません。</p>
    <h2 id="15-7-5-number-properties-of-number-instances-standard-ecma-262-5-1-edition">15.7.5 Number インスタンスのプロパティ / Properties of Number Instances / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="15-ecmascript-">15 標準組み込みECMAScriptオブジェクト</h3>
    <h3 id="15-7-number-">15.7 Number オブジェクト</h3>
    <h3 id="15-7-5-number-">15.7.5 Number インスタンスのプロパティ</h3>
    <p>　 Numberインスタンスは、Numberプロトタイプオブジェクトと値が“Number”であるそれらの内部プロパティ[[Class]]からプロパティを継承します。 Numberインスタンスはまた、内部プロパティ[[PrimitiveValue]]も持ちます。</p>
    <p>　内部プロパティ[[PrimitiveValue]]は、this Numberオブジェクトによって表したNumber値です。</p>
    <h2 id="15-8-math-the-math-object-standard-ecma-262-5-1-edition">15.8 Math オブジェクト / The Math Object / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="15-ecmascript-">15 標準組み込みECMAScriptオブジェクト</h3>
    <h3 id="15-8-math-">15.8 Math オブジェクト</h3>
    <p>　 Math オブジェクトは、いくつかの関数から成る、いくつかの名前付きプロパティを持つ単独のオブジェクトです。</p>
    <p>　 Math オブジェクトの内部プロパティ[[Prototype]]の値は、標準組み込みObjectプロトタイプオブジェクト(15.2.4)です。 Math オブジェクトの内部プロパティ[[Class]]の値は、“Math”です。</p>
    <p>　 Math オブジェクトは、内部プロパティ[[Construct]]を持っていません。 つまり、new 演算子を伴ってコンストラクタとしてMath オブジェクトを使用することはできません。</p>
    <p>　 Math オブジェクトは、内部プロパティ[[Call]]を持っていません。 つまり、Math オブジェクトを関数として呼び出すことはできません。</p>
    <p>[注釈]</p>
    <p>　この仕様について、フレーズ&quot; x におけるNumber値&quot;は、8.5 で定義した技術的な意味を持ちます。</p>
    <h2 id="15-8-1-math-value-properties-of-the-math-object-standard-ecma-262-5-1-edition">15.8.1 Math オブジェクトの値プロパティ / Value Properties of the Math Object / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="15-ecmascript-">15 標準組み込みECMAScriptオブジェクト</h3>
    <h3 id="15-8-math-">15.8 Math オブジェクト</h3>
    <h3 id="15-8-1-math-">15.8.1 Math オブジェクトの値プロパティ</h3>
    <h3 id="15-8-1-1-e">15.8.1.1 E</h3>
    <p>　自然(常用)対数の底 e におけるNumber値は、約 2.7182818284590452354 です。 このプロパティは、属性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false } を持ちます。</p>
    <h3 id="15-8-1-2-ln10">15.8.1.2 LN10</h3>
    <p>　10の自然常用対数におけるNumber値は、約 2.302585092994046 です。 このプロパティは、属性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false } を持ちます。</p>
    <h3 id="15-8-1-3-ln2">15.8.1.3 LN2</h3>
    <p>　2の自然(常用)対数におけるNumber値は、約 0.6931471805599453 です。 このプロパティは、属性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false } を持ちます。</p>
    <h3 id="15-8-1-4-log2e">15.8.1.4 LOG2E</h3>
    <p>　自然(常用)対数の底 e の 底-2 の対数におけるNumber値、この値は、約 1.4426950408889634 です。</p>
    <p>　このプロパティは、属性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false } を持ちます。</p>
    <p>[注釈]</p>
    <p>　 Math.LOG2E の値は、おおよそ Math.LN2の逆数です。</p>
    <h3 id="15-8-1-5-log10e">15.8.1.5 LOG10E</h3>
    <p>　自然(常用)対数の底 e の 底-10 の対数におけるNumber値、この値は、約 0.4342944819032518 です。</p>
    <p>　このプロパティは、属性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false } を持ちます。</p>
    <p>[注釈]</p>
    <p>　 Math.LOG10E の値は、おおよそ Math.LN10の逆数です。</p>
    <h3 id="15-8-1-6-pi">15.8.1.6 PI</h3>
    <p>　πにおけるNumber値は、その直径に対する円の円周率であり、それは、約 3.1415926535897932 です。 このプロパティは、属性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false } を持ちます。</p>
    <h3 id="15-8-1-7-sqrt1-_2">15.8.1.7 SQRT1_2</h3>
    <p>　1/2の平方根におけるNumber値は、約 0.7071067811865476 です。 このプロパティは、属性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false } を持ちます。</p>
    <p>[注釈]</p>
    <p>　 Math.SQRT1_2 の値は、おおよそ Math.SQRT2の逆数です。</p>
    <h3 id="15-8-1-8-sqrt2">15.8.1.8 SQRT2</h3>
    <p>　2の平方根におけるNumber値は、約 1.4142135623730951 です。 このプロパティは、属性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false } を持ちます。</p>
    <h2 id="standard-ecma-262-5-1-edition">Standard ECMA-262 5.1 Edition</h2>
    <h3 id="15-ecmascript-">15 標準組み込みECMAScriptオブジェクト</h3>
    <h3 id="15-8-math-">15.8 Math オブジェクト</h3>
    <h3 id="15-8-2-math-">15.8.2 Mathオブジェクトの関数プロパティ</h3>
    <p>　次のそれぞれのMathオブジェクト関数は、(1つ以上ある場合、左から右の順に)その引数のそれぞれに抽象操作ToNumberを適用し、それから結果となる Number value(s) についての算出を実行します。 以下の関数概要については、その記号 NaN、 -0、 +0、 -∞、 +∞ は、 8.5 で定義したNumber値を参照します。</p>
    <p>[注釈]</p>
    <p>　関数 acos 、asin 、atan、 atan2、 cos、 exp、 log、 pow、 sin、 sqrt、 tan の動作は、関心ある事柄を含む境界のケースを表す特定の引数の値における結果を指定することを要求する以外は、ここで指定したものは正確ではありません。 他の引数の値については、これらの関数は、よく知られている数学関数の結果との近似値を算出することが意図されますが、近似アルゴリズム選択内でのある程度の自由度が許容されます。 総合的な意図としては、実装は、そのプラットフォーム上の C プログラマが利用可能である、与えられたハードウェアプラットフォーム上でECMAScriptにおける同様の数学ライブラリを使用することができるべきであるということです。 アルゴリズムの選択は、実装に任されますが、とはいうものの、(このECMAScript標準仕様による指定ではなく、) Sun Microsystems 社発行のフリー配布の数学ライブラリ fdlibm (<a href="http://www.netlib.org/fdlibm">http://www.netlib.org/fdlibm</a>) 内に含んだ [ IEEE 754 arithmetic / 演算 ]における近似アルゴリズムを使用する実装が推奨されます。</p>
    <h3 id="15-8-2-1-abs-x-">15.8.2.1 abs (x)</h3>
    <p>　 x の絶対値を返します。 その結果は、 x と同じ大きさですが、正の符号を持ちます。</p>
<pre><code>・ x が、 NaN である場合、その結果は、NaN
    ・ x が、 -0 である場合、その結果は、 +0
    ・ x が、 -∞ である場合、その結果は、 +∞
</code></pre><h3 id="15-8-2-2-acos-x-">15.8.2.2 acos (x)</h3>
    <p>　 x のアークコサイン(逆コサイン)の実装依存の近似値を返します。 その結果は、ラジアン(角度)で表され、 +0 から +π までの範囲となります。</p>
<pre><code>・ x が、 NaN である場合、その結果は、 NaN
    ・ x が、 1 より大きい場合、その結果は、 NaN
    ・ x が、 -1 より小さい場合、その結果は、NaN
    ・ x が、 ちょうど 1 である場合、その結果は、 +0
</code></pre><h3 id="15-8-2-3-asin-x-">15.8.2.3 asin (x)</h3>
    <p>　 x のアークサイン(逆サイン)の実装依存の近似値を返します。 その結果は、ラジアンで表され、 -π/2 から +π/2 までの範囲となります。</p>
<pre><code>・ x が、 NaN である場合、その結果は、 NaN
    ・ x が、 1 より大きい場合、その結果は、 NaN
    ・ x が、 -1 より小さい場合、その結果は、 NaN
    ・ x が、 +0 である場合、その結果は、 +0
    ・ x が、 -0 である場合、その結果は、 -0
</code></pre><h3 id="15-8-2-4-atan-x-">15.8.2.4 atan (x)</h3>
    <p>　 x のアークタンジェント(逆タンジェント)の実装依存の近似値を返します。 その結果は、ラジアンで表され、 -π/2 から +π/2 までの範囲となります。</p>
<pre><code>・ x が、 NaN である場合、その結果は、 NaN
    ・ x が、 +0 である場合、その結果は、 +0
    ・ x が、 -0 である場合、その結果は、 -0
    ・ x が、 +∞ である場合、その結果は、 +π/2 への実装依存の近似値
    ・ x が、 -∞ である場合、その結果は、 -π/2 への実装依存の近似値
</code></pre><h3 id="15-8-2-5-atan2-y-x-">15.8.2.5 atan2 (y, x)</h3>
    <p>　 y と x の符号が、その結果の象限(quadrant)を決める為に使用される場合、引数 y と x の商のアークタンジェント(逆タンジェント)への実装依存の近似値を返します。 注釈としては、引数名 y を1つめ、引数名 x を2つめとした2つの引数を持つアークタンジェント関数としたのは、意図的であり、伝統的なものです。 その結果は、ラジアンで表され、-π から +π までの範囲となります。</p>
<pre><code>・ x または、 y の何れかが、NaN である場合、その結果は、 NaN
    ・ y &gt; 0 且つ、 x が、 +0 である場合、その結果は、 +π/2 への実装依存の近似値
    ・ y &gt; 0 且つ、 x が、 -0 である場合、その結果は、 +π/2 への実装依存の近似値
    ・ y が、 +0 且つ、 x &gt; 0 である場合、その結果は、 +0
    ・ y が、 +0 且つ、 x が、 +0 である場合、その結果は、 +0
    ・ y が、 +0 且つ、 x が、 -0 である場合、その結果は、 +π への実装依存の近似値
    ・ y が、 +0 且つ、 x &lt; 0 である場合、その結果は、  +π への実装依存の近似値
    ・ y が、 -0 且つ、 x &gt; 0 である場合、その結果は、 -0
    ・ y が、 -0 且つ、 x が、 +0 である場合、その結果は、 -0
    ・ y が、 -0 且つ、 x が、 -0 である場合、その結果は、 -π への実装依存の近似値
    ・ y が、 -0 且つ、 x &lt; 0 である場合、その結果は、 -π への実装依存の近似値
    ・ y &lt; 0 且つ、 x が、 +0 である場合、その結果は、 -π/2 への実装依存の近似値
    ・ y &lt; 0 且つ、 x が、 -0 である場合、その結果は、 -π/2 への実装依存の近似値
    ・ y &gt; 0 且つ、 y が、有限、且つ、 x is +∞ である場合、その結果は、 +0
    ・ y &gt; 0 且つ、 y が、有限、且つ、 x is -∞ である場合、その結果は、 +π への実装依存の近似値
    ・ y &lt; 0 且つ、 y が、有限、且つ、 x is +∞ である場合、その結果は、 -0
    ・ y &lt; 0 且つ、 y が、有限、且つ、 x is -∞ である場合、その結果は、 -π への実装依存の近似値
    ・ y が、 +∞ 且つ、 x が、有限である場合、その結果は、+π/2 への実装依存の近似値
    ・ y が、 -∞ 且つ、 x が、有限である場合、その結果は、-π/2 への実装依存の近似値
    ・ y が、 +∞ 且つ、 x が、 +∞ である場合、その結果は、 +π/4 への実装依存の近似値
    ・ y が、 +∞ 且つ、 x が、 -∞ である場合、その結果は、 +3π/4 への実装依存の近似値
    ・ y が、 -∞ 且つ、 x が、 +∞ である場合、その結果は、 -π/4 への実装依存の近似値
    ・ y が、 -∞ 且つ、 x が、 -∞ である場合、その結果は、 -3π/4 への実装依存の近似値
</code></pre><h3 id="15-8-2-6-ceil-x-">15.8.2.6 ceil (x)</h3>
    <p>　 x よりも小さくなることなく、数学的な整数と等しい(-∞に限りなく近い)最も小さいNumber値を返します。 x が、既に整数である場合、その結果は、x です。</p>
<pre><code>・ x が、 NaN である場合、その結果は、 NaN
    ・ x が、 +0 である場合、その結果は、 +0
    ・ x が、 -0 である場合、その結果は、 -0
    ・ x が、 +∞ である場合、その結果は、 +∞
    ・ x が、 -∞ である場合、その結果は、 -∞
    ・ x が、 0 より小さく、-1 より大きい場合、その結果は、-0
</code></pre><p>　 Math.ceil(x) の値は、 -Math.floor(-x) の値と同一です。</p>
    <h3 id="15-8-2-7-cos-x-">15.8.2.7 cos (x)</h3>
    <p>　 x の余弦(cosine/コサイン)の実装依存の近似値を返します。 その引数は、ラジアンで表されます。</p>
<pre><code>・ x が、 NaN である場合、その結果は、 NaN
    ・ x が、 +0 である場合、その結果は、 1
    ・ x が、 -0 である場合、その結果は、 1
    ・ x が、 +∞ である場合、その結果は、 NaN
    ・ x が、 -∞ である場合、その結果は、 NaN
</code></pre><h3 id="15-8-2-8-exp-x-">15.8.2.8 exp (x)</h3>
    <p>　 x の指数関数における実装依存の近似値を返します。( e が、自然(常用)対数の底である場合、 e の x 乗 )</p>
<pre><code>・ x が、 NaN である場合、その結果は、 NaN
    ・ x が、 +0 である場合、その結果は、 1
    ・ x が、 -0 である場合、その結果は、 1
    ・ x が、 +∞ である場合、その結果は、 +∞
    ・ x が、 -∞ である場合、その結果は、 +0
</code></pre><h3 id="15-8-2-9-floor-x-">15.8.2.9 floor (x)</h3>
    <p>　 x よりも大きくなることがない(+無限大に限りなく近い)最も大きく、数学的に等しいNumber値を返します。 x が、既に整数である場合、その結果は、 x です。</p>
<pre><code>・ x が、 NaN である場合、その結果は、NaN
    ・ x が、 +0 である場合、その結果は、 +0
    ・ x が、 -0 である場合、その結果は、 -0
    ・ x が、 +∞ である場合、その結果は、 +∞
    ・ x が、 -∞ である場合、その結果は、 -∞
</code></pre><p>　 x が、0より大きく、1より小さい場合、その結果は、+0 です。</p>
    <p>[注釈]</p>
    <p>　 Math.floor(x) の値は、 -Math.ceil(-x) の値と同一です。</p>
    <h3 id="15-8-2-10-log-x-">15.8.2.10 log (x)</h3>
    <p>　 x の自然(常用)対数への実装依存の近似値を返します。</p>
<pre><code>・ x が、 NaN である場合、その結果は、 NaN
    ・ x が、 0 より小さい場合、その結果は、 NaN
    ・ x が、 +0 または -0 である場合、その結果は、 -∞
    ・ x が、 1 である場合、その結果は、 +0
    ・ x が、 +∞ である場合、その結果は、 +∞
</code></pre><h3 id="15-8-2-11-max-value1-value2-">15.8.2.11 max ( [ value1 [ , value2 [ , … ] ] ] )</h3>
    <p>　ゼロ個以上の引数が与えられると引数ごとに ToNumber を呼び、結果となる値の最大値を返します。</p>
<pre><code>・与えられる引数が何もない場合、その結果は、 -∞
    ・一部の値が、 NaNである場合、その結果は、 NaN
    ・ +0 が、-0 より大きいと考えられる場合を除き、最大値を決める為の値の比較は、 11.8.5 内のように実行される
</code></pre><p>　 maxメソッドのlengthプロパティは、2です。</p>
    <h3 id="15-8-2-12-min-value1-value2-">15.8.2.12 min ( [ value1 [ , value2 [ , … ] ] ] )</h3>
    <p>　ゼロ個以上の引数が与えられると引数ごとに ToNumber を呼び、結果となる値の最小値を返します。</p>
<pre><code>・与えられる引数が何もない場合、その結果は、 +∞
    ・一部の値が、 NaN である場合、その結果は、 NaN
    ・ +0 が、-0 より大きいと考えられる場合を除き、最小値を決める為の値の比較は、 11.8.5 内のように実行される
</code></pre><p>　 minメソッドのlengthプロパティは、2です。</p>
    <h3 id="15-8-2-13-pow-x-y-">15.8.2.13 pow (x, y)</h3>
    <p>　 x の y 乗としてその結果への実装依存の近似値を返します。</p>
<pre><code>・ y が、 NaN である場合、その結果は、 NaN
    ・ y が、 +0 である場合、x が仮に NaNであったとしてもその結果は、 1
    ・ y が、 -0x が仮に NaNであったとしてもその結果は、1
    ・ x が、 NaN 且つ、 y が、非ゼロである場合、その結果は、 NaN
    ・ abs(x)&gt;1 且つ、 y が、 +∞ である場合、その結果は、 +∞
    ・ abs(x)&gt;1 且つ、 y が、 -∞ である場合、その結果は、 +0
    ・ abs(x)==1 且つ、 y が、 +∞ である場合、その結果は、 NaN
    ・ abs(x)==1 且つ、 y が、 -∞ である場合、その結果は、 NaN
    ・ abs(x)&lt;1 且つ、 y が、 +∞ である場合、その結果は、 +0
    ・ abs(x)&lt;1 且つ、 y が、 -∞ である場合、その結果は、 +∞
    ・ x が、 +∞ 且つ、 y&gt;0 である場合、その結果は、 +∞
    ・ x が、 +∞ 且つ、 y&lt;0 である場合、その結果は、 +0
    ・ x が、 -∞ 且つ、 y&gt;0 且つ、 y が、奇数である場合、その結果は、 -∞
    ・ x が、 -∞ 且つ、 y&gt;0 且つ、 y が、奇数ではない場合、その結果は、 +∞
    ・ x が、 -∞ 且つ、 y&lt;0 且つ、 y が、奇数である場合、その結果は、 -0
    ・ x が、 -∞ 且つ、 y&lt;0 且つ、 y が、 奇数ではない場合、その結果は、 +0
    ・ x が、 +0 且つ、 y&gt;0 である場合、その結果は、 +0
    ・ x が、 +0 且つ、 y&lt;0 である場合、その結果は、 +∞
    ・ x が、 -0 且つ、 y&gt;0 且つ、 y が、奇数である場合、その結果は、 -0
    ・ x が、 -0 且つ、 y&gt;0 且つ、 y が、奇数ではない場合、その結果は、 +0
    ・ x が、 -0 且つ、 y&lt;0 且つ、 y が、奇数である場合、その結果は、 -∞
    ・ x が、 -0 且つ、 y&lt;0 且つ、 y が、奇数ではない場合、その結果は、 +∞
    ・ x&lt;0 且つ、 x が有限、且つ、 y が有限、且つ、 y が奇数ではない場合、その結果は、 NaN
</code></pre><h3 id="15-8-2-14-random-">15.8.2.14 random ( )</h3>
    <p>　実装依存のアルゴリズムや方策を使用してその範囲を超えた均一な分布での選択ランダム、または、擬似ランダムで0以上(0より大きいか等しい)且つ、1より小さい正の符号を持つNumber値を返します。 この関数は、引数を一切取りません。</p>
    <h3 id="15-8-2-15-round-x-">15.8.2.15 round (x)</h3>
    <p>　 x に限りなく近く、数学的な整数と等しいNumber値を返します。 2つの整数であるNumber値が、x と限りなく等しい場合、その結果は、 +∞ に限りなく近いNumber値です。 x が、既に整数である場合、その結果は、x です。</p>
<pre><code>・ x が、 NaN である場合、その結果は、 NaN
    ・ x が、 +0 である場合、その結果は、 +0
    ・ x が、 -0 である場合、その結果は、 -0
    ・ x が、 +∞ である場合、その結果は、 +∞
    ・ x が、 -∞ である場合、その結果は、 -∞
    ・ x が、 0 より大きく、0.5より小さい場合、その結果は、 +0
    ・ x が、 0 より小さく、-0.5 より大きいか、等しい場合、その結果は、 -0
</code></pre><p>[注釈 1]</p>
    <p>　 Math.round(3.5) は、4 を返しますが、 Math.round(-3.5) は、 -3 を返します。</p>
    <p>[注釈 2]</p>
    <p>　 Math.round(x) の値は、 Math.round(x) が、 -0を返すが、 Math.floor(x+0.5) が、 +0 を返すというこれらの状況において x が、-0、または0より小さく、-0.5 より大きいか等しい場合を除き、Math.floor(x+0.5) の値と同一です。</p>
    <h3 id="15-8-2-16-sin-x-">15.8.2.16 sin (x)</h3>
    <p>　 x の正弦(sine/サイン)への実装依存の近似値を返します。 引数はラジアンで表されます。</p>
<pre><code>・ x が、 NaN である場合、その結果は、 NaN
    ・ x が、 +0 である場合、その結果は、 +0
    ・ x が、 -0 である場合、その結果は、 -0
    ・ x が、 +∞ または、 -∞ である場合、その結果は、 NaN
</code></pre><h3 id="15-8-2-17-sqrt-x-">15.8.2.17 sqrt (x)</h3>
    <p>　 x の平方根(square root)への近似値を返します。</p>
<pre><code>・ x が、 NaN である場合、その結果は、 NaN
    ・ x が、 0 より小さい場合、その結果は、 NaN
    ・ x が、 +0 である場合、その結果は、 +0
    ・ x が、 -0 である場合、その結果は、 -0
    ・ x が、 +∞ である場合、その結果は、 +∞
</code></pre><h3 id="15-8-2-18-tan-x-">15.8.2.18 tan (x)</h3>
    <p>　 x の正接(tangent/タンジェント)への実装依存の近似値を返します。 引数はラジアンで表されます。</p>
<pre><code>・ x が、 NaN である場合、その結果は、 NaN
    ・ x が、 +0 である場合、その結果は、 +0
    ・ x が、 -0 である場合、その結果は、 -0
    ・ x が、 +∞ or -∞ である場合、その結果は、 NaN
</code></pre><h2 id="15-9-date-date-objects-standard-ecma-262-5-1-edition">15.9 Date オブジェクト / Date Objects / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="15-ecmascript-">15 標準組み込みECMAScriptオブジェクト</h3>
    <h3 id="15-9-date-">15.9 Date オブジェクト</h3>
    <p>></p>
    <p>—-15.9.1.15.1 拡張した年</p>
    <p>–15.9.2.1 Date ( [ year [, month [, date [, hours [, minutes [, seconds [, ms ] ] ] ] ] ] ] )</p>
    <p>–15.9.3.1 new Date (year, month [, date [, hours [, minutes [, seconds [, ms ] ] ] ] ] )</p>
    <p>–15.9.3.2 new Date (value)</p>
    <p>–15.9.3.3 new Date ( )</p>
    <p>–15.9.4.1 Date.prototype</p>
    <p>–15.9.4.2 Date.parse (string)</p>
    <p>–15.9.4.3 Date.UTC (year, month [, date [, hours [, minutes [, seconds [, ms ] ] ] ] ] )</p>
    <p>–15.9.4.4 Date.now ( )</p>
    <p>–15.9.5.1 Date.prototype.constructor</p>
    <p>–15.9.5.2 Date.prototype.toString ( )</p>
    <p>–15.9.5.3 Date.prototype.toDateString ( )</p>
    <p>–15.9.5.4 Date.prototype.toTimeString ( )</p>
    <p>–15.9.5.5 Date.prototype.toLocaleString ( )</p>
    <p>–15.9.5.6 Date.prototype.toLocaleDateString ( )</p>
    <p>–15.9.5.7 Date.prototype.toLocaleTimeString ( )</p>
    <p>–15.9.5.8 Date.prototype.valueOf ( )</p>
    <p>–15.9.5.9 Date.prototype.getTime ( )</p>
    <p>–15.9.5.10 Date.prototype.getFullYear ( )</p>
    <p>–15.9.5.11 Date.prototype.getUTCFullYear ( )</p>
    <p>–15.9.5.12 Date.prototype.getMonth ( )</p>
    <p>–15.9.5.13 Date.prototype.getUTCMonth ( )</p>
    <p>–15.9.5.14 Date.prototype.getDate ( )</p>
    <p>–15.9.5.15 Date.prototype.getUTCDate ( )</p>
    <p>–15.9.5.16 Date.prototype.getDay ( )</p>
    <p>–15.9.5.17 Date.prototype.getUTCDay ( )</p>
    <p>–15.9.5.18 Date.prototype.getHours ( )</p>
    <p>–15.9.5.19 Date.prototype.getUTCHours ( )</p>
    <p>–15.9.5.20 Date.prototype.getMinutes ( )</p>
    <p>–15.9.5.21 Date.prototype.getUTCMinutes ( )</p>
    <p>–15.9.5.22 Date.prototype.getSeconds ( )</p>
    <p>–15.9.5.23 Date.prototype.getUTCSeconds ( )</p>
    <p>–15.9.5.24 Date.prototype.getMilliseconds ( )</p>
    <p>–15.9.5.25 Date.prototype.getUTCMilliseconds ( )</p>
    <p>–15.9.5.26 Date.prototype.getTimezoneOffset ( )</p>
    <p>–15.9.5.27 Date.prototype.setTime (time)</p>
    <p>–15.9.5.28 Date.prototype.setMilliseconds (ms)</p>
    <p>–15.9.5.29 Date.prototype.setUTCMilliseconds (ms)</p>
    <p>–15.9.5.30 Date.prototype.setSeconds (sec [, ms ] )</p>
    <p>–15.9.5.31 Date.prototype.setUTCSeconds (sec [, ms ] )</p>
    <p>–15.9.5.32 Date.prototype.setMinutes (min [, sec [, ms ] ] )</p>
    <p>–15.9.5.33 Date.prototype.setUTCMinutes (min [, sec [, ms ] ] )</p>
    <p>–15.9.5.34 Date.prototype.setHours (hour [, min [, sec [, ms ] ] ] )</p>
    <p>–15.9.5.35 Date.prototype.setUTCHours (hour [, min [, sec [, ms ] ] ] )</p>
    <p>–15.9.5.36 Date.prototype.setDate (date)</p>
    <p>–15.9.5.37 Date.prototype.setUTCDate (date)</p>
    <p>–15.9.5.38 Date.prototype.setMonth (month [, date ] )</p>
    <p>–15.9.5.39 Date.prototype.setUTCMonth (month [, date ] )</p>
    <p>–15.9.5.40 Date.prototype.setFullYear (year [, month [, date ] ] )</p>
    <p>–15.9.5.41 Date.prototype.setUTCFullYear (year [, month [, date ] ] )</p>
    <p>–15.9.5.42 Date.prototype.toUTCString ( )</p>
    <p>–15.9.5.43 Date.prototype.toISOString ( )</p>
    <p>–15.9.5.44 Date.prototype.toJSON ( key )</p>
    <h2 id="15-9-1-date-overview-of-date-objects-and-definitions-of-abstract-operators-standard-ecma-262-5-1-edition">15.9.1 Date オブジェクトの概要と抽象操作の定義 / Overview of Date Objects and Definitions of Abstract Operators / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="15-ecmascript-">15 標準組み込みECMAScriptオブジェクト</h3>
    <h3 id="15-9-date-">15.9 Date オブジェクト</h3>
    <h3 id="15-9-1-date-">15.9.1 Date オブジェクトの概要と抽象操作の定義</h3>
    <p>　次の関数は、( 15.9.1.1 で定義した)時間の値を操作する抽象操作です。</p>
    <p>　注釈としては、全てのケースについて、これらの関数の1つへの何らかの引数が、 NaN である場合、その結果は、 NaN になるでしょう。</p>
    <p>–15.9.1.15.1 拡張した年</p>
    <h2 id="15-9-2-date-the-date-constructor-called-as-a-function-standard-ecma-262-5-1-edition">15.9.2 関数として呼ぶ Dateコンストラクタ / The Date Constructor Called as a Function / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="15-ecmascript-">15 標準組み込みECMAScriptオブジェクト</h3>
    <h3 id="15-9-date-">15.9 Date オブジェクト</h3>
    <h3 id="15-9-2-date-">15.9.2 関数として呼ぶ Dateコンストラクタ</h3>
    <p>　Dateが、コンストラクタではなく、関数として呼ばれる際には、現在の時間(UTC)を表す文字列を返します。</p>
    <p>[注釈]</p>
    <p>　関数呼び出し Date(…) は、同一の引数を伴う当該オブジェクト生成式 new Date(…) と同等ではありません。</p>
    <h3 id="15-9-2-1-date-year-month-date-hours-minutes-seconds-ms-">15.9.2.1 Date ( [ year [, month [, date [, hours [, minutes [, seconds [, ms ] ] ] ] ] ] ] )</h3>
    <p>　引数は全てオプションであり、任意の引数の提供は許容はされますが、完全に無視されます。 文字列が生成され、その名を持つ標準組み込みコンストラクタと標準組み込みメソッド Date.prototype.toString である toString における式 (new Date()).toString() によるかのように返されます。</p>
    <h2 id="15-9-3-date-the-date-constructor-standard-ecma-262-5-1-edition">15.9.3 Date コンストラクタ / The Date Constructor / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="15-ecmascript-">15 標準組み込みECMAScriptオブジェクト</h3>
    <h3 id="15-9-date-">15.9 Date オブジェクト</h3>
    <h3 id="15-9-3-date-">15.9.3 Date コンストラクタ</h3>
    <p>　Dateが、new 式の一部として呼ばれる場合、それは、コンストラクタであり、新たに生成したオブジェクトを初期化します。</p>
    <h3 id="15-9-3-1-new-date-year-month-date-hours-minutes-seconds-ms-">15.9.3.1 new Date (year, month [, date [, hours [, minutes [, seconds [, ms ] ] ] ] ] )</h3>
    <p>　Dateが、2つから7つまでの引数を伴って呼ばれる際には、年、月、(オプションとして)日、時間、分、秒、ミリ秒を算出します。</p>
    <p>　新たに構築されたオブジェクトの内部プロパティ[[Prototype]]は、 Date.prototype (15.9.4.1) の初期値であるオリジナルのDateプロトタイプオブジェクトに設定されます。</p>
    <p>　新たに構築されたオブジェクトの内部プロパティ[[Class]]は、“Date”に設定されます。</p>
    <p>　新たに構築されたオブジェクトの内部プロパティ[[Extensible]]は、trueに設定されます。</p>
    <p>　新たに構築されたオブジェクトの内部プロパティ[[PrimitiveValue]]は、次のように設定されます。</p>
<pre><code>1. y は、 ToNumber(year) とする
    2. m は、 ToNumber(month) とする
    3. date が、提供される場合、 dt は、 ToNumber(date) とし、それ以外の場合、 dt は、 1 とする
    4. hours が、提供される場合、 h は、 ToNumber(hours) とし、それ以外の場合、 h は、 0 とする
    5. minutes が、提供される場合、 min は、 ToNumber(minutes) とし、それ以外の場合、 min は、 0 とする
    6. seconds が、提供される場合、 s は、 ToNumber(seconds) とし、それ以外の場合、 s は、 0 とする
    7. ms が、提供される場合、 milli は、 ToNumber(ms) とし、それ以外の場合、 milli は、 0 とする
    8. y が、NaNではない場合、且つ、 0 ≦ ToInteger(y) ≦ 99 である場合、 yr は、 1900+ToInteger(y) とし、それ以外の場合、yr は、y とする
    9. finalDate は、 MakeDate(MakeDay(yr, m, dt), MakeTime(h, min, s, milli)) とする
    10.新たに構築されたオブジェクトの内部プロパティ[[PrimitiveValue]]に TimeClip(UTC(finalDate)) を設定
</code></pre><h3 id="15-9-3-2-new-date-value-">15.9.3.2 new Date (value)</h3>
    <p>　新たに構築したオブジェクトの内部プロパティ[[Prototype]]は、 Date.prototype (15.9.4.1) の初期値であるオリジナルのDateプロトタイプオブジェクトに設定されます。</p>
    <p>　新たに構築したオブジェクトの内部プロパティ[[Class]]は、 “Date” に設定されます。</p>
    <p>　新たに構築したオブジェクトの内部プロパティ[[Extensible]]は、 true に設定されます。</p>
    <p>　新たに構築したオブジェクトの内部プロパティ[[PrimitiveValue]]は、 次のように設定されます。</p>
<pre><code>1. v は、 ToPrimitive(value) とする
    2. Type(v) が、 Stringである場合、
    a. parseメソッド(15.9.4.2)と同じ方法で正確に日(date)として v を解析し、 V は、この日(date)における時間の値とする
    3.それ以外の場合、 V は、 ToNumber(v) とする
    4.新たに構築したオブジェクトの内部プロパティ[[PrimitiveValue]]に TimeClip(V) を設定し、返す
</code></pre><h3 id="15-9-3-3-new-date-">15.9.3.3 new Date ( )</h3>
    <p>　新たに構築したオブジェクトの内部プロパティ[[Prototype]]は、 Date.prototype (15.9.4.1) の初期値であるオリジナルのDateプロトタイプオブジェクトに設定されます。</p>
    <p>　新たに構築したオブジェクトの内部プロパティ[[Class]]は、 “Date” に設定されます。</p>
    <p>　新たに構築したオブジェクトの内部プロパティ[[Extensible]]は、 true に設定されます。</p>
    <p>　新たに構築したオブジェクトの内部プロパティ[[PrimitiveValue]]は、現在時刻を識別して時間の値(UTC)に設定されます。</p>
    <h2 id="15-9-4-date-properties-of-the-date-constructor-standard-ecma-262-5-1-edition">15.9.4 Date コンストラクタのプロパティ / Properties of the Date Constructor / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="15-ecmascript-">15 標準組み込みECMAScriptオブジェクト</h3>
    <h3 id="15-9-date-">15.9 Date オブジェクト</h3>
    <h3 id="15-9-4-date-">15.9.4 Date コンストラクタのプロパティ</h3>
    <p>　Dateコンストラクタの内部プロパティの値は、Functionプロトタイプオブジェクト(15.3.4)です。 また、内部プロパティと(値が7である)lengthプロパティ、Dateコンストラクタは、次のプロパティも持ちます。</p>
    <h3 id="15-9-4-1-date-prototype">15.9.4.1 Date.prototype</h3>
    <p>　 Date.prototype の初期値は、組み込みDateプロトタイプオブジェクト(15.9.5)です。 このプロパティは、属性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false } を持ちます。</p>
    <h3 id="15-9-4-2-date-parse-string-">15.9.4.2 Date.parse (string)</h3>
    <p>　 parse 関数は、その引数にToString演算子を適用し、日付と時刻としての結果となる文字列を解釈し、その日付と時刻と一致するUTC時間の値である数字を返します。 文字列は、文字列の内容によってローカル時間としてや他のタイムゾーン(時間帯)における時間として解釈される場合もあります。 その関数は最初にDate内で呼んだ規則によって文字列の書式の解析を試行します。</p>
    <p>　時間文字列の書式 (15.9.1.15)。 文字列は、その書式に準拠しない場合、その関数は、実装仕様のヒューリスティクス(経験則)や実装仕様の日付の書式にフォールバック(縮退)する場合があります。 書式文字列内で不正な要素の値を含む認識不能な文字列や日付は、 Date.parse によってNaNを返しましょう。</p>
    <p>　 x が、ミリ秒単位の量が、ECMAScriptの特定の実装内でゼロであるDateオブジェクトの場合、参照したすべてのプロパティが、それらの初期値を持つ場合、次の式の全てにおいては、当該実装内で同じ数値の値を生成すべきです。</p>
<pre><code>x.valueOf()
    Date.parse(x.toString())
    Date.parse(x.toUTCString())
    Date.parse(x.toISOString())
</code></pre><p>　しかしながら、式</p>
<pre><code>Date.parse(x.toLocaleString())
</code></pre><p>は、先行する3つの式と同一のNumber値を要求されることはなく、一般には、与えられた文字列値が、日付時刻文字列の書式(15.9.1.15)に準拠しない場合や toString や toUTCString メソッドによってその実装内で生成されることができなかった場合、Date.parse によって生成する値については、実装依存となります。</p>
    <h3 id="15-9-4-3-date-utc-year-month-date-hours-minutes-seconds-ms-">15.9.4.3 Date.UTC (year, month [, date [, hours [, minutes [, seconds [, ms ] ] ] ] ] )</h3>
    <p>　 UTC 関数が、2つ未満(0または1つ)の引数を伴って呼ばれる場合、その動作は、実装依存です。 UTC 関数が、2つから7つまでの引数を伴って呼ばれる場合、 year、month、(オプションとして) date、hours、minutes、seconds、ms から日付を算出します。</p>
    <p>　(UTC 関数は、)次のステップが取られます。</p>
<pre><code>1. y は、 ToNumber(year) とする
    2. m は、 ToNumber(month) とする
    3. date が、提供される場合、 dt は、 ToNumber(date) とし、それ以外の場合、dt は、1とする
    4. hours が、提供される場合、 h は、 ToNumber(hours) とし、それ以外の場合、h は、0とする
    5. minutes が、提供される場合、 min は、 ToNumber(minutes) とし、それ以外の場合、min は、0とする
    6. seconds が、提供される場合、 s は、 ToNumber(seconds) とし、それ以外の場合、s は、0とする
    7. ms が、提供される場合、 milli は、 ToNumber(ms) とし、それ以外の場合、milli は、0とする
    8. y が、 NaN ではなく、且つ、 0 ≦ ToInteger(y) ≦ 99 である場合、 yr は、 1900+ToInteger(y) とし、それ以外の場合、 yr は、 yとする
    9. TimeClip(MakeDate(MakeDay(yr, m, dt), MakeTime(h, min, s, milli))) を返す
</code></pre><p>　 UTC 関数の length プロパティは、7です。</p>
    <p>[注釈]</p>
    <p>　 UTC 関数は、Dateオブジェクトを生成するのではなく、Numberとして時間の値を返し、ローカル時間としてではなくUTC内で引数を解釈するといったように2つの手法においてDateコンストラクタとは異なっています。</p>
    <h3 id="15-9-4-4-date-now-">15.9.4.4 Date.now ( )</h3>
    <p>　 now 関数は、指定した UTC 日付の時間の値と now 呼び出しの発生時刻であるNumber値を返します。</p>
    <h2 id="15-9-5-date-properties-of-the-date-prototype-object-standard-ecma-262-5-1-edition">15.9.5 Date プロトタイプオブジェクトのプロパティ / Properties of the Date Prototype Object / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="15-ecmascript-">15 標準組み込みECMAScriptオブジェクト</h3>
    <h3 id="15-9-date-">15.9 Date オブジェクト</h3>
    <h3 id="15-9-5-date-">15.9.5 Date プロトタイプオブジェクトのプロパティ</h3>
    <p>　Dateプロトタイプオブジェクトは、[[PrimitiveValue]] がNaNである、それ自身のDateオブジェクト(、その[[Class]]は、“Date”)です。 Dateプロトタイプオブジェクトの内部プロパティ[[Prototype]]の値は、標準組み込みObjectプロトタイプオブジェクト(15.2.4)です。 次のDateプロトタイプオブジェクトのプロパティである関数の説明、フレーズ“this Dateオブジェクト”は、当該関数の呼び出しにおける this 値であるオブジェクトを参照します。</p>
    <p>　明示的に記述されない限りにおいては、これら関数は、何れも一般的ではなく、内部プロパティ[[Class]]の値が、“Date”である場合における this　値がオブジェクトではない場合、TypeError例外が投げられ(スローされ)ます。 また、そのフレーズ“this 時間値”は、this Dateオブジェクトによって表した時間におけるNumber値を参照し、それは、内部プロパティ[[PrimitiveValue]]の値が、this Dateオブジェクトとなります。</p>
    <h3 id="15-9-5-1-date-prototype-constructor">15.9.5.1 Date.prototype.constructor</h3>
    <p>　 Date.prototype.constructor の初期値は、組み込みDateコンストラクタです。</p>
    <h3 id="15-9-5-2-date-prototype-tostring-">15.9.5.2 Date.prototype.toString ( )</h3>
    <p>　この関数は、文字列値を返します。 文字列の内容については、実装依存ですが、利便性が高く、人間が読み取ることが可能な書式で現在のタイムゾーン(時間帯)による日付を表現することが意図されます。</p>
    <p>[注釈]</p>
    <p>　ミリ秒単位の量がゼロである任意の日付の値 d については、 Date.parse(d.toString()) の結果は、 d.valueOf() と等しくなります。</p>
    <p>15.9.4.2. 参照。</p>
    <h3 id="15-9-5-3-date-prototype-todatestring-">15.9.5.3 Date.prototype.toDateString ( )</h3>
    <p>　この関数は、文字列値を返します。 文字列の内容については、実装依存ですが、利便性が高く、人間が読み取ることが可能な書式で現在のタイムゾーン(時間帯)による日付の“年月日”部分を表現することが意図されます。</p>
    <h3 id="15-9-5-4-date-prototype-totimestring-">15.9.5.4 Date.prototype.toTimeString ( )</h3>
    <p>　この関数は、文字列値を返します。 文字列の内容については、実装依存ですが、利便性が高く、人間が読み取ることが可能な書式で現在のタイムゾーン(時間帯)による日付の“時間”部分を表現することが意図されます。</p>
    <h3 id="15-9-5-5-date-prototype-tolocalestring-">15.9.5.5 Date.prototype.toLocaleString ( )</h3>
    <p>　この関数は、文字列値を返します。 文字列の内容については、実装依存ですが、ホスト環境の現在のロケールにおける表記法と一致する利便性が高く、人間が読み取ることが可能な書式で現在のタイムゾーン(時間帯)による日付を表現することが意図されます。</p>
    <p>[注釈]</p>
    <p>　この関数への1つめのパラメータは、この標準規格の将来のバージョンで使用されるかもしれません。 それは、つまり、実装は、いかなる場合においてもこのパラメータ位置を使用しないことが推奨されるという事です。</p>
    <h3 id="15-9-5-6-date-prototype-tolocaledatestring-">15.9.5.6 Date.prototype.toLocaleDateString ( )</h3>
    <p>　この関数は、文字列値を返します。 文字列の内容については、実装依存ですが、ホスト環境の現在のロケールにおける表記法と一致する利便性が高く、人間が読み取ることが可能な書式で現在のタイムゾーン(時間帯)による日付の“年月日”部分を表現することが意図されます。</p>
    <p>[注釈]</p>
    <p>　この関数への1つめのパラメータは、この標準規格の将来のバージョンで使用されるかもしれません。 それは、つまり、実装は、いかなる場合においてもこのパラメータ位置を使用しないことが推奨されるという事です。</p>
    <h3 id="15-9-5-7-date-prototype-tolocaletimestring-">15.9.5.7 Date.prototype.toLocaleTimeString ( )</h3>
    <p>　この関数は、文字列値を返します。 文字列の内容については、実装依存ですが、ホスト環境の現在のロケールにおける表記法と一致する利便性が高く、人間が読み取ることが可能な書式で現在のタイムゾーン(時間帯)による日付の“時間”部分を表現することが意図されます。</p>
    <p>[注釈]</p>
    <p>　この関数への1つめのパラメータは、この標準規格の将来のバージョンで使用されるかもしれません。 それは、つまり、実装は、いかなる場合においてもこのパラメータ位置を使用しないことが推奨されるという事です。</p>
    <h3 id="15-9-5-8-date-prototype-valueof-">15.9.5.8 Date.prototype.valueOf ( )</h3>
    <p>　 valueOf 関数は、this 時間の値のNumberを返します。</p>
    <h3 id="15-9-5-9-1-date-prototype-gettime-">15.9.5.9 1. Date.prototype.getTime ( )</h3>
    <p>　 this 時間の値を返します。</p>
    <h3 id="15-9-5-10-date-prototype-getfullyear-">15.9.5.10 Date.prototype.getFullYear ( )</h3>
<pre><code>1. t は、this 時間の値とする
    2. t が、NaN である場合、 NaN を返す
    3. YearFromTime(LocalTime(t)) を返す
</code></pre><h3 id="15-9-5-11-date-prototype-getutcfullyear-">15.9.5.11 Date.prototype.getUTCFullYear ( )</h3>
<pre><code>1. t は、this 時間の値とする
    2. t が、NaN である場合、 NaN を返す
    3. YearFromTime(t) を返す
</code></pre><h3 id="15-9-5-12-date-prototype-getmonth-">15.9.5.12 Date.prototype.getMonth ( )</h3>
<pre><code>1. t は、this 時間の値とする
    2. t が、NaN である場合、 NaN を返す
    3. MonthFromTime(LocalTime(t)) を返す
</code></pre><h3 id="15-9-5-13-date-prototype-getutcmonth-">15.9.5.13 Date.prototype.getUTCMonth ( )</h3>
<pre><code>1. t は、this 時間の値とする
    2. t が、NaN である場合、 NaN を返す
    3. MonthFromTime(t) を返す
</code></pre><h3 id="15-9-5-14-date-prototype-getdate-">15.9.5.14 Date.prototype.getDate ( )</h3>
<pre><code>1. t は、this 時間の値とする
    2. t が、NaN である場合、 NaN を返す
    3. DateFromTime(LocalTime(t)) を返す
</code></pre><h3 id="15-9-5-15-date-prototype-getutcdate-">15.9.5.15 Date.prototype.getUTCDate ( )</h3>
<pre><code>1. t は、this 時間の値とする
    2. t が、NaN である場合、 NaN を返す
    3. DateFromTime(t) を返す
</code></pre><h3 id="15-9-5-16-date-prototype-getday-">15.9.5.16 Date.prototype.getDay ( )</h3>
<pre><code>1. t は、this 時間の値とする
    2. t が、NaN である場合、 NaN を返す
    3. WeekDay(LocalTime(t)) を返す
</code></pre><h3 id="15-9-5-17-date-prototype-getutcday-">15.9.5.17 Date.prototype.getUTCDay ( )</h3>
<pre><code>1. t は、this 時間の値とする
    2. t が、NaN である場合、 NaN を返す
    3. WeekDay(t) を返す
</code></pre><h3 id="15-9-5-18-date-prototype-gethours-">15.9.5.18 Date.prototype.getHours ( )</h3>
<pre><code>1. t は、this 時間の値とする
    2. t が、NaN である場合、 NaN を返す
    3. HourFromTime(LocalTime(t)) を返す
</code></pre><h3 id="15-9-5-19-date-prototype-getutchours-">15.9.5.19 Date.prototype.getUTCHours ( )</h3>
<pre><code>1. t は、this 時間の値とする
    2. t が、NaN である場合、 NaN を返す
    3. HourFromTime(t) を返す
</code></pre><h3 id="15-9-5-20-date-prototype-getminutes-">15.9.5.20 Date.prototype.getMinutes ( )</h3>
<pre><code>1. t は、this 時間の値とする
    2. t が、NaN である場合、 NaN を返す
    3. MinFromTime(LocalTime(t)) を返す
</code></pre><h3 id="15-9-5-21-date-prototype-getutcminutes-">15.9.5.21 Date.prototype.getUTCMinutes ( )</h3>
<pre><code>1. t は、this 時間の値とする
    2. t が、NaN である場合、 NaN を返す
    3. MinFromTime(t) を返す
</code></pre><h3 id="15-9-5-22-date-prototype-getseconds-">15.9.5.22 Date.prototype.getSeconds ( )</h3>
<pre><code>1. t は、this 時間の値とする
    2. t が、NaN である場合、 NaN を返す
    3. SecFromTime(LocalTime(t)) を返す
</code></pre><h3 id="15-9-5-23-date-prototype-getutcseconds-">15.9.5.23 Date.prototype.getUTCSeconds ( )</h3>
<pre><code>1. t は、this 時間の値とする
    2. t が、NaN である場合、 NaN を返す
    3. SecFromTime(t) を返す
</code></pre><h3 id="15-9-5-24-date-prototype-getmilliseconds-">15.9.5.24 Date.prototype.getMilliseconds ( )</h3>
<pre><code>1. t は、this 時間の値とする
    2. t が、NaN である場合、 NaN を返す
    3. msFromTime(LocalTime(t)) を返す
</code></pre><h3 id="15-9-5-25-date-prototype-getutcmilliseconds-">15.9.5.25 Date.prototype.getUTCMilliseconds ( )</h3>
<pre><code>1. t は、this 時間の値とする
    2. t が、NaN である場合、 NaN を返す
    3. msFromTime(t) を返す
</code></pre><h3 id="15-9-5-26-date-prototype-gettimezoneoffset-">15.9.5.26 Date.prototype.getTimezoneOffset ( )</h3>
    <p>　分単位でローカルタイムとUTC時間の相違を返します。</p>
<pre><code>1. t は、this 時間の値とする
    2. t が、NaN である場合、 NaN を返す
    3. (t - LocalTime(t)) / msPerMinute を返す
</code></pre><h3 id="15-9-5-27-date-prototype-settime-time-">15.9.5.27 Date.prototype.setTime (time)</h3>
<pre><code>1. v は、 TimeClip(ToNumber(time)) とする
    2. this Dateオブジェクトの内部プロパティ[[PrimitiveValue]]に v を設定する
    3. v を返す
</code></pre><h3 id="15-9-5-28-date-prototype-setmilliseconds-ms-">15.9.5.28 Date.prototype.setMilliseconds (ms)</h3>
<pre><code>1. t は、 LocalTime(this time value) の結果とする
    2. time は、 MakeTime(HourFromTime(t), MinFromTime(t), SecFromTime(t), ToNumber(ms)) とする
    3. u は、 TimeClip(UTC(MakeDate(Day(t), time))) とする
    4. this Dateオブジェクトの内部プロパティ[[PrimitiveValue]]に u を設定する
    5. u を返す
</code></pre><h3 id="15-9-5-29-date-prototype-setutcmilliseconds-ms-">15.9.5.29 Date.prototype.setUTCMilliseconds (ms)</h3>
<pre><code>1. t は、this 時間の値とする
    2. time は、 MakeTime(HourFromTime(t), MinFromTime(t), SecFromTime(t), ToNumber(ms)) とする
    3. v は、 TimeClip(MakeDate(Day(t), time)) とする
    4. this Dateオブジェクトの内部プロパティ[[PrimitiveValue]]に v を設定する
    5. v を返す
</code></pre><h3 id="15-9-5-30-date-prototype-setseconds-sec-ms-">15.9.5.30 Date.prototype.setSeconds (sec [, ms ] )</h3>
    <p>　 ms が指定されない場合、これは、値 getMilliseconds() を伴って指定された ms であるかのように動作します。</p>
<pre><code>1. t は、 LocalTime(this time value) の結果とする
    2. s は、 ToNumber(sec) とする
    3. ms が指定されない場合、 milli は、 msFromTime(t) とし、それ以外の場合、 milli は、 ToNumber(ms) とする
    4. date は、 MakeDate(Day(t), MakeTime(HourFromTime(t), MinFromTime(t), s, milli)) とする
    5. u は、 TimeClip(UTC(date)) とする
    6. this Dateオブジェクトの内部プロパティ[[PrimitiveValue]]に u を設定する
    7. u を返す
</code></pre><p>　 setSecondsメソッドのlengthプロパティは、2です。</p>
    <h3 id="15-9-5-31-date-prototype-setutcseconds-sec-ms-">15.9.5.31 Date.prototype.setUTCSeconds (sec [, ms ] )</h3>
    <p>　 ms が指定されない場合、これは、値 getUTCMilliseconds() を伴って指定された ms であるかのように動作します。</p>
<pre><code>1. t は、this 時間の値とする
    2. s は、 ToNumber(sec) とする
    3. ms が指定されない場合、 milli は、 msFromTime(t) とし、それ以外の場合、 milli は、 ToNumber(ms) とする
    4. date は、 MakeDate(Day(t), MakeTime(HourFromTime(t), MinFromTime(t), s, milli)) とする
    5. v は、 TimeClip(date) とする
    6. this Dateオブジェクトの内部プロパティ[[PrimitiveValue]]に v を設定する
    7. v を返す
</code></pre><p>　 setUTCSecondsメソッドのlengthプロパティは、2です。</p>
    <h3 id="15-9-5-32-date-prototype-setminutes-min-sec-ms-">15.9.5.32 Date.prototype.setMinutes (min [, sec [, ms ] ] )</h3>
    <p>　 sec が指定されない場合、これは、値 getSeconds() を伴って指定された sec であるかのように動作します。</p>
    <p>　 ms が指定されない場合、これは、値 getMilliseconds() を伴って指定された ms であるかのように動作します。</p>
<pre><code>1. t は、 LocalTime(this time value) の結果とする
    2. m は、 ToNumber(min) とする
    3. sec が、指定されない場合、 s は、 SecFromTime(t) とし、それ以外の場合、s は、 ToNumber(sec) とする
    4. ms が、指定されない場合、 milli は、 msFromTime(t) とし、それ以外の場合、milliは、 ToNumber(ms) とする
    5. date は、 MakeDate(Day(t), MakeTime(HourFromTime(t), m, s, milli)) とする
    6. u は、 TimeClip(UTC(date)) とする
    7. this Dateオブジェクトの内部プロパティ[[PrimitiveValue]]に u を設定する
    8. u を返す
</code></pre><p>　 setMinutesメソッドのlengthプロパティは、3です。</p>
    <h3 id="15-9-5-33-date-prototype-setutcminutes-min-sec-ms-">15.9.5.33 Date.prototype.setUTCMinutes (min [, sec [, ms ] ] )</h3>
    <p>　 sec が指定されない場合、これは、値 getUTCSeconds() を伴って指定された sec であるかのように動作します。</p>
    <p>　 ms が指定されない場合、これは、値 getUTCMilliseconds() を伴って指定された ms であるかのように動作します。</p>
<pre><code>1. t は、 LocalTime(this time value) の結果とする
    2. m は、 ToNumber(min) とする
    3. sec が、指定されない場合、 s は、 SecFromTime(t) とし、それ以外の場合、s は、 ToNumber(sec) とする
    4. ms が、指定されない場合、 milli は、 msFromTime(t) とし、それ以外の場合、milliは、 ToNumber(ms) とする
    5. date は、 MakeDate(Day(t), MakeTime(HourFromTime(t), m, s, milli)) とする
    6. v は、 TimeClip(date) とする
    7. this Dateオブジェクトの内部プロパティ[[PrimitiveValue]]に v を設定する
    8. v を返す
</code></pre><p>　 setUTCMinutesメソッドのlengthプロパティは、3です。</p>
    <h3 id="15-9-5-34-date-prototype-sethours-hour-min-sec-ms-">15.9.5.34 Date.prototype.setHours (hour [, min [, sec [, ms ] ] ] )</h3>
    <p>　 min が指定されない場合、これは、値 getMinutes() を伴って指定された min であるかのように動作します。</p>
    <p>　 sec が指定されない場合、これは、値 getSeconds() を伴って指定された sec であるかのように動作します。</p>
    <p>　 ms が指定されない場合、これは、値 getMilliseconds() を伴って指定された ms であるかのように動作します。</p>
<pre><code>1. t は、 LocalTime(this time value) の結果とする
    2. h は、 ToNumber(hour) とする
    3. min が、指定されない場合、 m は、 MinFromTime(t) とし、それ以外の場合、 m は、 ToNumber(min) とする
    4. sec が、指定されない場合、 s は、 SecFromTime(t) とし、それ以外の場合、 s は、 ToNumber(sec) とする
    5. ms が、指定されない場合、 milli は、 msFromTime(t) とし、それ以外の場合、 milli は、 ToNumber(ms) とする
    6. date は、 MakeDate(Day(t), MakeTime(h, m, s, milli)) とする
    7. u は、 TimeClip(UTC(date)) とする
    8. this Dateオブジェクトの内部プロパティ[[PrimitiveValue]]に u を設定する
    9. u を返す
</code></pre><p>　 setHoursメソッドのlengthプロパティは、4です。</p>
    <h3 id="15-9-5-35-date-prototype-setutchours-hour-min-sec-ms-">15.9.5.35 Date.prototype.setUTCHours (hour [, min [, sec [, ms ] ] ] )</h3>
    <p>　 min が指定されない場合、これは、値 getUTCMinutes() を伴って指定された min であるかのように動作します。</p>
    <p>　 sec が指定されない場合、これは、値 getUTCSeconds() を伴って指定された sec であるかのように動作します。</p>
    <p>　 ms が指定されない場合、これは、値 getUTCMilliseconds() を伴って指定された ms であるかのように動作します。</p>
<pre><code>1. t は、this 時間の値とする
    2. h は、 ToNumber(hour) とする
    3. min が、指定されない場合、 m は、 MinFromTime(t) とし、それ以外の場合、 m は、 ToNumber(min) とする
    4. sec が、指定されない場合、 s は、 SecFromTime(t) とし、それ以外の場合、 s は、 ToNumber(sec) とする
    5. ms が、指定されない場合、 milli は、 msFromTime(t) とし、それ以外の場合、 milli は、 ToNumber(ms) とする
    6. newDate は、 MakeDate(Day(t), MakeTime(h, m, s, milli)) とする
    7. v は、 TimeClip(newDate) とする
    8. this Dateオブジェクトの内部プロパティ[[PrimitiveValue]]に v を設定する
    9. v を返す
</code></pre><p>　 setUTCHoursメソッドのlengthプロパティは、4です。</p>
    <h3 id="15-9-5-36-date-prototype-setdate-date-">15.9.5.36 Date.prototype.setDate (date)</h3>
<pre><code>1. t は、 LocalTime(this time value) の結果とする
    2. dt は、 ToNumber(date) とする
    3. newDate は、 MakeDate(MakeDay(YearFromTime(t), MonthFromTime(t), dt), TimeWithinDay(t)) とする
    4. u は、 TimeClip(UTC(newDate)) とする
    5. this Dateオブジェクトの内部プロパティ[[PrimitiveValue]]に u を設定する
    6. u を返す
</code></pre><h3 id="15-9-5-37-date-prototype-setutcdate-date-">15.9.5.37 Date.prototype.setUTCDate (date)</h3>
<pre><code>1. t は、this 時間の値とする
    2. dt は、 ToNumber(date) とする
    3. newDate は、 MakeDate(MakeDay(YearFromTime(t), MonthFromTime(t), dt), TimeWithinDay(t)) とする
    4. v は、 TimeClip(newDate) とする
    5. this Dateオブジェクトの内部プロパティ[[PrimitiveValue]]に v を設定する
    6. v を返す
</code></pre><h3 id="15-9-5-38-date-prototype-setmonth-month-date-">15.9.5.38 Date.prototype.setMonth (month [, date ] )</h3>
    <p>　 date が指定されない場合、これは、値 getDate() を伴って指定された date であるかのように動作します。</p>
<pre><code>1. t は、 LocalTime(this time value) の結果とする
    2. m は、 ToNumber(month) とする
    3. date が指定されない場合、 dt は、 DateFromTime(t) とし、それ以外の場合、 dt は、 ToNumber(date) とする
    4. newDate は、 MakeDate(MakeDay(YearFromTime(t), m, dt), TimeWithinDay(t)) とする
    5. u は、 TimeClip(UTC(newDate)) とする
    6. this Dateオブジェクトの内部プロパティ[[PrimitiveValue]]に u を設定する
    7. u を返す
</code></pre><p>　 setMonthメソッドのlengthプロパティは、2です。</p>
    <h3 id="15-9-5-39-date-prototype-setutcmonth-month-date-">15.9.5.39 Date.prototype.setUTCMonth (month [, date ] )</h3>
    <p>　 date が指定されない場合、これは、値 getUTCDate() を伴って指定された date であるかのように動作します。</p>
<pre><code>1. t は、this 時間の値とする
    2. m は、 ToNumber(month) とする
    3. date が、指定されない場合、 dt は、 DateFromTime(t) とし、それ以外の場合、 dt は、 ToNumber(date) とする
    4. newDate は、 MakeDate(MakeDay(YearFromTime(t), m, dt), TimeWithinDay(t)) とする
    5. v は、 TimeClip(newDate) とする
    6. this Dateオブジェクトの内部プロパティ[[PrimitiveValue]]に v を設定する
    7. v を返す
</code></pre><p>　 setUTCMonthメソッドのlengthプロパティは、2です。</p>
    <h3 id="15-9-5-40-date-prototype-setfullyear-year-month-date-">15.9.5.40 Date.prototype.setFullYear (year [, month [, date ] ] )</h3>
    <p>　 month が指定されない場合、これは、値 getMonth() を伴って指定された month であるかのように動作します。</p>
    <p>　 date が指定されない場合、これは、値 getDate() を伴って指定された date であるかのように動作します。</p>
<pre><code>1. t は、 LocalTime(this time value) の結果とするが、this 時間の値が、 NaN である場合には、 t は、 +0 とする
    2. y は、 ToNumber(year) とする
    3. month が、指定されない場合、 m は、MonthFromTime(t) とし、 それ以外の場合、 m は、 ToNumber(month) とする
    4. date が、指定されない場合、dt は、DateFromTime(t) とし、 それ以外の場合、dt は、 ToNumber(date) とする
    5. newDate は、 MakeDate(MakeDay(y, m, dt), TimeWithinDay(t)) とする
    6. u は、 TimeClip(UTC(newDate)) とする
    7. this Dateオブジェクトの内部プロパティ[[PrimitiveValue]]に u を設定する
    8. u を返す
</code></pre><p>　 setFullYearメソッドのlengthプロパティは、3です。</p>
    <h3 id="15-9-5-41-date-prototype-setutcfullyear-year-month-date-">15.9.5.41 Date.prototype.setUTCFullYear (year [, month [, date ] ] )</h3>
    <p>　 month が指定されない場合、これは、値 getUTCMonth() を伴って指定された month であるかのように動作します。</p>
    <p>　 date が指定されない場合、これは、値 getUTCDate() を伴って指定された date であるかのように動作します。</p>
<pre><code>1. t は、this 時間の値とするが、this 時間の値が、NaN である場合、t は、 +0 とする
    2. y は、 ToNumber(year) とする
    3. month が、指定されない場合、 m は、 MonthFromTime(t) とし、それ以外の場合、 m は、 ToNumber(month) とする
    4. date が、指定されない場合、 dt は、 DateFromTime(t) とし、それ以外の場合、dt は、 ToNumber(date) とする
    5. newDate は、 MakeDate(MakeDay(y, m, dt), TimeWithinDay(t)) とする
    6. v は、 TimeClip(newDate) とする
    7. this Dateオブジェクトの内部プロパティ[[PrimitiveValue]]に v を設定する
    8. v を返す
</code></pre><p>　 setUTCFullYearメソッドのlengthプロパティは、3です。</p>
    <h3 id="15-9-5-42-date-prototype-toutcstring-">15.9.5.42 Date.prototype.toUTCString ( )</h3>
    <p>　この関数は、文字列値を返します。 文字列の内容については、実装依存ですが、UTCにおける利便性が高く、人間が読み取り可能な書式で日付を表現することが意図されます。</p>
    <p>[注釈]</p>
    <p>　その意図は、 15.9.1.15. で指定した書式よりも可読性の高い日付の文字列表現を生成することにあります。 曖昧さがないようにするとか、より容易に機械解析可能とする書式を選択するといったような必要があるわけではありません。 実装が、優先する人間が読み取り可能な書式を持っていない場合には、 15.9.1.15 で定義した書式を使用することが推奨されますが、(この場合、)日付と時刻の要素を分割する為に使用した“T”ではなく、空白を伴います。</p>
    <h3 id="15-9-5-43-date-prototype-toisostring-">15.9.5.43 Date.prototype.toISOString ( )</h3>
    <p>　この関数は、Dateオブジェクトによって表した時間内でのインスタンスを表す文字列値を返します。 文字列の書式は、 15.9.1.15. で定義した日付時刻の文字列書式です。 全ての項目は、その文字列内に存在します。 タイムゾーン(時間帯)は、常に UTC であり、接尾辞 Z で表されます。 this オブジェクトの時間の値が、有限のNumberではない場合、RangeError例外が投げられ(スローされ)ます。</p>
    <h3 id="15-9-5-44-date-prototype-tojson-key-">15.9.5.44 Date.prototype.toJSON ( key )</h3>
    <p>　この関数は、 JSON.stringify (15.12.3)によって使用する為にDateオブジェクトの文字列表現を提供します。</p>
    <p>　 toJSONメソッドが、引数 key を伴って呼ばれる際には、次のステップが取られます。</p>
<pre><code>1. O は、その引数として this 値をそれに与え、 ToObject を呼んだ結果とする
    2. tv は、 ToPrimitive(O, hint Number) とする
    3. tv が、Numberで且つ、有限ではない場合、 null を返す
    4. toISO は、引数&quot;toISOString&quot;を伴う O の内部メソッド[[Get]]を呼んだ結果とする
    5. IsCallable(toISO) が、 false である場合、TypeError例外を投げる(スローする)
    6. this 値として O と カラの引数リストを伴う toISO の内部メソッド[[Call]]を呼んだ結果を返す
</code></pre><p>[注釈 1]</p>
    <p>　その引数は無視されます。</p>
    <p>[注釈 2]</p>
    <p>　 toJSON 関数は、汎用的であることが意図され、this 値をDateオブジェクトとすることを要求しません。 その為、メソッドとしての使用においては、オブジェクトの他の種類に転送することが可能です。 しかしながら、そのようなオブジェクトは、 toISOString メソッドを持つことを要求します。 オブジェクトが、その文字列化をフィルタする為に引数 key を使用することは自由です。</p>
    <h2 id="15-9-6-date-properties-of-date-instances-standard-ecma-262-5-1-edition">15.9.6 Date インスタンスのプロパティ / Properties of Date Instances / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="15-ecmascript-">15 標準組み込みECMAScriptオブジェクト</h3>
    <h3 id="15-9-date-">15.9 Date オブジェクト</h3>
    <h3 id="15-9-6-date-">15.9.6 Date インスタンスのプロパティ</h3>
    <p>　 Dateインスタンスは、Dateプロトタイプオブジェクトと値が、“Date”であるそれらの内部プロパティ[[Class]]からプロパティを継承します。 Dateインスタンスはまた、内部プロパティ[[PrimitiveValue]]も持ちます。 内部プロパティ[[PrimitiveValue]]は、このDateオブジェクトによって表した時間の値です。</p>
    <h2 id="15-10-regexp-regexp-regular-expression-objects-standard-ecma-262-5-1-edition">15.10 RegExp (正規表現)オブジェクト / RegExp (Regular Expression) Objects / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="15-ecmascript-">15 標準組み込みECMAScriptオブジェクト</h3>
    <h3 id="15-10-regexp-regular-expression-">15.10 RegExp (Regular Expression／正規表現) オブジェクト</h3>
    <p>　 RegExpオブジェクトは、正規表現とその関連付けたフラグを含みます。</p>
    <p>[注釈]</p>
    <p>　正規表現の書式と機能は、プログラミング言語 Perl 5 にある正規表現機能を元にモデル化されています。</p>
    <p>– 15.10.2.1 表記法</p>
    <p>– 15.10.2.2 パターン</p>
    <p>– 15.10.2.3 論理和</p>
    <p>– 15.10.2.4 選択肢</p>
    <p>– 15.10.2.5 用語</p>
    <p>– 15.10.2.6 アサーション</p>
    <p>– 15.10.2.7 量指定子</p>
    <p>– 15.10.2.8 Atom</p>
    <p>– 15.10.2.9 AtomEscape</p>
    <p>– 15.10.2.10 CharacterEscape</p>
    <p>– 15.10.2.11 DecimalEscape</p>
    <p>– 15.10.2.12 CharacterClassEscape</p>
    <p>– 15.10.2.13 CharacterClass</p>
    <p>– 15.10.2.14 ClassRanges</p>
    <p>– 15.10.2.15 NonemptyClassRanges</p>
    <p>– 15.10.2.16 NonemptyClassRangesNoDash</p>
    <p>– 15.10.2.17 ClassAtom</p>
    <p>– 15.10.2.18 ClassAtomNoDash</p>
    <p>– 15.10.2.19 ClassEscape</p>
    <p>– 15.10.3.1 RegExp(pattern, flags)</p>
    <p>– 15.10.4.1 new RegExp(pattern, flags)</p>
    <p>– 15.10.5.1 RegExp.prototype</p>
    <p>– 15.10.6.1 RegExp.prototype.constructor</p>
    <p>– 15.10.6.2 RegExp.prototype.exec(string)</p>
    <p>– 15.10.6.3 RegExp.prototype.test(string)</p>
    <p>– 15.10.6.4 RegExp.prototype.toString()</p>
    <p>– 15.10.7.1 source</p>
    <p>– 15.10.7.2 global</p>
    <p>– 15.10.7.3 ignoreCase</p>
    <p>– 15.10.7.4 multiline</p>
    <p>– 15.10.7.5 lastIndex</p>
    <h2 id="15-10-1-patterns-standard-ecma-262-5-1-edition">15.10.1 パターン / Patterns / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="15-ecmascript-">15 標準組み込みECMAScriptオブジェクト</h3>
    <h3 id="15-10-regexp-regular-expression-">15.10 RegExp (Regular Expression／正規表現) オブジェクト</h3>
    <h3 id="15-10-1-">15.10.1 パターン</h3>
    <p>　RegExpコンストラクタは、パターン文字列について次の文法を適用します。 文法が、パターンの式として文字列を解釈できない場合、エラーが発生します。</p>
<pre><code>【構文】
    Pattern ::
    Disjunction

    Disjunction ::
    Alternative
    Alternative | Disjunction

    Alternative ::
    [empty]
    Alternative Term

    Term ::
    Assertion
    Atom
    Atom Quantifier

    Assertion ::
    ^
    $
    \ b
    \ B
    ( ? = Disjunction )
    ( ? ! Disjunction )

    Quantifier ::
    QuantifierPrefix
    QuantifierPrefix ?

    QuantifierPrefix ::
    *
    +
    ?
    { DecimalDigits }
    { DecimalDigits , }
    { DecimalDigits , DecimalDigits }

    Atom ::
    PatternCharacter
    .
    \ AtomEscape
    CharacterClass
    ( Disjunction )
    ( ? : Disjunction )

    PatternCharacter ::
    SourceCharacter

    ^ $ \ . * + ? ( ) [ ] { } |

    以外

    AtomEscape ::
    DecimalEscape
    CharacterEscape
    CharacterClassEscape

    CharacterEscape ::
    ControlEscape
    c ControlLetter
    HexEscapeSequence
    UnicodeEscapeSequence
    IdentityEscape

    ControlEscape ::
    f n r t v
    の内の1つ

    ControlLetter ::
    a b c d e f g h i j k l m n o p q r s t u v w x y z
    A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
    の内の1つ

    IdentityEscape ::
    SourceCharacterであってIdentifierPartでない
    &lt;ZWJ&gt;
    &lt;ZWNJ&gt;


    DecimalEscape ::
    DecimalIntegerLiteral [lookahead ? DecimalDigit]
    ( ?部は、 ∈の否定文字)
    CharacterClassEscape ::
    d D s S w W
    の内の1つ

    CharacterClass ::
    [ [lookahead ? {^}] ClassRanges ]
    ( ?部は、 ∈の否定文字)
    [ ^ ClassRanges ]

    ClassRanges ::
    [empty]
    NonemptyClassRanges

    NonemptyClassRanges ::
    ClassAtom
    ClassAtom NonemptyClassRangesNoDash
    ClassAtom - ClassAtom ClassRanges

    NonemptyClassRangesNoDash ::
    ClassAtom
    ClassAtomNoDash NonemptyClassRangesNoDash
    ClassAtomNoDash - ClassAtom ClassRanges

    ClassAtom ::
    -
    ClassAtomNoDash

    ClassAtomNoDash ::
    \ (バックスラッシュ)、] (右角ブラケット)、- (ハイフン)ではない SourceCharacter
    \ ClassEscape

    ClassEscape ::
    DecimalEscape
    b
    CharacterEscape
    CharacterClassEscape
</code></pre><h2 id="15-10-2-pattern-semantics-standard-ecma-262-5-1-edition">15.10.2 パターンのセマンティックス / Pattern Semantics / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="15-ecmascript-">15 標準組み込みECMAScriptオブジェクト</h3>
    <h3 id="15-10-regexp-regular-expression-">15.10 RegExp (Regular Expression／正規表現) オブジェクト</h3>
    <h3 id="15-10-2-">15.10.2 パターンのセマンティックス</h3>
    <p>　正規表現のパターンは、以下で説明したプロセスを使って内部プロシージャに変換されます。 実装は、結果が同じ長さになるように以下に挙げた内の1つより効率的なアルゴリズムを使用することが奨励されます。 内部プロシージャは、RegExpオブジェクトの内部プロパティ[[Match]]の値として使用されます。</p>
<pre><code>プロシージャとは、(一連の)手続き(を行う関数、メソッド等)
</code></pre><h3 id="15-10-2-1-notation-">15.10.2.1 Notation / 表記法</h3>
    <p>　以下の説明では、次の変数を使用します。</p>
<pre><code>・入力は、正規表現のパターンによってマッチした文字列とする。
    ・表記法 input[n] は、n が0(内包的)とInputLength(排他的)の範囲とすることができる場合、入力の n 番めの文字を意味するものとする。
    ・InputLengthは、入力文字列内の文字数とする。
    ・NcapturingParensは、パターン内で(例えば、 Atom :: ( Disjunction ) プロダクションが拡張される回数の総数のように)キャプチャしたカッコの左かっこの総数であるものとする。
    ・キャプチャしたカッコの左かっこは、 Atom :: ( Disjunction ) プロダクションの ( ターミナルによってマッチされる( というパターン文字であるものとする。
    ・IgnoreCaseは、RegExpオブジェクトのignoreCaseプロパティを設定することであるものとする。
    ・Multilineは、RegExpオブジェクトのmultilineプロパティを設定することであるものとする。
</code></pre><p>　更に、以下の説明は、次の内部データ構造を使用します。</p>
<pre><code>・任意のCharSetは、数学的な文字の集合とする。
    ・任意のStateは、endIndexが整数、且つ、capturesがNcapturingParens値の内部配列である場合において指定したペア(endIndex, captures)とする。
    　 Statesは、正規表現のマッチングアルゴリズム内で特定のマッチする状態を表す為に使用されるものとする。
    　 endIndexは、 captures がキャプチャしたカッコの結果を保持する場合、そのパターンによってそれまでマッチしていた最後の入力文字のインデックスに1を加えるものとする。
    　 captures の n 番めの要素は、キャプチャしたカッコの n 番めのセットによって得られた値を表す文字列か、または、キャプチャするカッコの n 番めのセットに、まだ到達していない場合のundefinedの何れかであるものとする。
    　バックトラッキングの為、多くのStatesが、マッチング処理中に(任意の時点で)使用されている場合もあるものとする。
    ・ MatchResultは、State、または、マッチに失敗したことを示す特殊なトークン(字句)である failure の何れかであるものとする。
    ・ Continuationプロシージャは、内部クロージャ(例えば、既に値にバインドされている任意の引数を伴う内部プロシージャ)は、1つのState引数を取り、MatchResultの結果を返すものとする。

    内部クロージャは、当該クロージャを生成する関数内でバインドされる変数を参照し、当該クロージャは、クロージャが生成された時点でこれらの変数を使用するものとする。
    中間の状態で始まる入力文字列に対するパターンの(クロージャの既にバインドされている引数によって指定した)残りの部分をマッチする為のContinuationの試行は、そのState引数によって与えられるものとする。
    マッチが成功した場合、そのContinuationは、それが到達した最後のStateを返し、マッチが失敗した場合には、そのContinuationは、failureを返すものとする。

    ・Matcherプロシージャは、1つの State と 1つの Continuation の2つを引数に取り、MatchResultの結果を返す内部クロージャであるものとする。
    中間の状態で始まる入力文字列に対するパターンの(クロージャの既にバインドされている引数によって指定した)中間のサブパターンとのマッチの為のMatcherの試行は、そのState引数によって与えられるものとする。
    Continuation引数は、当該パターンの残りにマッチするクロージャとすべきものとする。
    新たなStateを取得する為、パターンのサブパターンとのマッチング後、そのMatcherは、パターンの残りがうまくマッチする場合、テストする為に新たなState上でContinuationを呼ぶものとする。
    可能であれば、当該Matcherは、Continuationによって返したStateを返すものとし、不可能であれば、Matcher は、成功か、全ての可能性を使いきるかの何れかになるまで繰り返しContinuationを呼び、その選択ポイントで異なる選択を試す場合もあるものとする。

    ・AssertionTesterプロシージャは、State引数を取り、Booleanの結果を返す内部クロージャとする。
    アサーションテスターは、入力文字列内の現在の場所に対して(クロージャの既にバインドされている引数によって指定した)仕様上の条件をテストし、条件にマッチする場合、true、そうではない場合、falseを返すものとする。

    ・EscapeValueは、1つの文字か、1つの整数であるものとする。
    EscapeValueは、エスケープシーケンス DecimalEscape として解釈する表記法の為に使用されるものとする。
    整数 n が、キャプチャしたカッコの n 番めのセットへの後方参照として解釈されるエスケープシーケンスを意味する場合、文字 ch が、文字 ch として解釈されるエスケープシーケンスという意味であるものとする。
</code></pre><h3 id="15-10-2-2-pattern-">15.10.2.2 Pattern / パターン</h3>
    <p>　プロダクション Pattern :: Disjunction は、次のように評価します。</p>
<pre><code>1. Matcher m を取得する為、 Disjunction を評価する
    2.文字列 str と 整数 index という2つの引数を取り、次を実行する内部クロージャを返す
    1. Input には、文字列 str を与えるものとする
    この変数は、 15.10.2 にあるアルゴリズムを介して利用されるものとする
    2. InputLength は、Input の長さとする
    この変数は、 15.10.2 にあるアルゴリズムを介して利用されるものとする
    3. c は、MatchResultが成功したものとして当該State引数を常に返すContinuationとする
    4. cap は、索引付けした1からNcapturingParensまでundefined値であるNcapturingParensの内部配列とする
    5. x は、 当該State (index, cap) とする
    6. m(x, c) を呼び、その結果を返す
</code></pre><p>[注釈]</p>
    <p>　パターンは、内部プロシージャの値について(“compiles”)を評価します。 RegExp.prototype.exec は、その後、文字列と当該パターンが確実に当該文字列内のオフセット位置にある開始点とマッチするかどうかを決める為の文字列内のオフセットを、更にマッチする場合、キャプチャするカッコの値にこのプロシージャを適用します。 パターンをコンパイルするように設計されている 15.10.2 にあるアルゴリズムは、SyntaxError例外を投げ(スローし)、他方で1度パターンがコンパイルに成功すると(メモリ不足(out-of-memory)のようなどこかで発生するホスト定義の例外である場合を除き、)例外を投げることができない文字列内でマッチを見つける為に内部プロシージャをその結果に適用します。</p>
    <h3 id="15-10-2-3-disjunction-">15.10.2.3 Disjunction / 論理和</h3>
    <p>　プロダクション Disjunction :: Alternative は、 Matcher と Matcher を返すことで得られる Alternative を評価します。</p>
    <p>　プロダクション Disjunction :: Alternative | Disjunction は、 次のように評価します。</p>
<pre><code>1. Matcher m1 を得る為に Alternative を評価
    2. Matcher m2 を得る為に Disjunction を評価
    3. 任意の State x と任意の Continuation c という2つの引数を取り、次を実行する内部 Matcher クロージャを返す
    1. m1(x, c) を呼び、r は、その結果とする
    2. r が、failureではない場合、r を返す
    3. m2(x, c) を呼び、その結果を返す
</code></pre><p>[注釈]</p>
    <p>　正規表現演算子 | は、2つの選択肢を分割します。 1つめのパターンは、(正規表現の続きにより続けられる)左側のAlternativeへのマッチングを試行し、失敗した場合、(正規表現の続きにより続けられる)右側のDisjunctionへのマッチングを試行します。 左側のAlternative、右側のDisjunction、その後半の全ては、選択点を持ち、後半にある全ての選択点は、左側のAlternativeにある次の選択肢に移動する前に試行されます。 左側のAlternativeにある選択肢を使いきった場合、左側のAlternativeの代わりに右側のDisjunctionが、試行されます。 \ | によってスキップしたパターンのキャプチャするカッコ内の部分は、文字列の代わりにundefined値を生成します。</p>
    <p>このように例えば、</p>
<pre><code>    /a|ab/.exec(&quot;abc&quot;)
</code></pre><p>は、“a”という結果を返すのであって“ab”を返すわけではありません。</p>
    <p>更に</p>
<pre><code>    /((a)|(ab))((c)|(bc))/.exec(&quot;abc&quot;)
</code></pre><p>は、配列</p>
<pre><code>    [&quot;abc&quot;, &quot;a&quot;, &quot;a&quot;, undefined, &quot;bc&quot;, undefined, &quot;bc&quot;]
</code></pre><p>を返すのであって</p>
<pre><code>    [&quot;abc&quot;, &quot;ab&quot;, undefined, &quot;ab&quot;, &quot;c&quot;, &quot;c&quot;, undefined]
</code></pre><p>を返すわけではありません。</p>
    <h3 id="15-10-2-4-alternative-">15.10.2.4 Alternative / 選択肢</h3>
    <p>　プロダクション Alternative :: [empty] は、 任意の State x と任意の Continuation c という2つの引数を取り、 c(x) を呼んだ結果を返す Matcher を実行することによって評価します。</p>
    <p>　プロダクション Alternative :: Alternative Term は、次のように評価します。</p>
<pre><code>1. Matcher m1 を取得する為に Alternative を評価
    2. Matcher m2 を取得する為に Term を評価
    3. 任意の State x と任意の Continuation c という2つの引数を取り、次を実行する内部 Matcher クロージャを返す
    1. 1つのState引数 y を取る Continuation d を生成し、 m2(y, c) を呼んだ結果を返す
    2. m1(x, d) を呼び、その結果を返す
</code></pre><p>[注釈]</p>
    <p>　連続した Terms は、入力文字列の連続的な部分と同時にマッチするように試行します。 左側の Alternative 、右側の Term 、正規表現の後半の全ては、選択点を持ち、後半の全ての選択肢は、右側の Term 内の次の選択肢に移動する前に試行され、右側の Term 内にある全ての選択点は、左側の Alternative 内にある次の選択点に移動する前に試行されます。</p>
    <h3 id="15-10-2-5-term-">15.10.2.5 Term / 用語</h3>
    <p>　プロダクション Term :: Assertion は、 任意の State x と任意の Continuation c という2つの引数を取り、次を実行する内部 Matcher クロージャを実行することによって評価します。</p>
<pre><code>1. AssertionTester t を取得する為に Assertion を評価
    2. t(x) を呼び、 r は、結果となるBoolean値とする
    3. r が、 falseである場合、 failure を返す
    4. c(x) を呼び、その結果を返す
</code></pre><p>　プロダクション Term :: Atom は、 Matcher とその Matcher を返すことによって得られる Atom を評価することによって評価します。</p>
    <p>　プロダクション Term :: Atom Quantifier は、次のように評価します。</p>
<pre><code>1. Matcher m を取得する為に Atom を評価
    2.整数 min、整数(または、∞) max、Boolean値 greedy という3つの結果を取得する為に Quantifier を評価
    3. max が有限、且つ、min より小さい場合、SyntaxError例外を投げる(スローする)
    4. parenIndex は、このプロダクションの拡張の Term の左側に現れる正規表現全体の中にあるキャプチャした左カッコの数とする
    これは、この Term を囲む Atom :: ( Disjunction ) プロダクションの総数を加えた、このプロダクションの Term に優先して Atom :: ( Disjunction ) プロダクションが拡張される回数の総数
    5. parenCount は、このプロダクションの Atom の拡張内でキャプチャした左カッコの数とする
    これは、このプロダクションの Atom によって囲まれた Atom :: ( Disjunction ) プロダクションの総数
    6.任意の State x と任意の Continuation c という2つの引数を取り、次を実行する内部 Matcher クロージャを返す
    1. RepeatMatcher(m, min, max, greedy, x, c, parenIndex, parenCount) を呼び、その結果を返す
</code></pre><p>　抽象操作 RepeatMatcher は、 Matcher m 、整数 min 、整数(または∞) max、Boolean値 greedy 、 State x 、 Continuation c 、整数 parenIndex 、整数 parenCount という8つのパラメータを取り、次を実行します。</p>
<pre><code>1. max がゼロである場合、 c(x) を呼び、その結果を返す
    2. State 引数 y を1つ取り、内部 Continuation クロージャ d を生成し、次を実行する
    1. min がゼロ、且つ、y の endIndex が、x の endIndex と等しい場合、 failure を返す
    2. min がゼロである場合、 min2 は、ゼロとし、それ以外の場合、 min2 は、min-1 とする
    3. max が、∞である場合、 max2 は、∞とし、それ以外の場合、 max2 は、max-1 とする
    4. RepeatMatcher(m, min2, max2, greedy, y, c, parenIndex, parenCount) を呼び、その結果を返す
    3. cap は、 x のキャプチャ内部配列の最新のコピーとする
    4. parenIndex &lt; k 、且つ、 k ≦ parenIndex+parenCount を満たす整数 kごとに cap[k] に undefined を設定する
    5. e は、 x の endIndex とする
    6. xr は、State (e, cap) とする
    7. min が、ゼロである場合、 m(xr, d) を呼び、その結果を返す
    8. greedy が、 falseである場合、
    a. c(x) を呼び、 z は、その結果とする
    b. z が、 failureではない場合、z を返す
    c. m(xr, d) を呼び、その結果を返す
    9. m(xr, d) を呼び、z は、その結果とする
    10. z が、 failureではない場合、z を返す
    11. c(x) を呼び、その結果を返す
</code></pre><p>[注釈 1]</p>
    <p>　 Quantifier (量指定子)が続く Atom は、 Quantifier によって指定した回数の数字が表示されます。 当該 Atom パターンが、後半とマッチしている間、可能な限り、少数回繰り返す場合、 Quantifier は、非greedyとすることができますし、また、当該 Atom パターンが、後半とマッチしている間、可能な限り、多数回繰り返す場合、greedyとすることができます Atom パターンは、マッチする入力文字列以上に繰り返される為、 Atomの異なる反復では、入力部分文字列とマッチさせることが可能です。</p>
    <p>[注釈 2]</p>
    <p>　当該 Atom と正規表現全体の内の後半部分は、選択点を持ち、当該 Atom は、可能な限り多くの回数(非greedyの場合、数回)マッチさせる最初のものです。 後続の全ての選択肢は、 Atom の最後の反復内にある次の選択肢に移動する前に試行されます。 Atom の最後(n 番め)の反復内にある全ての選択肢は、現在利用可能な Atom の反復が多数回、または数回あることが判明する場合のある時点で Atom の(n-1 番め)の反復の次から最後までの st 内の次の選択肢に移動する前に試行されます。 これらは、 Atom の(n-1 番め)の反復 st にある次の選択肢に移動する前に使い果たされ(ますが、再び、可能な限り少数回または、多数回の何れかで開始し)、…等々。</p>
    <p>“abc”を返す</p>
<pre><code>    /a[a-z]{2,4}?/.exec(&quot;abcdefghi&quot;)
</code></pre><p>と“abcde”を返す</p>
<pre><code>    /a[a-z]{2,4}/.exec(&quot;abcdefghi&quot;)
</code></pre><p>を比較してみましょう</p>
    <p>この</p>
<pre><code>    /(aa|aabaac|ba|b|c)*/.exec(&quot;aabaac&quot;)
</code></pre><p>についても考えてみましょう。</p>
    <p>これは、上記の順番の選択点によって</p>
<pre><code>    [&quot;aabaac&quot;, &quot;aabaac&quot;]
    [&quot;aabaac&quot;, &quot;c&quot;]
</code></pre><p>の何れでもなく、 以下の配列を返します。</p>
<pre><code>    [&quot;aaba&quot;, &quot;ba&quot;]
</code></pre><p>　上記選択点の順は、(単項表記で表した)2つの数字の最大公約数となる正規表現を書く為に使用されることが可能です。</p>
    <p>　次の例は、10と15のgcd(greatest common divisor/最大公約数)を算出します。</p>
<pre><code>    &quot;aaaaaaaaaa,aaaaaaaaaaaaaaa&quot;.replace(/^(a+)\1*,\1+$/,&quot;$1&quot;)
</code></pre><p>　これは、単項表記“aaaaa”内のgcd(greatest common divisor/最大公約数)を返します。</p>
    <p>[注釈 3]</p>
    <p>　 RepeatMatcher のステップ4は、 Atom が繰り返される度ごとに Atom のキャプチャをクリアします。 以下の正規表現内でその動作を確認する(見る)ことができます。</p>
    <p>この正規表現</p>
<pre><code>    /(z)((a+)?(b+)?(c))*/.exec(&quot;zaacbbbcac&quot;)
</code></pre><p>は、以下ではなく、</p>
<pre><code>    [&quot;zaacbbbcac&quot;, &quot;z&quot;, &quot;ac&quot;, &quot;a&quot;, &quot;bbb&quot;, &quot;c&quot;]
</code></pre><p>以下の配列を返します。</p>
<pre><code>    [&quot;zaacbbbcac&quot;, &quot;z&quot;, &quot;ac&quot;, &quot;a&quot;, undefined, &quot;c&quot;]
</code></pre><p>　なぜなら、最も外側の * の各反復(イタレーション)は、定量化した Atom 内に含む全てのキャプチャ文字列をクリアするからであり、このケースでは、2,3,4,5と番号付けしたキャプチャ文字列を含みます。</p>
    <p>[注釈 4]</p>
    <p>　 RepeatMatcher の d クロージャのステップ1は、それ以上の反復が考えられないカラの文字列とマッチする Atom の多くの拡張を満たしている最小の反復数1回という状態です。 これは、以下のようなパターンにおいて正規表現エンジンが無限ループに陥ることを防止します。</p>
    <p>パターン</p>
<pre><code>    /(a*)*/.exec(&quot;b&quot;)
</code></pre><p>や若干より複雑な</p>
<pre><code>    /(a*)b\1+/.exec(&quot;baaaac&quot;)
</code></pre><p>は、</p>
<pre><code>    [&quot;b&quot;, &quot;&quot;]
</code></pre><p>という配列を返します。</p>
    <h3 id="15-10-2-6-assertion-">15.10.2.6 Assertion / アサーション</h3>
    <p>　プロダクション Assertion :: ^ は、任意の State 引数 x を取り、次を実行する内部 AssertionTester クロージャを返すことによって評価します。</p>
<pre><code>1. e は、 x の endIndex とする
    2. e が、ゼロである場合、 true を返す
    3. Multiline が、 falseである場合、 false を返す
    4.文字 Input[e-1] が、LineTerminator の1つである場合、 true を返す
    5. false を返す
</code></pre><p>　プロダクション Assertion :: $ は、任意の State 引数 x を取り、次を実行する内部 AssertionTester クロージャを返すことによって評価します。</p>
<pre><code>1. e は、 x の endIndex とする
    2. e が、InputLength と等しい場合、 true を返す
    3. multiline が、 falseである場合、 false を返す
    4.文字 Input[e] が、LineTerminator の1つである場合、 true を返す
    5. false を返す
</code></pre><p>　プロダクション Assertion :: \ b は、任意の State 引数 x を取り、次を実行する内部 AssertionTester クロージャを返すことによって評価します。</p>
<pre><code>1. e は、 x の endIndex とする
    2. IsWordChar(e-1) を呼び、 a は、Booleanの結果を返す
    3. IsWordChar(e) を呼び、  b は、Booleanの結果を返す
    4. a が、 true 、且つ b が、 falseである場合、 trueを返す
    5. a が、 false 、且つ b が、 trueである場合、 trueを返す
    6. false を返す
</code></pre><p>　プロダクション Assertion :: \ B は、任意の State 引数 x を取り、次を実行する内部 AssertionTester クロージャを返すことによって評価します。</p>
<pre><code>1. e は、 x の endIndex とする
    2. IsWordChar(e-1) を呼び、 a は、Booleanの結果を返す
    3. IsWordChar(e) を呼び、  b は、Booleanの結果を返す
    4. a が、 true 、且つ b が、 falseである場合、 falseを返す
    5. a が、 false 、且つ b が、 trueである場合、 falseを返す
    6. true を返す
</code></pre><p>　プロダクション Assertion :: ( ? = Disjunction ) は、次のように評価します。</p>
<pre><code>1. Matcher m を取得する為に Disjunction を評価
    2. 任意の State x と任意の Continuation c という2つの引数を取り、次のステップを実行する内部 Matcher クロージャを返す
    1. d は、成功したMatchResultのように当該Stateの引数を常に返すContinuationとする
    2. m(x, d) を呼び、 r は、その結果とする
    3. r が、 failure である場合、 failure を返す
    4. y は、 r の State とする
    5. cap は、 y の キャプチャ内部配列とする
    6. xe は、 x の endIndex とする
    7. z は、 State (xe, cap) とする
    8. c(z) を呼び、その結果を返す
</code></pre><p>　プロダクション Assertion :: ( ? ! Disjunction ) は、次のように評価します。</p>
<pre><code>1. Matcher m を取得する為に Disjunction を評価
    2.任意の State x と任意の Continuation c という2つの引数を取り、次のステップを実行する内部 Matcher クロージャを返す
    1. d は、成功したMatchResultのように当該Stateの引数を常に返すContinuationとする
    2. m(x, d) を呼び、 r は、その結果とする
    3. r が、 failure ではない場合、 failure を返す
    4. c(x) を呼び、 その結果を返す
</code></pre><p>　抽象操作 IsWordChar は、整数のパラメータ e を取り、次を実行します。</p>
<pre><code>1. e == -1 または、 e == InputLength である場合、 false を返す
    2. c は、文字 Input[e] とする
    3. c が、以下の63文字の内の1つである場合、 true を返す
    a b c d e f g h i j k l m n o p q r s t u v w x y z
    A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
    0 1 2 3 4 5 6 7 8 9 _
    4. false を返す
</code></pre><h3 id="15-10-2-7-quantifier-">15.10.2.7 Quantifier / 量指定子</h3>
    <p>　プロダクション Quantifier :: QuantifierPrefix は、次のように評価します。</p>
<pre><code>1.整数 min と整数 (または、 ∞) max という2つの結果を取得する為にQuantifierPrefixを評価
    2. min, max, trueという3つの結果を返す
</code></pre><p>　プロダクション Quantifier :: QuantifierPrefix ? は、次のように評価します。</p>
<pre><code>1.整数 min と整数 (または、 ∞) max という2つの結果を取得する為にQuantifierPrefixを評価
    2. min, max, falseという3つの結果を返す
</code></pre><p>　プロダクション QuantifierPrefix :: * は、 0 と ∞ という2つの結果を返す事によって評価します。</p>
    <p>　プロダクション QuantifierPrefix :: + は、 1 と ∞ という2つの結果を返す事によって評価します。</p>
    <p>　プロダクション QuantifierPrefix :: ? は、 0 と 1 という2つの結果を返す事によって評価します。</p>
    <p>　プロダクション QuantifierPrefix :: { DecimalDigits } は、次のように評価します。</p>
<pre><code>1. i は、DecimalDigits ( 7.8.3 参照)の MV とする
    2. i と i という2つの結果を返す
</code></pre><p>　プロダクション QuantifierPrefix :: { DecimalDigits , } は、次のように評価します。</p>
<pre><code>1. i は、DecimalDigits の MV とする
    2. i と ∞ という2つの結果を返す
</code></pre><p>　プロダクション QuantifierPrefix :: { DecimalDigits , DecimalDigits } は、次のように評価します。</p>
<pre><code>1. i は、1つめの DecimalDigits とする
    2. j は、2つめの DecimalDigits とする
    3. i と j という2つの結果を返す
</code></pre><h3 id="15-10-2-8-atom-">15.10.2.8 Atom / 原始</h3>
    <p>　プロダクション Atom :: PatternCharacter は、次のように評価します。</p>
<pre><code>1. ch は、PatternCharacter によって表した文字とする
    2. A は、文字 ch を含んでいる1つの要素(one-element) CharSet とする
    3. CharacterSetMatcher(A, false) を呼び、その Matcher の結果を返す
</code></pre><p>　プロダクション Atom :: . は、次のように評価します。</p>
<pre><code>1. A は、LineTerminator を除く全ての文字の集合とする
    2. CharacterSetMatcher(A, false) を呼び、その Matcher の結果を返す
</code></pre><p>　プロダクション Atom :: \ AtomEscape は、 Matcher と実行中のその Matcher を取得する為に評価中の AtomEscape を評価します。</p>
    <p>　プロダクション Atom :: CharacterClass は、次のように評価します。</p>
<pre><code>1. 任意の CharSet A と 任意の Booleanフラグinvert を取得する為にCharacterClassを評価
    2. CharacterSetMatcher(A, invert) を呼び、その Matcher の結果を返す
</code></pre><p>　プロダクション Atom :: ( Disjunction ) は、次のように評価します。</p>
<pre><code>1. Matcher m を取得する為にDisjunctionを評価
    2. parenIndex は、このプロダクションの拡張の初期の左カッコに現れる正規表現全体にあるキャプチャする左カッコの数とする
    これは、この Atom を囲む Atom :: ( Disjunction ) プロダクションの総数を加えた、このプロダクションの Atom に優先して Atom :: ( Disjunction ) プロダクションが、拡張される回数の総数
    3.任意の State x と任意の Continuation c という2つの引数を取り、次のステップを実行する内部 Matcher クロージャを返す
    1. 1つの State引数を取り、次のステップを実行する内部 Continuation クロージャ d を生成する
    1. cap は、y のキャプチャ内部配列の最新のコピーとする
    2. xe は、 x の endIndex とする
    3. ye は、 y の endIndex とする
    4. s は、 xe (を含む xe )から ye ( を含まない ye )までの位置にある Input の文字である文字列を持つ最新の文字列とする
    5. cap[parenIndex+1] に s を設定する
    6. z は、State (ye, cap) とする
    7. c(z) を呼び、その結果を返す
    2. m(x, d) を呼び、その結果を返す
</code></pre><p>　プロダクション Atom :: ( ? : Disjunction ) は、 Matcher と実行中のその Matcher を取得する為に評価中のDisjunctionを評価します。</p>
    <p>　抽象操作CharacterSetMatcherは、任意の CharSet A と任意のBooleanフラグinvertという2つの引数を取り、次を実行します。</p>
<pre><code>1.任意の State x と任意の Continuation c という2つの引数を取り、次のステップを実行する内部 Matcher クロージャを返す
    1. e は、 x の endIndex とする
    2. e == InputLength である場合、 failure を返す
    3. ch は、文字 Input[e] とする
    4. cc は、 Canonicalize(ch) の結果とする
    5. invert が、 falseである場合、
    a Canonicalize(a) == cc というような集合 A のメンバが存在しない場合、 failure を返す
    6.それ以外の場合、invert は、 true であり、
    a  Canonicalize(a) == cc というような集合 A のメンバが存在する場合、 failure を返す
    7. cap は、x のキャプチャ内部配列とする
    8. y は、 State (e+1, cap) とする
    9. c(y) を呼び、その結果を返す
</code></pre><p>　抽象操作 Canonicalize は、文字パラメータ ch を取り、次のステップを実行します。</p>
<pre><code>1. IgnoreCase が、 false である場合、 ch を返す
    2. u 1文字のString ch上で標準組み込みメソッド String.prototype.toUpperCase を呼んだかのように大文字に変換した ch とする
    3. u が、単一の文字で構成されていない場合、 ch を返す
    4. cu は、u の文字とする
    5. ch のコードユニット値が、10進数の128より大きいか等しく、且つ、cu のコードユニット値が、10進数の128より小さい場合、 ch を返す
    6. cu を返す
</code></pre><p>[注釈 1]</p>
    <p>　書式 ( Disjunction ) のカッコは、パターン Disjunction のコンポーネントを共にグループ化することとマッチした結果の保存の両方を提供します。 その結果は、置換文字列内で参照した、または、正規表現がマッチした内部プロシージャから得られた配列の一部として返した後方参照(非ゼロの10進数が続く\)内の何れかで使用されることが可能です。 カッコのキャプチャリング動作を抑制するには、代わりに書式 (?: Disjunction ) を使用します。</p>
    <p>[注釈 2]</p>
    <p>　書式 (?= Disjunction ) は、先読みするゼロ幅位置を指定します。 それを成功させる為には、パターンの内側の Disjunction は、現在の位置でマッチしなければいけませんが、現在の位置は、後半とマッチする前に進められることはありません。 Disjunction が、複数の方法で現在位置でマッチする場合、最初の1つだけが試行されます。 他の正規表現の演算子とは異なり、 (?= という書式にバックトラッキングはありません。(この一風変わった動作は、Perlから継承されます。) これは、Disjunctionが、キャプチャするカッコとそれらのキャプチャへの後方参照を含むパターンの後半を含む場合に限ったことです。</p>
    <p>例えば、</p>
<pre><code>    /(?=(a+))/.exec(&quot;baaabac&quot;)
</code></pre><p>は、1つめの b の直後のカラの文字列にマッチし、よって、その配列である</p>
<pre><code>    [&quot;&quot;, &quot;aaa&quot;]
</code></pre><p>を返し、先読みへのトラックバックの不足を例示する為に考慮すると、これは、</p>
<pre><code>    /(?=(a+))a*b\1/.exec(&quot;baaabac&quot;)
</code></pre><p>となり、この式は、</p>
<pre><code>    [&quot;aaaba&quot;, &quot;a&quot;]
</code></pre><p>ではなく、</p>
<pre><code>    [&quot;aba&quot;, &quot;a&quot;]
</code></pre><p>を返します。</p>
    <p>[注釈 3]</p>
    <p>　書式 (?! Disjunction ) は、ゼロ幅の負の先読みを指定します。 それを成功させる為には、パターンの内側の Disjunction が、現在位置でのマッチに失敗しなければいけません。 現在位置は、後半にマッチする前に進められることはありません。 Disjunctionは、キャプチャするカッコを含むことができますが、それらへの後方参照は、Disjunctionそれ自身の内部からのみ検出します。</p>
    <p>　パターン内の他の場所からこれらのキャプチャするカッコへの後方参照は、成功するパターンにおいて負の先読みが失敗しなければいけないということになるので常に undefined を返します。</p>
    <p>　例えば、</p>
<pre><code>    /(.*?)a(?!(a+)b\2c)\2(.*)/.exec(&quot;baaabaac&quot;)
</code></pre><p>は、 a の中で何らかの正の数字 n が直後に続かない a である a b 、(1つめの \2 によって指定した)他の n a、そして a c を探します。 2つめの \2 は、負の先読みの外側にある為、 undefined に対してマッチすることから常に成功します。</p>
    <p>　正規表現全体としては、配列</p>
<pre><code>    [&quot;baaabaac&quot;, &quot;ba&quot;, undefined, &quot;abaac&quot;]
</code></pre><p>を返します。</p>
    <p>　全ての文字にマッチする大文字小文字不問状態(case-insignificant)においては、それらが比較される前に暗黙のうちにすぐに大文字に変換されます。 しかしながら、大文字への文字変換中において(変換中の“s” (\u00DF)が、“SS”といったように)1文字以上に文字が拡張される場合、代わりにその文字がそのまま残ります。 その文字はまた、ASCII文字ではないけれども大文字への変換中にそれを(一時的に)ASCII文字にする場合もそのままの文字が残ります。 これは、ASCII文字とのマッチが意図される場合にのみ /[a-z]/i のような正規表現にマッチする \u0131 と \u017F といったようなUnicode文字を防ぐことができます。 更にこれらの変換が許容される場合、 /[^\W]/i は、 a, b, …, h のそれぞれにはマッチしますが、i や s にはマッチしません。</p>
    <h3 id="15-10-2-9-atomescape">15.10.2.9 AtomEscape</h3>
    <p>　プロダクション AtomEscape :: DecimalEscape は、次のように評価します。</p>
<pre><code>1. EscapeValue E を取得する為にDecimalEscapeを評価
    2. E が文字である場合、
    a. ch は、 E の文字とする
    b. A は、文字 ch を含んでいる1つの要素 CharSet とする
    c. CharacterSetMatcher(A, false) を呼び、その Matcher (クロージャ)の結果を返す
    3. E は、整数にしなければならず、 n は、その整数とする
    4. n=0 または、 n&gt;NCapturingParens である場合、SyntaxError例外を投げる(スローする)
    5.任意の State x と任意の Continuation c という2つの引数を取り、次を実行する内部 Matcher クロージャを返す
    1. cap は、 x のキャプチャ内部配列とする
    2. s は、 cap[n] とする
    3. s が、undefinedである場合、 c(x) を呼び、その結果を返す
    4. e は、 x の endIndex とする
    5. len は、 s の長さとする
    6. f は、 e+len とする
    7. f&gt;InputLength である場合、 failure を返す
    8.整数 i が存在する場合、 Canonicalize(Input [e+i]) と同じ文字ではない  Canonicalize(s[i]) といったような 0 (を含む 0 )と len (を含まない len )の間である場合、 failure を返す
    9. y は、 State (f, cap) とする
    10. c(y) を呼び、その結果を返す
</code></pre><p>　プロダクション AtomEscape :: CharacterEscape は、次のように評価します。</p>
<pre><code>1.文字 ch を取得する為にCharacterEscapeを評価
    2. A は、文字 ch を含んでいる1つの要素 CharSet とする
    3. CharacterSetMatcher(A, false) を呼び、その Matcher (クロージャ)の結果を返す
</code></pre><p>　プロダクション AtomEscape :: CharacterClassEscape は、次のように評価します。</p>
<pre><code>1. CharSet A を取得する為にCharacterClassEscapeを評価
    2. CharacterSetMatcher(A, false) を呼び、その Matcher (クロージャ)の結果を返す
</code></pre><p>[注釈]</p>
    <p>　非ゼロの10進数字 n が続く書式 \ というエスケープシーケンスは、キャプチャするカッコ( 15.10.2.11 参照)の n 番めのセットという結果とマッチします。 正規表現が、 n 番めのキャプチャするカッコより少ないという場合、それはエラーです。 正規表現は、n 以上キャプチャするカッコを持ちますが、キャプチャするものがない為に n 番めのそれが undefinedである場合、後方参照は、常に成功します。</p>
    <h3 id="15-10-2-10-characterescape">15.10.2.10 CharacterEscape</h3>
    <p>　プロダクション CharacterEscape :: ControlEscape は、 Table 23 による文字を返すことにより評価します。</p>
<pre><code>Table 23 -- ControlEscape 文字値
    -------------------------------------------------------------------------------------------
    ControlEscape   コードユニット 名称                      記号
    -------------------------------------------------------------------------------------------
    t       \u0009      水平タブ(horizontal tab)            &lt;HT&gt;
    n       \u000A      ラインフィード(改行)／line feed (new line)    &lt;LF&gt;
    v       \u000B      垂直タブ(vertical tab)              &lt;VT&gt;
    f       \u000C      フォームフィード(form feed)         &lt;FF&gt;
    r       \u000D      キャリッジリターン(carriage return)      &lt;CR&gt;
    -------------------------------------------------------------------------------------------
</code></pre><p>　プロダクション CharacterEscape :: c ControlLetter は、次のように評価します。</p>
<pre><code>1. ch は、ControlLetterによって表した文字とする
    2. i は、ch のコードユニット値とする
    3. j は、i を 32 で割った余りとする
    4.コードユニット値が j である文字を返す
</code></pre><p>　プロダクション CharacterEscape :: HexEscapeSequence は、 HexEscapeSequence の CV ( 7.8.4 参照)を評価し、その文字結果を返すことによって評価します。</p>
    <p>　プロダクション CharacterEscape :: UnicodeEscapeSequence は、UnicodeEscapeSequence の CV ( 7.8.4 参照)を評価し、その文字結果を返すことによって評価します。</p>
    <p>　プロダクション CharacterEscape :: IdentityEscape は、IdentityEscape によって示した文字を返すことによって評価します。</p>
    <h3 id="15-10-2-11-decimalescape">15.10.2.11 DecimalEscape</h3>
    <p>　プロダクション DecimalEscape :: DecimalIntegerLiteral [lookahead ? DecimalDigit] は、次のように評価します。 [?部は、∈の否定形]</p>
<pre><code>1. i は、DecimalIntegerLiteral の MV とする
    2. i が、ゼロである場合、&lt;NUL&gt; 文字(Unicode値 0000)を含んでいるEscapeValueを返す
    3.整数 i を含んでいるEscapeValueを返す
</code></pre><p>　“DecimalIntegerLiteral の MV” の定義は、 7.8.3. にあります。</p>
    <p>[注釈]</p>
    <p>　最初の桁が0である10進数字 n が続く \ がある場合、そのエスケープシーケンスは、後方参照とすることが考慮されます。 n が、正規表現全体にあるキャプチャする左かっこの総数よりも大きい場合、それはエラーです。 \0 は、 \&lt;NUL\&gt; 文字を表し、10進数字を後続させることはできません。</p>
    <h3 id="15-10-2-12-characterclassescape">15.10.2.12 CharacterClassEscape</h3>
    <p>　プロダクション CharacterClassEscape :: d は、0 から 9 までの文字を含んでいる複数文字の10要素(ten-element)のセットを返すことによって評価します。</p>
    <p>　プロダクション CharacterClassEscape :: D は、CharacterClassEscape :: d によって返したセット内に含まれない全ての文字のセットを返すことによって評価します。</p>
    <p>　プロダクション CharacterClassEscape :: s は、WhiteSpace(7.2)やLineTerminator(7.3)の右側にある文字を含んでいる文字のセットを返すことによって評価します。</p>
    <p>　プロダクション CharacterClassEscape :: S は、CharacterClassEscape :: s によって返したセット内に含まれない全ての文字のセットを返すことによって評価します。</p>
    <p>　プロダクション CharacterClassEscape :: w は、以下63個の文字をを含んでいる文字のセットを返すことによって評価します。</p>
<pre><code>a b c d e f g h i j k l m n o p q r s t u v w x y z
    A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
    0 1 2 3 4 5 6 7 8 9 _
</code></pre><p>　プロダクション CharacterClassEscape :: W は、 CharacterClassEscape :: w によって返したセット内に含まれない全ての文字のセットを返すことによって評価します。</p>
    <h3 id="15-10-2-13-characterclass">15.10.2.13 CharacterClass</h3>
    <p>　プロダクション CharacterClass :: [ [lookahead ? {^}] ClassRanges ] は、 CharSet を取得する為に ClassRanges を評価し、その CharSet と Booleanフラグ falseを返すことによって評価します。[?部は、∈の否定形]</p>
    <p>　プロダクション CharacterClass :: [ ^ ClassRanges ] は、 CharSet を取得する為に ClassRanges を評価し、その CharSet と Booleanフラグ trueを返すことによって評価します。</p>
    <h3 id="15-10-2-14-classranges">15.10.2.14 ClassRanges</h3>
    <p>　プロダクション ClassRanges :: [empty] は、カラの CharSet を返すことによって評価します。</p>
    <p>　プロダクション ClassRanges :: NonemptyClassRanges は、 CharSet を取得する為に NonemptyClassRanges を評価し、その CharSet を返すことによって評価します。</p>
    <h3 id="15-10-2-15-nonemptyclassranges">15.10.2.15 NonemptyClassRanges</h3>
    <p>　プロダクション NonemptyClassRanges :: ClassAtom は、 CharSet を取得する為に ClassAtom を評価し、その CharSet を返すことによって評価します。</p>
    <p>　プロダクション NonemptyClassRanges :: ClassAtom NonemptyClassRangesNoDash は、次のように評価します。</p>
<pre><code>1. CharSet A を取得する為、ClassAtom を評価
    2. CharSet B を取得する為、NonemptyClassRangesNoDash を評価
    3. CharSets A と B の結合(union)を返す
</code></pre><p>　プロダクション NonemptyClassRanges :: ClassAtom - ClassAtom ClassRanges は、次のように評価します。</p>
<pre><code>1. CharSet A を取得する為、1つめの ClassAtom を評価
    2. CharSet B を取得する為、2つめの ClassAtom を評価
    3. CharSets C を取得する為、 ClassRanges を評価
    4. CharacterRange(A, B) を呼び、D は、その結果となる CharSet とする
    5. CharSets D と C の結合を返す
</code></pre><p>　抽象操作 CharacterRange は、2つの CharSet パラメータ A と B を取り、次を実行します。</p>
<pre><code>1. A が、ぴったり1文字を含まない場合や B が、ぴったり1文字を含まない場合、SyntaxError例外を投げる(スローする)
    2. a は、 CharSet A 内にある1文字とする
    3. b は、 CharSet B 内にある1文字とする
    4. i は、文字 a のコードユニット値とする
    5. j は、文字 b のコードユニット値とする
    6. i &gt; j である場合、SyntaxError例外を投げる(スローする)
    7. i から　j までを包含する番号付けされた文字全てを含むセットを返す
</code></pre><h3 id="15-10-2-16-nonemptyclassrangesnodash">15.10.2.16 NonemptyClassRangesNoDash</h3>
    <p>　プロダクション NonemptyClassRangesNoDash :: ClassAtom は、 CharSet を取得する為に ClassAtom を評価し、その CharSet を返すことによって評価します。</p>
    <p>　プロダクション NonemptyClassRangesNoDash :: ClassAtomNoDash NonemptyClassRangesNoDash は、次のように評価します。</p>
<pre><code>1. CharSet A を取得する為、ClassAtomNoDash を評価
    2. CharSet B を取得する為、NonemptyClassRangesNoDash を評価
    3. CharSets A と B の結合を返す
</code></pre><p>　プロダクション NonemptyClassRangesNoDash :: ClassAtomNoDash - ClassAtom ClassRanges は、次のように評価します。</p>
<pre><code>1. CharSet A を取得する為、ClassAtomNoDash を評価
    2. CharSet B を取得する為、ClassAtom を評価
    3. CharSets C を取得する為、 ClassRanges を評価
    4. CharacterRange(A, B) を呼び、D は、その結果となる CharSet とする
    5. CharSets D と C の結合を返す
</code></pre><p>[注釈 1]</p>
    <p>　 ClassRanges は、単一の ClassAtoms とダッシュによって分割した2つの ClassAtoms の範囲の双方または一方について拡張することが可能です。 後者では、 ClassRanges は、1つめの ClassAtom と2つめの ClassAtom の間にある全ての文字を内包的に含み、 ClassAtom が単一の文字を表さない(例えば、一方が\wである)場合、または、1つめの ClassAtom のコードユニット値が、2つめの ClassAtom のコードユニット値よりも大きい場合、エラーが発生します。</p>
    <p>[注釈 2]</p>
    <p>　パターンが無視される場合でさえ、範囲内の末尾が2つのケースは、その範囲内に属する文字を決定中は有効となります。 このように、例えば、パターン /[E-f]/i が、記号 [ , \ , ] , ^ , _ , ` と同様の全ての大文字と小文字のASCII文字にマッチする場合、 パターン /[E-F]/i は、文字 E, F, e, f の何れかにだけマッチします。</p>
    <p>[注釈 3]</p>
    <p>　1文字の - (ハイフン) は、文字通り(リテラルとして)扱われたり、任意の範囲を示すことが可能です。 ClassRanges の最初や最後の文字であり、範囲仕様の開始や末端の限界、または、直後に範囲仕様(の限界)が続く場合、文字通り(リテラルとして)扱われます。</p>
    <h3 id="15-10-2-17-classatom">15.10.2.17 ClassAtom</h3>
    <p>　プロダクション ClassAtom :: - は、 - (ハイフン)1文字を含む CharSet を返すことによって評価します。</p>
    <p>　プロダクション ClassAtom :: ClassAtomNoDash は、 CharSet を取得する為に ClassAtomNoDash を評価し、その CharSet を返すことによって評価します。</p>
    <h3 id="15-10-2-18-classatomnodash">15.10.2.18 ClassAtomNoDash</h3>
    <p>　 \ や ] や - ではないプロダクション ClassAtomNoDash :: SourceCharacter は、 SourceCharacter によって表した文字を含む1つの要素 CharSet を返すことによって評価します。</p>
    <p>　プロダクション ClassAtomNoDash :: \ ClassEscape は、 CharSet を取得する為に ClassEscape を評価し、その CharSet を返すことによって評価します。</p>
    <h3 id="15-10-2-19-classescape">15.10.2.19 ClassEscape</h3>
    <p>　プロダクション ClassEscape :: DecimalEscape は、次のように評価します。</p>
<pre><code>1.任意の EscapeValue E を取得する為に DecimalEscape を評価
    2. E が、文字ではない場合、SyntaxError例外を投げる(スローする)
    3. ch は、 E の文字とする
    4.文字 ch を含む1つの要素 CharSetを返す
</code></pre><p>　プロダクション ClassEscape :: b は、 \&lt;BS\&gt; (Unicode値 0008) 1文字を含む CharSet を返すことによって評価します。</p>
    <p>　プロダクション ClassEscape :: CharacterEscape は、任意の文字を取得する為に CharacterEscape を評価し、その文字を含む1つの要素 CharSet を返すことによって評価します。</p>
    <p>　プロダクション ClassEscape :: CharacterClassEscape は、 CharSet を取得する為に CharacterClassEscape を評価し、その CharSet を返すことによって評価します。</p>
    <p>[注釈]</p>
    <p>　任意の ClassAtom は、 \b, \B と後方参照を除く正規表現内で許容される残りのエスケープシーケンスの一部を使用することが可能です。 任意の CharacterClass 内の \b は、 \B と後方参照がエラーを発生させる場合、バックスペース文字を意味します。 ClassAtom 内で後方参照を使用することは、エラーの要因になります。</p>
    <h2 id="15-10-3-regexp-the-regexp-constructor-called-as-a-function-standard-ecma-262-5-1-edition">15.10.3 関数として呼んだ RegExp コンストラクタ / The RegExp Constructor Called as a Function / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="15-ecmascript-">15 標準組み込みECMAScriptオブジェクト</h3>
    <h3 id="15-10-regexp-regular-expression-">15.10 RegExp (Regular Expression／正規表現) オブジェクト</h3>
    <h3 id="15-10-3-regexp-">15.10.3 関数として呼んだ RegExp コンストラクタ</h3>
    <h3 id="15-10-3-1-regexp-pattern-flags-">15.10.3.1 RegExp(pattern, flags)</h3>
    <p>　 patternが、内部プロパティ[[Class]]が “RegExp”、フラグがundefinedであるオブジェクト R である場合、変更せずに R を返します。 それ以外の場合、式 RegExp(pattern, flags) によるそのコンストラクタによって構築したオブジェクトを返すかのように標準組み込みRegExpコンストラクタ(15.10.4.1)を呼びます。</p>
    <h2 id="15-10-4-regexp-the-regexp-constructor-standard-ecma-262-5-1-edition">15.10.4 RegExp コンストラクタ / The RegExp Constructor / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="15-ecmascript-">15 標準組み込みECMAScriptオブジェクト</h3>
    <h3 id="15-10-regexp-regular-expression-">15.10 RegExp (Regular Expression／正規表現) オブジェクト</h3>
    <h3 id="15-10-4-regexp-">15.10.4 RegExp コンストラクタ</h3>
    <p>　 RegExp が、 new 式の一部として呼ばれる場合、それは、コンストラクタであり、新たに生成したオブジェクトを初期化します。</p>
    <h3 id="15-10-4-1-new-regexp-pattern-flags-">15.10.4.1 new RegExp(pattern, flags)</h3>
    <p>　 pattern が、内部プロパティ[[Class]]が “RegExp”、フラグが、undefinedであるオブジェクト R である場合、P は、Rを構築する為に使用したpatternとし、F は、 R を構築する為に使用したフラグとします。 pattern が、内部プロパティ[[Class]]が “RegExp”、フラグが、undefinedでないオブジェクト R である場合、TypeError例外を投げ(スローし)ます。 それ以外の場合、 pattern が、 undefined である場合、 P は、カラの文字列とし、それ以外の場合、フラグがundefinedで且つ、 ToString(flags) 以外の場合、 F はカラの文字列とします。</p>
    <p>　 P を構成する文字が、Pattern から成る構文を持たない場合、SyntaxError例外を投げ(スローし)ます。 それ以外の場合、新たに構築したオブジェクトは、15.10.2 で説明したように同じ Pattern である P を構成する文字(“compiling”)を評価することによって得られた内部プロパティ[[Match]]を持つものとします。</p>
    <p>　 F が、 “g”, “i”, “m” 以外の文字を含んだり、1つ以上の同一文字を含む場合、SyntaxError例外を投げ(スローし)ます。</p>
    <p>　 SyntaxError例外を投げ(スローし)ない場合、</p>
<pre><code> S は、以下で説明したようにエスケープ(符号化)される特定の文字内にある P と同等の任意の Pattern の書式にある文字列とします。
    S は、 P や pattern と同一であったり、そうでなかったりする場合がありますが、しかしながら、任意の Pattern として S を評価することによって得られる結果である内部プロシージャは、構築したオブジェクトの内部プロパティ[[Match]]によって与えられる内部プロシージャと同一の動作をしなければいけません。
    pattern 内に現れる文字 / (スラッシュ)は、構築した正規表現と同一の動作をする RegularExpressionLiteral として(適切な語彙的内容内で)解析されることが可能な文字列 &quot;/&quot;, S, &quot;/&quot;, F を連結することによって形成されるString値として確保する為に必要となる S 内でエスケープされるようにしましょう。
    例えば、 P が、 &quot;/&quot; である場合、 F が続く /// は、 RegularExpressionLiteral ではなく、SingleLineComment として解析される可能性があるので S は、他の可能性の中でも&quot;/&quot;ではなく &quot;\/&quot; や &quot;\u002F&quot; とすべきです。
    P が、カラの文字列である場合、この仕様は、 S が、&quot;(?:)&quot; であるものとすることによって満たされます。
</code></pre><p>新たに構築したオブジェクトの次のプロパティは、 15.10.7 で指定される属性を伴うデータプロパティです。</p>
    <p>　各プロパティの[[Value]]は、次のように設定されます。</p>
<pre><code>新たに構築したオブジェクトの source プロパティは、 S に設定されます。
    新たに構築したオブジェクトの global プロパティは、 F が、文字 &quot;g&quot; と false以外を含む場合、trueであるBoolean値に設定されます。
    新たに構築したオブジェクトのignoreCaseプロパティは、 F が、文字 &quot;i&quot; と false以外を含む場合、trueであるBoolean値に設定されます。
    新たに構築したオブジェクトの multiline プロパティは、 F が、文字 &quot;m&quot; と false以外を含む場合、trueであるBoolean値に設定されます。
    新たに構築したオブジェクトの lastIndex プロパティは、 0に設定されます。
    新たに構築したオブジェクトの内部プロパティ[[Prototype]]は、 15.10.6 で指定したように標準組み込み RegExp プロトタイプオブジェクトに設定されます。
    新たに構築したオブジェクトの内部プロパティ[[Class]]は、 &quot;RegExp&quot; に設定されます。
</code></pre><p>[注釈]</p>
    <p>　 pattern が、StringLiteral である場合、通常、エスケープシーケンスの置換は、文字列が、 RegExp によって処理される前に実行されます。 pattern が、 RegExp によって認識される為にエスケープシーケンスを含む場合、バックスラッシュである \ 文字は、 StringLiteral の内容が、形成される際に削除されることを防ぐために StringLiteral 内でエスケープされなければいけません。</p>
    <h2 id="15-10-5-regexp-properties-of-the-regexp-constructor-standard-ecma-262-5-1-edition">15.10.5 RegExp コンストラクタのプロパティ / Properties of the RegExp Constructor / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="15-ecmascript-">15 標準組み込みECMAScriptオブジェクト</h3>
    <h3 id="15-10-regexp-regular-expression-">15.10 RegExp (Regular Expression／正規表現) オブジェクト</h3>
    <h3 id="15-10-5-regexp-">15.10.5 RegExp コンストラクタのプロパティ</h3>
    <p>　 RegExpコンストラクタの内部プロパティ[[Prototype]]の値は、標準組み込みFunctionプロトタイプオブジェクト(15.3.4)です。 また、その内部プロパティ、(値が2である)lengthプロパティ、RegExpコンストラクタは、次のプロパティも持ちます。</p>
    <h3 id="15-10-5-1-regexp-prototype">15.10.5.1 RegExp.prototype</h3>
    <p>　 RegExp.prototype の初期値は、RegExpプロトタイプオブジェクト(15.10.6)です。 このプロパティには、属性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false } を持たせましょう。</p>
    <h2 id="15-10-6-regexp-properties-of-the-regexp-prototype-object-standard-ecma-262-5-1-edition">15.10.6 RegExpプロトタイプオブジェクトのプロパティ / Properties of the RegExp Prototype Object / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="15-ecmascript-">15 標準組み込みECMAScriptオブジェクト</h3>
    <h3 id="15-10-regexp-regular-expression-">15.10 RegExp (Regular Expression／正規表現) オブジェクト</h3>
    <h3 id="15-10-6-regexp-">15.10.6 RegExpプロトタイプオブジェクトのプロパティ</h3>
    <p>　 RegExpプロトタイプオブジェクトの内部プロパティ[[Prototype]]の値は、標準組み込みObjectプロトタイプオブジェクト(15.2.4)です。</p>
    <p>　 RegExpプロトタイプオブジェクトは、それ自身の正規表現オブジェクトであり、その[[Class]]は、“RegExp”です。</p>
    <p>　 RegExpプロトタイプオブジェクトのデータプロパティ(15.10.7)の初期値は、その名を持つ標準組み込みコンストラクタである RegExp を式 new RegExp() によって生成されたオブジェクトであるかのように設定されます。</p>
    <p>　 RegExpプロトタイプオブジェクトは、その自身の valueOf プロパティは持ちませんが、ObjectプロトタイプオブジェクトからvalueOf プロパティを継承します。</p>
    <p>　次のRegExpプロトタイプオブジェクトのプロパティである関数の概要にあるフレーズ“this RegExp オブジェクト”は、当該関数の呼び出しにおける this 値である当該オブジェクトを参照します。</p>
    <p>　 this 値が、オブジェクトではなかったり、内部プロパティ[[Class]]の値が、“RegExp”でないオブジェクトである場合には、TypeError例外が投げられ(スローされ)ます。</p>
    <h3 id="15-10-6-1-regexp-prototype-constructor">15.10.6.1 RegExp.prototype.constructor</h3>
    <p>　 RegExp.prototype.constructor の初期値は、標準組み込みRegExpコンストラクタです。</p>
    <h3 id="15-10-6-2-regexp-prototype-exec-string-">15.10.6.2 RegExp.prototype.exec(string)</h3>
    <p>　正規表現に対するstringの正規表現のマッチを実行し、マッチした結果を含んでいるArrayオブジェクトを、stringがマッチしなければ、nullを返します。</p>
    <p>　文字列 ToString(string) は、次のような正規表現のパターンの出現において検索されます。</p>
<pre><code>1. R は、 this RegExp オブジェクトとする
    2. S は、 ToString(string) の値とする
    3. length は、 S の長さとする
    4. lastIndex は、引数&quot;lastIndex&quot;を伴う R の内部メソッド[[Get]]を呼んだ結果とする
    5. i は、 ToInteger(lastIndex) の値とする
    6. global は、引数&quot;global&quot;を伴う R の内部メソッド[[Get]]を呼んだ結果とする
    7. global が、 false である場合、 i = 0 とする
    8. matchSucceeded は、false とする
    9. matchSucceeded が、false である間、繰り返す
    a. i &lt; 0 または、 i &gt; length である場合、
    i.引数&quot;lastIndex&quot;を伴う R の内部メソッド[[Put]]を呼ぶ
    ii. null を返す
    b.引数 S と i を伴う R の内部メソッド[[Match]]を呼ぶ
    c. [[Match]] が、 failure を返す場合、
    i. i = i+1 とする
    d.それ以外の場合、
    i. r は、[[Match]]を呼んだ結果の State (状態)とする
    ii. matchSucceeded に true を設定する
    10. e は、 r の endIndex 値とする
    11. global が、 trueである場合、
    a.引数&quot;lastIndex&quot;、e、true を伴う R　の内部メソッド[[Put]]を呼ぶ
    12. n は、r のキャプチャ配列の長さとする。(これは、 15.10.2.1 の NCapturingParens と同じ値である)
    13. A は、その名を持つ標準組み込みコンストラクタである Array を式 new Array() によるかのように生成した新たな配列とする
    14. matchIndex は、 i とする
    15.引数 &quot;index&quot; 、プロパティ記述子 {[[Value]]: matchIndex, [[Writable]: true, [[Enumerable]]: true, [[Configurable]]: true}、 true を伴う A の内部メソッド[[DefineOwnProperty]]を呼ぶ
    16.引数 &quot;input&quot; 、プロパティ記述子 {[[Value]]: S, [[Writable]: true, [[Enumerable]]: true, [[Configurable]]: true}、 true を伴う A の内部メソッド[[DefineOwnProperty]]を呼ぶ
    17.引数 &quot;length&quot; 、プロパティ記述子 {[[Value]]: n + 1}、 true を伴う A の内部メソッド[[DefineOwnProperty]]を呼ぶ
    18. matchedSubstr は、マッチした部分文字列とする(例えば、内包的なオフセット i と排他的なオフセット e の間の S の部分等々)
    19.引数 &quot;0&quot; 、プロパティ記述子 {[[Value]]: matchedSubstr, [[Writable]: true, [[Enumerable]]: true, [[Configurable]]: true}、 true を伴う A の内部メソッド[[DefineOwnProperty]]を呼ぶ
    20. i &gt; 0 且つ、 i ≦ n のような整数 i ごとに
    a. captureI は、r の キャプチャ配列の i 番めの要素とする
    b.引数 ToString(i) 、プロパティ記述子 {[[Value]]: captureI, [[Writable]: true, [[Enumerable]]: true, [[Configurable]]: true}、 trueを伴う A の内部メソッド[[DefineOwnProperty]]を呼ぶ
    21. A を返す
</code></pre><h3 id="15-10-6-3-regexp-prototype-test-string-">15.10.6.3 RegExp.prototype.test(string)</h3>
    <p>　(testは、)次のステップが取られます。</p>
<pre><code>1. match は、引数として string を使用して this RegExp オブジェクト上の RegExp.prototype.exec (15.10.6.2) のアルゴリズムを評価した結果とする
    2. match が、null ではない場合、true を返し、それ以外の場合、false を返す
</code></pre><h3 id="15-10-6-4-regexp-prototype-tostring-">15.10.6.4 RegExp.prototype.toString()</h3>
    <p>　文字列 “/” 、 this RegExp オブジェクトのソースプロパティのString値と “/” 、加えて global プロパティが trueである場合、“g”、 ignoreCase プロパティが trueである場合、“i”、 multiline プロパティが trueである場合、“m” を連結することによって形成されるString値を返します。</p>
    <p>[注釈]</p>
    <p>　返した文字列は、 this オブジェクトとして同一の動作を伴う他の RegExp オブジェクトを評価する RegularExpressionLiteral の書式を持ちます。</p>
    <h2 id="15-10-7-regexp-properties-of-regexp-instances-standard-ecma-262-5-1-edition">15.10.7 RegExp インスタンスのプロパティ / Properties of RegExp Instances / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="15-ecmascript-">15 標準組み込みECMAScriptオブジェクト</h3>
    <h3 id="15-10-regexp-regular-expression-">15.10 RegExp (Regular Expression／正規表現) オブジェクト</h3>
    <h3 id="15-10-7-regexp-">15.10.7 RegExp インスタンスのプロパティ</h3>
    <p>　RegExpインスタンスは、 RegExp プロトタイプオブジェクトと値が、“RegExp”であるそれらの内部プロパティ[[Class]]からプロパティを継承します。</p>
    <p>　RegExpインスタンスはまた、内部プロパティ[[Match]]とlengthプロパティも持ちます。</p>
    <p>　内部プロパティ[[Match]]の値は、 RegExp オブジェクトの Pattern の実装依存の表現です。</p>
    <p>　RegExpインスタンスはまた、次のプロパティも持ちます。</p>
    <h3 id="15-10-7-1-source">15.10.7.1 source</h3>
    <p>　source プロパティの値は、現在の正規表現を表す任意の Pattern の書式内にある文字列です。</p>
    <p>　このプロパティは、属性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false } を持つようにしましょう。</p>
    <h3 id="15-10-7-2-global">15.10.7.2 global</h3>
    <p>　global プロパティの値は、文字 “g” を含んだフラグかどうかを示すBoolean値です。</p>
    <p>　このプロパティは、属性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false } を持つようにしましょう。</p>
    <h3 id="15-10-7-3-ignorecase">15.10.7.3 ignoreCase</h3>
    <p>　 ignoreCase プロパティの値は、文字 “i” を含んだフラグかどうかを示すBoolean値です。</p>
    <p>　このプロパティは、属性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false } を持つようにしましょう。</p>
    <h3 id="15-10-7-4-multiline">15.10.7.4 multiline</h3>
    <p>　multiline プロパティの値は、文字 “m” を含んだフラグかどうかを示すBoolean値です。</p>
    <p>　このプロパティは、属性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false } を持つようにしましょう。</p>
    <h3 id="15-10-7-5-lastindex">15.10.7.5 lastIndex</h3>
    <p>　 lastIndex プロパティの値は、次にマッチする開始位置における文字列を指定します。</p>
    <p>　それは使用時に強制変換されます。( 15.10.6.2 参照)</p>
    <p>　このプロパティは、属性 { [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false } を持つようにしましょう。</p>
    <p>[注釈]</p>
    <p>　 RegExpインスタンスの他の標準組み込みプロパティとは異なり、 lastIndex は、書き込み可能(writable)です。</p>
    <h2 id="15-11-error-error-objects-standard-ecma-262-5-1-edition">15.11 Error オブジェクト / Error Objects / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="15-ecmascript-">15 標準組み込みECMAScriptオブジェクト</h3>
    <h3 id="15-11-error-">15.11 Error オブジェクト</h3>
    <p>　 Errorオブジェクトのインスタンスは、実行エラーが発生する際に例外として投げられ(スローされ)ます。</p>
    <p>　 Errorオブジェクトはまた、ユーザー定義の例外クラスにおける基準オブジェクトとして提供する場合もあります。</p>
    <p>– 15.11.1.1 Error (message)</p>
    <p>– 15.11.2.1 new Error (message)</p>
    <p>– 15.11.3.1 Error.prototype</p>
    <p>– 15.11.4.1 Error.prototype.constructor</p>
    <p>– 15.11.4.2 Error.prototype.name</p>
    <p>– 15.11.4.3 Error.prototype.message</p>
    <p>– 15.11.4.4 Error.prototype.toString ( )</p>
    <p>– 15.11.6.1 EvalError</p>
    <p>– 15.11.6.2 RangeError</p>
    <p>– 15.11.6.3 ReferenceError</p>
    <p>– 15.11.6.4 SyntaxError</p>
    <p>– 15.11.6.5 TypeError</p>
    <p>– 15.11.6.6 URIError</p>
    <p>– 15.11.7.1 関数として呼んだ NativeError コンストラクタ</p>
    <p>– 15.11.7.2 NativeError (message)</p>
    <p>– 15.11.7.3 NativeError コンストラクタ</p>
    <p>– 15.11.7.4 new NativeError (message)</p>
    <p>– 15.11.7.5 NativeError コンストラクタのプロパティ</p>
    <p>– 15.11.7.6 NativeError.prototype</p>
    <p>– 15.11.7.7 NativeErrorプロトタイプオブジェクトのプロパティ</p>
    <p>– 15.11.7.8 NativeError.prototype.constructor</p>
    <p>– 15.11.7.9 NativeError.prototype.name</p>
    <p>– 15.11.7.10 NativeError.prototype.message</p>
    <p>– 15.11.7.11 NativeError インスタンスのプロパティ</p>
    <h2 id="15-11-1-error-the-error-constructor-called-as-a-function-standard-ecma-262-5-1-edition">15.11.1 関数として呼んだ Error コンストラクタ / The Error Constructor Called as a Function / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="15-ecmascript-">15 標準組み込みECMAScriptオブジェクト</h3>
    <h3 id="15-11-error-">15.11 Error オブジェクト</h3>
    <h3 id="15-11-1-error-">15.11.1 関数として呼んだ Error コンストラクタ</h3>
    <p>　 Errorが、コンストラクタではなく、関数として呼ばれる際には、新たなErrorオブジェクトを生成、初期化します。</p>
    <p>　このような関数呼び出し Error(…) は、同じ引数を伴うオブジェクト生成式 new Error(…) と等価です。</p>
    <h3 id="15-11-1-1-error-message-">15.11.1.1 Error (message)</h3>
    <p>　新たに構築したオブジェクトの内部プロパティ[[Prototype]]は、Error.prototype (15.11.3.1)の初期値であるオリジナルのErrorプロトタイプオブジェクトに設定されます。</p>
    <p>　新たに構築したオブジェクトの内部プロパティ[[Class]]は、“Error”に設定されます。</p>
    <p>　新たに構築したオブジェクトの内部プロパティ[[Extensible]]は、trueに設定されます。</p>
    <p>　引数 message は、undefinedではない場合、 新たに構築したオブジェクトのプロパティ自身のメッセージは、ToString(message) に設定されます。</p>
    <h2 id="15-11-2-error-the-error-constructor-standard-ecma-262-5-1-edition">15.11.2 Error コンストラクタ / The Error Constructor / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="15-ecmascript-">15 標準組み込みECMAScriptオブジェクト</h3>
    <h3 id="15-11-error-">15.11 Error オブジェクト</h3>
    <h3 id="15-11-2-error-">15.11.2 Error コンストラクタ</h3>
    <p>　 Error は、new 式の一部として呼ばれる場合、それは、コンストラクタであり、新たに生成したオブジェクトを初期化します。</p>
    <h3 id="15-11-2-1-new-error-message-">15.11.2.1 new Error (message)</h3>
    <p>　新たに構築したオブジェクトの内部プロパティ[[Prototype]]は、Error.prototype (15.11.3.1)の初期値であるオリジナルのErrorプロトタイプオブジェクトに設定されます。</p>
    <p>　新たに構築したオブジェクトの内部プロパティ[[Class]]は、“Error”に設定されます。</p>
    <p>　新たに構築したオブジェクトの内部プロパティ[[Extensible]]は、trueに設定されます。</p>
    <p>　引数 message は、undefinedではない場合、 新たに構築したオブジェクトのプロパティ自身のメッセージは、ToString(message) に設定されます。</p>
    <h2 id="15-11-3-error-properties-of-the-error-constructor-standard-ecma-262-5-1-edition">15.11.3 Error コンストラクタのプロパティ / Properties of the Error Constructor / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="15-ecmascript-">15 標準組み込みECMAScriptオブジェクト</h3>
    <h3 id="15-11-error-">15.11 Error オブジェクト</h3>
    <h3 id="15-11-3-error-">15.11.3 Error コンストラクタのプロパティ</h3>
    <p>　Errorコンストラクタの内部プロパティ[[Prototype]]の値は、Functionプロトタイプオブジェクト(15.3.4)です。</p>
    <p>　また、当該内部プロパティ、(値が1である)lengthプロパティ、当該Errorコンストラクタは、次のプロパティも持ちます。</p>
    <h3 id="15-11-3-1-error-prototype">15.11.3.1 Error.prototype</h3>
    <p>　 Error.prototype の初期値は、Errorプロトタイプオブジェクト(15.11.4)です。</p>
    <p>　このプロパティは、属性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false } を持ちます。</p>
    <h2 id="15-11-4-error-properties-of-the-error-prototype-object-standard-ecma-262-5-1-edition">15.11.4 Errorプロトタイプオブジェクトのプロパティ / Properties of the Error Prototype Object / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="15-ecmascript-">15 標準組み込みECMAScriptオブジェクト</h3>
    <h3 id="15-11-error-">15.11 Error オブジェクト</h3>
    <h3 id="15-11-4-error-">15.11.4 Errorプロトタイプオブジェクトのプロパティ</h3>
    <p>　 Errorプロトタイプオブジェクトは、それ自身のErrorオブジェクト(、その[[Class]]は、“Error”)です。</p>
    <p>　 Errorプロトタイプオブジェクトの内部プロパティ[[Prototype]]は、標準組み込みObjectプロトタイプオブジェクト(15.2.4)です。</p>
    <h3 id="15-11-4-1-error-prototype-constructor">15.11.4.1 Error.prototype.constructor</h3>
    <p>　 Error.prototype.constructor の初期値は、組み込みErrorコンストラクタです。</p>
    <h3 id="15-11-4-2-error-prototype-name">15.11.4.2 Error.prototype.name</h3>
    <p>　 Error.prototype.name の初期値は、“Error”です。</p>
    <h3 id="15-11-4-3-error-prototype-message">15.11.4.3 Error.prototype.message</h3>
    <p>　 Error.prototype.message の初期値は、カラの文字列です。</p>
    <h3 id="15-11-4-4-error-prototype-tostring-">15.11.4.4 Error.prototype.toString ( )</h3>
    <p>　(toStringは、)次のステップが取られます。</p>
<pre><code>1. O は、 this 値とする
    2. Type(O) が、 Object ではない場合、TypeError例外を投げる(スローする)
    3. name が、引数&quot;name&quot;を伴う O の内部メソッド[[Get]を呼んだ結果とする
    4. name が、 undefined である場合、 name は、 &quot;Error&quot; とし、それ以外の場合は、 name は、 ToString(name) とする
    5. msg は、引数&quot;message&quot;を伴う O の内部メソッド[[Get]]を呼んだ結果とする
    6. msg が、undefined である場合、カラの文字列を返し、 msg は、 ToString(msg) とする
    7. msg が、undefined である場合、カラの文字列を返し、 msg は、 ToString(msg) とする
    8. name が、カラの文字列である場合、 msg を返す
    9. msg が、カラの文字列である場合、name を返す
    10. name, &quot;:&quot;, 単一のスペース文字と msg を連結した結果を返す
</code></pre><p>[注記：]原文：6 と 7 重複。 8 があることを考えると単に一方を削除でよさげ？</p>
    <h2 id="15-11-5-error-properties-of-error-instances-standard-ecma-262-5-1-edition">15.11.5 Error インスタンスのプロパティ / Properties of Error Instances / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="15-ecmascript-">15 標準組み込みECMAScriptオブジェクト</h3>
    <h3 id="15-11-error-">15.11 Error オブジェクト</h3>
    <h3 id="15-11-5-error-">15.11.5 Error インスタンスのプロパティ</h3>
    <p>　 Errorインスタンスは、Errorプロトタイプオブジェクトと値が“Error”であるそれらの内部プロパティ[[Class]]からプロパティを継承します。</p>
    <p>　 Errorインスタンスは、特別なプロパティを何も持ちません。</p>
    <h2 id="15-11-6-error-native-error-types-used-in-this-standard-standard-ecma-262-5-1-edition">15.11.6 この標準規格で使用したネイティブなErrorの種類 / Native Error Types Used in This Standard / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="15-ecmascript-">15 標準組み込みECMAScriptオブジェクト</h3>
    <h3 id="15-11-error-">15.11 Error オブジェクト</h3>
    <h3 id="15-11-6-error-">15.11.6 この標準規格で使用したネイティブなErrorの種類</h3>
    <p>　以下のNativeErrorオブジェクトの1つは、実行エラーが検出される際に投げられ(スローされ)ます。</p>
    <p>　これらオブジェクトのすべては、 15.11.7 で説明したように同じ構造を共有します。</p>
    <h3 id="15-11-6-1-evalerror">15.11.6.1 EvalError</h3>
    <p>　この例外は、この仕様内では、現在使用されません。</p>
    <p>　このオブジェクトは、この仕様の前のエディション(版)との互換性の為に残します。</p>
    <h3 id="15-11-6-2-rangeerror">15.11.6.2 RangeError</h3>
    <p>　許容される範囲を超える数値の値を示します。</p>
    <p>15.4.2.2, 15.4.5.1, 15.7.4.2, 15.7.4.5, 15.7.4.6, 15.7.4.7, 15.9.5.43 参照。</p>
    <h3 id="15-11-6-3-referenceerror">15.11.6.3 ReferenceError</h3>
    <p>　検出済みの無効なリファレンスを示します。</p>
    <p>8.7.1, 8.7.2, 10.2.1, 10.2.1.1.4, 10.2.1.2.4, 11.13.1 参照。</p>
    <h3 id="15-11-6-4-syntaxerror">15.11.6.4 SyntaxError</h3>
    <p>　発生しているエラーを解析していることを示します。</p>
    <p>11.1.5, 11.3.1, 11.3.2, 11.4.1, 11.4.4, 11.4.5, 11.13.1, 11.13.2, 12.2.1, 12.10.1, 12.14.1, 13.1, 15.1.2.1, 15.3.2.1, 15.10.2.2, 15.10.2.5, 15.10.2.9, 15.10.2.15, 15.10.2.19, 15.10.4.1, 15.12.2 参照。</p>
    <h3 id="15-11-6-5-typeerror">15.11.6.5 TypeError</h3>
    <p>　期待した型と異なるオペランドの実際の型を示します。</p>
    <p>8.6.2, 8.7.2, 8.10.5, 8.12.5, 8.12.7, 8.12.8, 8.12.9, 9.9, 9.10, 10.2.1, 10.2.1.1.3, 10.6, 11.2.2, 11.2.3, 11.4.1, 11.8.6, 11.8.7, 11.3.1, 13.2, 13.2.3, 15, 15.2.3.2, 15.2.3.3, 15.2.3.4, 15.2.3.5, 15.2.3.6, 15.2.3.7, 15.2.3.8, 15.2.3.9, 15.2.3.10, 15.2.3.11, 15.2.3.12, 15.2.3.13, 15.2.3.14, 15.2.4.3, 15.3.4.2, 15.3.4.3, 15.3.4.4, 15.3.4.5, 15.3.4.5.2, 15.3.4.5.3, 15.3.5, 15.3.5.3, 15.3.5.4, 15.4.4.3, 15.4.4.11, 15.4.4.16, 15.4.4.17, 15.4.4.18, 15.4.4.19, 15.4.4.20, 15.4.4.21, 15.4.4.22, 15.4.5.1, 15.5.4.2, 15.5.4.3, 15.6.4.2, 15.6.4.3, 15.7.4, 15.7.4.2, 15.7.4.4, 15.9.5, 15.9.5.44, 15.10.4.1, 15.10.6, 15.11.4.4, 15.12.3 参照。</p>
    <h3 id="15-11-6-6-urierror">15.11.6.6 URIError</h3>
    <p>　その定義を伴う非互換性による方法で使用したGlobal(オブジェクトの) URI操作関数の1つを示します。</p>
    <p>15.1.3 参照。</p>
    <h2 id="15-11-7-nativeerror-nativeerror-object-structure-standard-ecma-262-5-1-edition">15.11.7 NativeError オブジェクト構造 / NativeError Object Structure / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="15-ecmascript-">15 標準組み込みECMAScriptオブジェクト</h3>
    <h3 id="15-11-error-">15.11 Error オブジェクト</h3>
    <h3 id="15-11-7-nativeerror-">15.11.7 NativeError オブジェクト構造</h3>
    <p>　ECMAScriptの実装が、実行エラーを検出する場合には、 15.11.6 で定義した NativeError オブジェクトの1つであるインスタンスを投げ(スローし)ます。 これら各オブジェクトは、プロトタイプオブジェクトのプロパティ名の中、またプロトタイプオブジェクトの実装定義のメッセージプロパティの中で NativeError の代わりにコンストラクタ名として使用した名称だけが異なる以下で説明した構造を持ちます。 各エラーオブジェクトごとに定義内にある NativeError を参照する場合には、 15.11.6 から成る適切なオブジェクト名を伴って置換されるべきです。</p>
    <h3 id="15-11-7-1-nativeerror-">15.11.7.1 関数として呼んだ NativeError コンストラクタ</h3>
    <p>　 NativeErrorコンストラクタが、コンストラクタではなく、関数として呼ばれる場合には、新たなオブジェクトを生成、初期化します。 関数としてのオブジェクトの呼び出しは、同じ引数を伴うコンストラクタとしてそれを呼ぶことと等価です。</p>
    <h3 id="15-11-7-2-nativeerror-message-">15.11.7.2 NativeError (message)</h3>
    <p>　新たに構築したオブジェクトの内部プロパティ[[Prototype]]は、このエラーコンストラクタにおけるプロトタイプオブジェクトに設定されます。</p>
    <p>　新たに構築したオブジェクトの内部プロパティ[[Class]]は、“Error”に設定されます。</p>
    <p>　新たに構築したオブジェクトの内部プロパティ[[Extensible]]は、trueに設定されます。</p>
    <p>　引数 message が、undefinedではない場合、新たに構築したオブジェクトの当該メッセージ自身のプロパティは、 ToString(message) に設定されます。</p>
    <h3 id="15-11-7-3-nativeerror-">15.11.7.3 NativeError コンストラクタ</h3>
    <p>　 NativeErrorコンストラクタが、 new 式の一部として呼ばれる場合には、それは、コンストラクタであり、新たに生成したオブジェクトを初期化します。</p>
    <h3 id="15-11-7-4-new-nativeerror-message-">15.11.7.4 new NativeError (message)</h3>
    <p>　新たに構築したオブジェクトの内部プロパティ[[Prototype]]は、このNativeErrorコンストラクタにおけるプロトタイプオブジェクトに設定されます。</p>
    <p>　新たに構築したオブジェクトの内部プロパティ[[Class]]は、“Error”に設定されます。</p>
    <p>　新たに構築したオブジェクトの内部プロパティ[[Extensible]]は、trueに設定されます。</p>
    <p>　引数 message が、undefinedではない場合、新たに構築したオブジェクトの当該メッセージ自身のプロパティは、 ToString(message) に設定されます。</p>
    <h3 id="15-11-7-5-nativeerror-">15.11.7.5 NativeError コンストラクタのプロパティ</h3>
    <p>　 NativeErrorコンストラクタの内部プロパティ[[Prototype]]の値は、Functionプロトタイプオブジェクト(15.3.4)です。</p>
    <p>　また、当該内部プロパティ、(値が1である)lengthプロパティ、NativeErrorコンストラクタは、次のプロパティも持ちます。</p>
    <h3 id="15-11-7-6-nativeerror-prototype">15.11.7.6 NativeError.prototype</h3>
    <p>　 NativeError.prototype の初期値は、NativeErrorプロトタイプオブジェクト(15.11.7.7)です。</p>
    <p>　各NativeErrorコンストラクタは、個別のプロトタイプオブジェクトを持ちます。 このプロパティは、属性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false } を持ちます。</p>
    <h3 id="15-11-7-7-nativeerror-">15.11.7.7 NativeErrorプロトタイプオブジェクトのプロパティ</h3>
    <p>　各NativeErrorプロトタイプオブジェクトは、任意のErrorオブジェクト(、[[Class]]は、“Error”)です。</p>
    <p>　各NativeErrorプロトタイプオブジェクトの内部プロパティ[[Prototype]]の値は、標準組み込みErrorプロトタイプオブジェクト(15.11.4)です。</p>
    <h3 id="15-11-7-8-nativeerror-prototype-constructor">15.11.7.8 NativeError.prototype.constructor</h3>
    <p>　与えられるNativeErrorコンストラクタにおけるプロトタイプのコンストラクタのプロパティの初期値は、NativeErrorコンストラクタ関数それ自身(15.11.7)です。</p>
    <h3 id="15-11-7-9-nativeerror-prototype-name">15.11.7.9 NativeError.prototype.name</h3>
    <p>　与えられるNativeErrorコンストラクタにおけるプロトタイプのプロパティ名の初期値は、当該コンストラクタの名称(NativeErrorの代わりに使用した名称)です。</p>
    <h3 id="15-11-7-10-nativeerror-prototype-message">15.11.7.10 NativeError.prototype.message</h3>
    <p>　与えられるNativeErrorコンストラクタにおけるプロトタイプのmessageプロパティの初期値は、カラの文字列です。</p>
    <p>[注釈]</p>
    <p>　NativeErrorコンストラクタにおけるプロトタイプは、自分自身は、toString関数を提供しませんが、エラーのインスタンスは、Errorプロトタイプオブジェクトからそれを継承します。</p>
    <h3 id="15-11-7-11-nativeerror-">15.11.7.11 NativeError インスタンスのプロパティ</h3>
    <p>　 NativeErrorインスタンスは、それらのNativeErrorプロトタイプオブジェクトと値が“Error”であるそれらの内部プロパティ[[Class]]から継承します。</p>
    <p>　 NativeErrorインスタンスは、特別なプロパティを何も持ちません。</p>
    <h2 id="15-12-json-the-json-object-standard-ecma-262-5-1-edition">15.12 JSON オブジェクト / The JSON Object / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="15-ecmascript-">15 標準組み込みECMAScriptオブジェクト</h3>
    <h3 id="15-12-json-">15.12 JSON オブジェクト</h3>
    <p>　JSONオブジェクトは、JSONテキストを解析し、構築する為に使用される parse と stringify という2つの関数を含む単一のオブジェクトです。</p>
    <p>　JSON Data Interchange Format (JSONデータ変換書式) は、 RFC 4627 <a href="http://www.ietf.org/rfc/rfc4627.txt">\<a href="http://www.ietf.org/rfc/rfc4627.txt\">http://www.ietf.org/rfc/rfc4627.txt\</a></a> で説明されます。</p>
    <p>　この仕様内で使用した JSON Data Interchange Format (JSONデータ変換書式) は、2つの例外があるものの(、それ以外は、) RFC 4627 で説明したものと全く同じです。</p>
    <ul>
        <li>ECMAScriptのJSONの文法のトップレベルの JSONText プロダクションは、 RFC 4627 によって指定したような任意の JSONObject や任意の JSONArray の存在を制限したものではなく、何らかの JSONValue から構成される場合があります。</li>
        <li>JSON.parse と JSON.stringify の実装に準拠するということは、書式への削除や拡張なしで、この仕様内で定義した確実な書式変換をサポートしなければならないということです。これは、非JSON書式と拡張を許容するJSONパーサーを許可する RFC 4627 とは異なります。</li>
    </ul>
    <p>　 JSONオブジェクトの内部プロパティ[[Prototype]]の値は、標準組み込みObjectプロトタイプ(15.2.4)です。 JSONオブジェクトの内部プロパティ[[Class]]の値は、“JSON”です。 JSONオブジェクトの内部プロパティ[[Extensible]]の値は、trueに設定されます。</p>
    <p>　 JSONオブジェクトは、内部プロパティ[[Construct]]を持たず、new 演算子を伴うコンストラクタとしてJSONオブジェクトを使用することはできません。 JSONオブジェクトは、内部プロパティ[[Call]]を持たず、関数としてJSONオブジェクトを呼び出すことはできません。</p>
    <h2 id="15-12-1-json-the-json-grammar-standard-ecma-262-5-1-edition">15.12.1 JSONの文法 / The JSON Grammar / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="15-ecmascript-">15 標準組み込みECMAScriptオブジェクト</h3>
    <h3 id="15-12-json-">15.12 JSON オブジェクト</h3>
    <h3 id="15-12-1-json-">15.12.1 JSONの文法</h3>
    <p>　 JSON.stringify は、次のJSONの文法に準拠する文字列を生成します。 JSON.parse は、JSONの文法に準拠する文字列を許容します。</p>
    <h3 id="15-12-1-1-json-">15.12.1.1 JSONの語彙的な文法</h3>
    <p>　 JSONは、SourceCharacterの規則と一致する複数文字の並びから構成される中にあるECMAScriptのソーステキストに似ています。 JSONの語彙的な文法は、ECMAScriptのソーステキストのトークン(字句)を定義するECMAScriptの語彙的な文法における方法に似たJSONテキストを作り上げるトークンを定義します。 JSONの語彙的な文法は、プロダクションJSONWhiteSpaceによって定義したホワイトスペース文字を認識するだけです。 JSONの語彙的な文法は、ECMAScriptの語彙的な文法を伴う一部のプロダクションを共有します。 文字“JSON”を伴って始まらない文法上の全ての非終端記号は、ECMAScriptの語彙的な文法のプロダクションによって定義されます。</p>
<pre><code>【構文】
    JSONWhiteSpace ::
    &lt;TAB&gt;
    &lt;CR&gt;
    &lt;LF&gt;
    &lt;SP&gt;

    JSONString ::
    &quot; JSONStringCharactersopt &quot;

    JSONStringCharacters ::
    JSONStringCharacter JSONStringCharactersopt

    JSONStringCharacter ::
    &quot;  、 \ 、または、U+0000 から U+001F までの何れでもない SourceCharacter
    \ JSONEscapeSequence

    JSONEscapeSequence ::
    JSONEscapeCharacter
    UnicodeEscapeSequence

    JSONEscapeCharacter ::
    &quot; / \ b f n r t
    の何れか1つ

    JSONNumber ::
    -opt DecimalIntegerLiteral JSONFractionopt ExponentPartopt

    JSONFraction ::
    . DecimalDigits

    JSONNullLiteral ::
    NullLiteral

    JSONBooleanLiteral ::
    BooleanLiteral
</code></pre><h3 id="15-12-1-2-json-">15.12.1.2 JSON 構文の文法</h3>
    <p>　 JSON構文の文法は、JSONの語彙的な文法によって定義したトークン(字句)の用語にある有効なJSONテキストを定義します。 その文法の目標シンボルは、JSONText です。</p>
<pre><code>【構文】
    JSONText :
    JSONValue

    JSONValue :
    JSONNullLiteral
    JSONBooleanLiteral
    JSONObject
    JSONArray
    JSONString

    JSONNumber JSONObject :
    { }
    { JSONMemberList }

    JSONMember :
    JSONString : JSONValue

    JSONMemberList :
    JSONMember
    JSONMemberList , JSONMember

    JSONArray :
    [ ]
    [ JSONElementList ]

    JSONElementList :
    JSONValue
    JSONElementList , JSONValue
</code></pre><h2 id="15-12-2-parse-text-reviver-standard-ecma-262-5-1-edition">15.12.2 parse ( text [ , reviver ] ) / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="15-ecmascript-">15 標準組み込みECMAScriptオブジェクト</h3>
    <h3 id="15-12-json-">15.12 JSON オブジェクト</h3>
    <h3 id="15-12-2-parse-text-reviver-">15.12.2 parse ( text [ , reviver ] )</h3>
    <p>　 parse関数は、JSONテキスト(JSON書式化文字列)を解析し、ECMAScriptの値を生成します。 JSONフォーマット(書式)には、ECMAScriptのリテラルによる制限があります。 JSONのオブジェクトは、ECMAScriptのオブジェクトとして理解されます。 JSONの配列は、ECMAScriptの配列として理解されます。 JSONの文字列、数値、ブール(ブーリアン)、null は、ECMAScriptの文字列、数値、ブール(ブーリアン)、nullとして理解されます。 JSONは、エスケープシーケンスを使用することなく、直接 JSONString 内に現れる、より限定した WhiteSpace 以外のホワイトスペース文字の集合とUnicodeコードポイント U+2028 及び U+2029 を許容します。 解析の処理は、JSONの文法による制約を持たせた 11.1.4 と 11.1.5 に似ています。</p>
    <p>　オプションの reviver パラメータは、2つのパラメータ( key と value )を取る関数です。 それは、結果をフィルタし、変換することが可能です。 それは、解析により処理した key / value のペアのそれぞれを伴って呼ばれ、その戻り値は、オリジナルの値の代わりに使用されます。 それが、受け取ったものを返す場合、その構造は、変更されません。 それが、undefinedを受け取る場合、そのプロパティは、その結果から削除されます。</p>
<pre><code>1. JText は、 ToString(text) とする
    2. 15.12.1 にある文法を使って JText を解析する
    JText が、目標記号 JSONText における JSON の文法と一致しない場合、SyntaxError例外を投げる(スローする)
    3. unfiltered は、ECMAScriptのプログラムのソーステキストだったが、StringLiteral の 場所で JSONString を使用中であるかのように JText を解析、評価した結果とする
    JText からJSONの文法との一致における注釈として、この結果は、任意の ArrayLiteral や任意の ObjectLiteral の何れかによって定義される任意の原始的な(プリミティブ)値や任意のオブジェクトの何れかになるでしょう。
    4. IsCallable(reviver) が、 true である場合、
    a. root は、その名を伴う標準組み込みコンストラクタである Object について式 new Object() によるかのように生成した新たなオブジェクトとする
    b.引数としてカラの文字列、PropertyDescriptor {[[Value]]: unfiltered, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}、 false を伴う root の内部メソッド[[DefineOwnProperty]]を呼ぶ
    c. root とカラの文字列を解析し、抽象操作Walkを呼んだ結果を返す
    抽象操作 Walk は、以下で説明される
    5.それ以外の場合、
    a. unfiltered を返す
</code></pre><p>　抽象操作 Walk は、holder オブジェクトとそのオブジェクトにあるプロパティとしてString型の name という2つのパラメータ取る再帰的な抽象操作です。 Walk は、上記のparse関数に渡した元となった reviver の値を使用します。</p>
<pre><code>1. val は、引数 name を伴う holder の内部メソッド[[Get]]を呼んだ結果とする
    2. val が、オブジェクトである場合、
    a. val の内部プロパティ[[Class]]が、&quot;Array&quot; である場合、
    i. I に 0 を設定する
    ii. len は、引数&quot;length&quot;を伴う val の内部メソッド[[Get]]を呼んだ結果とする
    iii. I &lt; len である間、繰り返す
    1. newElement は、 val と ToString(I) を渡して抽象操作 Walk を呼んだ結果とする
    2. newElement が、 undefined である場合、引数として ToString(I) と false を伴う val の内部メソッド[[Delete]]を呼ぶ
    3.それ以外の場合、
    a 引数 ToString(I)、プロパティ記述子 {[[Value]]: newElement, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}、 false を伴う val の内部メソッド[[DefineOwnProperty]]を呼ぶ
    4.  I に 1 を追加する
    b.それ以外の場合、
    i. keys は、[[Enumerable]]属性が、trueである val の自身のプロパティ全ての名称から成るString値である内部リストとする
    文字列の順番は、標準組み込み関数 Object.keys によって使用したものと同じにすべきである
    ii. keys 内のString P ごとに実行
    1. newElement は、 val と P を渡して抽象操作 Walk を呼んだ結果とする
    2. newElement が、 undefinedである場合、引数として P と false を伴う val の内部メソッド[[Delete]]を呼ぶ
    3.それ以外の場合、
    a 引数 P 、プロパティ記述子 {[[Value]]: newElement, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}、 false を伴う val の内部メソッド[[DefineOwnProperty]]を呼ぶ
    3. this 値としての holder と name と val から成る引数リストを共に渡し、 reviver の内部メソッド[[Call]]を呼んだ結果を返す
</code></pre><p>　 JSONの文法を拡張する為の JSON.parse の実装との一致については許可されません。 実装が、JSONの内部変換書式を変更または拡張したサポートをしたい場合、別途parse関数を定義することによってそれをしなければいけません。</p>
    <p>[注釈]</p>
    <p>　任意のオブジェクト内でname文字列が重複することがあるケースについては、同一のキーにおいて語彙的に先行する値は、上書きするようにしましょう。</p>
    <h2 id="15-12-3-stringify-value-replacer-space-standard-ecma-262-5-1-edition">15.12.3 stringify ( value [ , replacer [ , space ] ] ) / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="15-ecmascript-">15 標準組み込みECMAScriptオブジェクト</h3>
    <h3 id="15-12-json-">15.12 JSON オブジェクト</h3>
    <h3 id="15-12-3-stringify-value-replacer-space-">15.12.3 stringify ( value [ , replacer [ , space ] ] )</h3>
    <p>　 stringify(文字列化)関数は、ECMAScriptの値を表すJSON形式の文字列を返します。 それは、3つのパラメータを取ります。 1つめのパラメータは、必須です。 value パラメータは、ECMAScriptの値であり、それは通常のオブジェクトや配列で文字列、ブール(ブーリアン)、数値、null でも可です。 オプションの replacer パラメータは、オブジェクトと配列が文字列化される方法や文字列化されるであろうオブジェクトのプロパティを選択することによってホワイトリストとして動作する文字列と数値の配列の何れかを変更する機能です。 オプションの space パラメータは、人間が読解可能なことを保証する為にそれに挟んみ込んだホワイトスペースのある結果を許容する文字列や数値です。</p>
    <p>　これらは、任意のオブジェクトを文字列化する際のステップです。</p>
<pre><code>1. stack は、カラのリストとする
    2. indent は、カラの文字列とする
    3. PropertyList と ReplacerFunction は、 undefined とする
    4. Type(replacer) が、 Object である場合、
    a. IsCallable(replacer) が、 true である場合、
    i. ReplacerFunction は、 replacer とする
    b. replacer の内部プロパティ[[Class]]が、&quot;Array&quot; である場合、
    i. PropertyList は、カラの内部リストとする
    ii. replacer のプロパティの値 v ごとに配列インデックスプロパティ名を持つ
    プロパティは、それらの名称の配列インデックス順における昇順で列挙される
    1. item は、 undefined とする
    2. Type(v) が、 String である場合、 item は、 v とする
    3. Type(v) が、 Number である場合、 item は、 ToString(v) とする
    4. Type(v) が、 Object である場合、
    a  v の内部プロパティ[[Class]]が、&quot;String&quot; または、 &quot;Number&quot; である場合、 item は、 ToString(v) とする
    5. item が、undefined でなく、且つ、 item が、現在の PropertyList の要素ではない場合、
    a  PropertyList の末尾に item を付加する
    5. Type(space) が、 Object である場合、
    a. space の内部プロパティ[[Class]]が、&quot;Number&quot;である場合、
    i. space は、 ToNumber(space) とする
    b. space の内部プロパティ[[Class]]が、&quot;String&quot;である場合、
    i. space は、 ToString(space) とする
    6. Type(space) が、 Number である場合、
    a. space は、 min(10, ToInteger(space)) とする
    b. gap に空白文字 space を含むStringを設定する
    これは、 space が、1よりも小さい場合、カラの文字列となるでしょう。
    7.  Type(space) が、 String である場合、
    a. space 内にある文字数が、 10未満である場合、 gap に space を設定し、それ以外の場合、 gap に space の最初の10文字を含む文字列を設定
    8.それ以外の場合、
    a. gap にカラの文字列を設定する
    9. wrapper は、その名称を持つ標準組み込みコンストラクタであるObjectを式 new Object() によるかのように生成した新たなオブジェクトとする
    10.引数にカラの文字列、プロパティ記述子  {[[Value]]: value, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}、 false を伴う wrapper の内部メソッド[[DefineOwnProperty]]を呼ぶ
    11.カラの文字列と wrapper を伴う抽象操作 Str を呼んだ結果を返す
</code></pre><p>　抽象操作 Str(key, holder) は、stringifyメソッドの呼び出しによる ReplacerFunction へのアクセスを持ちます。 そのアルゴリズムは、次のようになります。</p>
<pre><code>1. value は、引数 key を伴う holder の内部メソッド[[Get]]を呼んだ結果とする
    2. Type(value) が、 Object である場合、
    a. toJSON は、引数  &quot;toJSON&quot;を伴う value の内部メソッド[[Get]]を呼んだ結果とする
    b. IsCallable(toJSON) が、 true である場合、
    i. value は、 this 値として value と keyから構成される引数リストを渡して toJSON の内部メソッド[[Call]]を呼んだ結果とする
    3. ReplacerFunction が、 undefined ではない場合、
    a. value は、 this 値として holder と key と value で構成される引数リストを渡して ReplacerFunction の内部メソッド[[Call]]を呼んだ結果とする
    4. Type(value) が、 Object である場合、
    a. value の内部プロパティ[[Class]]が、&quot;Number&quot;である場合、
    i. value は、 ToNumber(value) とする
    b. value の内部プロパティ[[Class]]が、&quot;String&quot;である場合、
    i. value は、 ToString(value) とする
    c. value の内部プロパティ[[Class]]が、&quot;Boolean&quot;である場合、
    i.  value は、value の内部プロパティ[[PrimitiveValue]]の値とする
    5. value が、 null である場合、&quot;null&quot;を返す
    6. value が、 true である場合、&quot;true&quot;を返す
    7. value が、 false である場合、&quot;false&quot;を返す
    8. Type(value) が、 String である場合、引数 value を伴う抽象操作 Quote を呼んだ結果を返す
    9. Type(value) が、 Number である場合、
    a. value が、有限である場合、 ToString(value) を返す
    b.それ以外の場合、&quot;null&quot;を返す
    10. Type(value) が、 Object、且つ、 IsCallable(value) が、 false である場合、
    a. value の内部プロパティ[[Class]]が、&quot;Array&quot;である場合、
    i.引数 value を伴う抽象操作 JA を呼んだ結果を返す
    b.それ以外の場合、引数 value を伴う抽象操作 JO を呼んだ結果を返す
    11. undefined を返す
</code></pre><p>　抽象操作 Quote(value) は、その中にあるダブルクォートとエスケープ文字内の文字列値を囲みます。</p>
<pre><code>1. product は、ダブルクォート文字とする
    2. value 内の文字 C ごとに
    a. C が、ダブルクォート文字、または、バックスラッシュ文字である場合、
    i. product は、 product とバックスラッシュ文字を連結したものとする
    ii. product は、 product と C を連結したものとする
    b. C が、バックスペース、フォームフィード、ニューライン、キャリッジリターン、タブ である場合、
    i. product は、 product とバックスラッシュ文字を連結したものとする
    ii. abbrev は、次のような C の値と一致する文字とする
    backspace       &quot;b&quot;
    formfeed        &quot;f&quot;
    newline         &quot;n&quot;
    carriage return &quot;r&quot;
    tab         &quot;t&quot;
    iii. product は、 product と abbrev を連結したものとする
    c. C が、その空白文字よりも小さいコードユニット値を持つ制御文字である場合、
    i. product は、 product とバックスラッシュ文字を連結したものとする
    ii. product は、 product と &quot;u&quot; を連結したものとする
    iii. hex は、 C の数値のコードユニット値を4つの16進数から成る文字列に変換した結果とする
    iv. product は、 product と hex を連結したものとする
    d.それ以外の場合、
    i. product は、 product と C を連結したものとする
    3. product は、 product とダブルクォート文字を連結したものとする
    4. product を返す
</code></pre><p>　抽象操作 JO(value) は、任意のオブジェクトをシリアライズします。 stringify メソッドの呼び出しとして stack、 indent、 gap、 PropertyList、 ReplacerFunction、 space へのアクセス権を持ちます。</p>
<pre><code>1. stack が、 value を含む場合、構造が循環的(循環構造)である為、TypeError例外を投げる(スローする)
    2. stack に value を付加
    3. stepback は、 indent とする
    4. indent は、 indent と gap を連結したものとする
    5. PropertyList が、undefined ではない場合、
    a. K は、 PropertyList とする
    6.それ以外の場合、
    a. K は、[[Enumerable]]属性がtrueである value 自身のプロパティ全ての名称から成る文字列の内部リストとする
    文字列の順序は、標準組み込み関数 Object.keys によって使用したのと同様とすべき
    7. partial は、カラのリストとする
    8. K の要素 P ごとに
    a. strP は、引数 P と value を伴う抽象操作 Str を呼んだ結果とする
    b. strP が、 undefined ではない場合、
    i. member は、引数 P を伴う抽象操作 Quote を呼んだ結果とする
    ii. member は、 member とコロン文字を連結したものとする
    iii. gap がカラの文字列ではない場合、
    1. member は、 member と空白文字を連結したものとする
    iv. member は、 member と strP を連結したものとする
    v. partial に member を付加する
    9. partial がカラである場合、
    a. final は、 &quot;{}&quot; とする
    10.それ以外の場合、
    a. gap が、カラの文字列である場合、
    i. properties は、カンマ文字を伴って分割した文字列の隣接するペアごとの一部の要素の文字列全てを連結することによって形成した文字列とする
    カンマは、最初の文字列の前、または、最後の文字列の後の何れかには挿入されない
    ii. final は、&quot;{&quot;、 properties 、 &quot;}&quot; を連結した結果とする
    b.それ以外の場合、 gap は、カラの文字列ではなく、
    i. separator は、カンマ文字、ラインフィード文字、 indent を連結した結果とする
    ii. properties は、セパレータを伴って分割した文字列の隣接するペアごとに一部の要素の文字列全てを連結することによって形成した文字列とする
    セパレータ文字列は、最初の文字列の前、または、最後の文字列の後の何れかには挿入されない
    iii. final は、 &quot;{&quot;、 そのラインフィード文字、 indent、 properties、そのラインフィード文字、stepback、&quot;}&quot; を連結した結果とする
    11. stack の最後の要素を削除する
    12. indent は、 stepback とする
    13. final を返す
</code></pre><p>　抽象操作 JA(value) は、任意の配列をシリアライズします。 stringifyメソッドの呼び出しとして stack, indent, gap, space へのアクセス権を持ちます。 配列の表現としては、ゼロと array.length - 1 を含むその間の要素のみを含みます。 名前付きプロパティは、文字列化から除外されます。 任意の配列は、開始左ブラケット、カンマ区切りの要素、閉じ右ブラケットとして文字列化されます。</p>
<pre><code>1. stack が、 value を含む場合、構造が循環する為、TypeError例外を投げる(スローする)
    2. stack に value を付加(追加)
    3. stepback は、 indent とする
    4. indent は、 indent と gap の連結したものとする
    5. partial は、カラのリストとする
    6. len は、引数&quot;length&quot;を伴う value の内部メソッド[[Get]]を呼んだ結果とする
    7. index は、 0 とする
    8. while index &lt; len という条件下で繰り返す
    a. strP は、引数 ToString(index) と value を伴う抽象操作 Str を呼んだ結果とする
    b. strP が、 undefined である場合、
    i. partial に &quot;null&quot; を付加(追加)
    c.それ以外の場合、
    i. partial に strP を付加(追加)
    d. index を1で増分する
    9. partial が、カラである場合、
    a. final は、 &quot;[]&quot; とする
    10.それ以外の場合、
    a. gap が、カラの文字列である場合、
    i. properties は、カンマ文字を伴って分割した隣接する文字列のペアごとに partial の要素文字列全てを連結することによって形成した文字列とする
    カンマは、最初の文字列の前、または、最後の文字列の後に挿入されることはないものとする
    ii. final は、 &quot;[&quot;, properties, &quot;]&quot; を連結した結果とする
    b. それ以外の場合、
    i. separator は、カンマ文字、ラインフィード文字、 indent を連結した結果とする
    ii. properties は、セパレータで区切られた隣接する文字列のペアごとに partial の要素文字列全てを連結することによって形成した文字列とする
    セパレータ文字は、最初文字列の前、または、最後の文字列の後に挿入されることはないものとする
    iii. final は、&quot;[&quot;、 そのラインフィード文字、indent 、 properties 、そのラインフィード文字、 stepback 、&quot;]&quot; を連結した結果とする
    11. stack の最後の要素を削除する
    12. indent は、 stepback とする
    13. final を返す
</code></pre><p>[注釈 1]</p>
    <p>　 JSON構造は、任意の深さにネストされることが許容されますが、非循環としなければいけません。 value が存在したり、循環構造を含む場合、stringify関数は、TypeError例外を投げ(スローし)ます。</p>
    <p>　これは、文字列化されることができない値の例です。</p>
<pre><code>a = [];
    a[0] = a;
    my_text = JSON.stringify(a); // これは、TypeErrorを投げなければいけない
</code></pre><p>[注釈 2]</p>
    <p>　シンボリックプリミティブ値は、次のように描画(レンダリング)されます。</p>
    <ul>
        <li>null 値は、文字列 null としてJSONテキスト内で描画されます。</li>
        <li>undefined 値は、描画されません。</li>
        <li>true 値は、文字列 true としてJSONテキスト内で描画されます。</li>
        <li>false 値は、文字列 false としてJSONテキスト内で描画されます。</li>
    </ul>
    <p>[注釈 3]</p>
    <p>　 String値は、ダブルクォートで囲います。 文字 &quot; と \ は、接頭辞 \ でエスケープされます。 制御文字は、エスケープシーケンス \uHHHH や略記 \b (backspace), \f (formfeed), \n (newline), \r (carriage return), \t (tab) で置換されます。</p>
    <p>[注釈 4]</p>
    <p>　有限の数値は、 ToString(number) を呼ぶことによるかのように文字列化されます。 符号に関わらず、NaN と無限大は、文字列 null として表現されます。</p>
    <p>[注釈 5]</p>
    <p>　(undefinedと関数のような)JSON表現を持たない値は、文字列を生成しません。 代わりにそれらは、undefined(未定義)値を生成します。 配列内のこれらの値は、文字列 null として表現されます。 オブジェクト内の表現できない値は、文字列化から除外されるプロパティの要因になります。</p>
    <p>[注釈 6]</p>
    <p>　任意のオブジェクトは、ゼロ個以上のプロパティが続く開始左波かっこ(brace)、カンマ区切り、右閉じ波かっことして描画されます。 任意のプロパティは、キーやプロパティ名、コロン、それから文字列化したプロパティ値を表しているクォートした文字列です。 任意の配列は、ゼロ個以上の値が続く左開始ブラケット(角かっこ)、カンマ区切り、右閉じブラケットとして描画されます。</p>
    <h2 id="16-errors-standard-ecma-262-5-1-edition">16 エラー / Errors / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="16-">16 エラー</h3>
    <p>　実装は、関連するECMAScript言語の構成が評価される場合には、ほぼ全てに渡り、エラーを報告しなければいけません。 初期エラーとは、そのエラーを含んでいるプログラム内にある構成の評価に優先して検出、報告されることが可能なエラーです。 実装は、当該プログラムの最初の評価に優先してプログラム内の初期エラーを報告しなければいけません。 eval コード内の初期エラーは、 eval が呼ばれた時点で報告されますが、それは eval コード内の任意の構成の評価に優先して報告されます。 初期エラーではない全てのエラーは、実行エラーです。</p>
    <p>　実装は、初期エラーとしての次のエラーの種類のインスタンスを扱わなければいけません。</p>
    <ul>
        <li>任意の構文エラー</li>
        <li>同名で割り当てられる複数の get プロパティや同名で割り当てられる複数の set プロパティを持つ ObjectLiteral を定義する試行</li>
        <li>割り当てられるデータプロパティと同名で割り当てられる複数の get や set プロパティの両方を持つ ObjectLiteral を定義する試行</li>
        <li>実装定義の構文の拡張ではない正規表現リテラル内のエラー</li>
        <li>同名で割り当てられる複数のデータプロパティを持つ ObjectLiteral を定義するstrictモードのコード内での試行</li>
        <li>strictモードのコード内での WithStatement (With 文)の出現</li>
        <li>単独のstrictモードの FunctionDeclaration (関数宣言)や FunctionExpression (関数式)から成る任意の FormalParameterList (関数のパラメータリスト)内で1度以上現れる Identifier (識別子)の値の出現</li>
        <li>return, break, continue の不適切な使用</li>
        <li>(例えば、代入文 3=4 を実行する等)リファレンスではない値を生成されることが可能な初期決定における任意の値上で PutValue を呼ぶ試行</li>
    </ul>
    <p>　実装は、いかなる状況においてもエラーなく実行できない構成であることを裏付けることが可能なコンパイラであったとしても初期エラーとして他の種類のエラーを扱わないようにしましょう。 実装は、そのようなケースにおいては初期警告を発する場合があるにしても関連する構成が、実際に実行されるまでは、エラーを報告すべきではありません。</p>
    <p>　実装は、次の場合を除き、既に記述したように全てのエラーを報告しましょう。</p>
    <ul>
        <li>実装が、プログラム構文、正規表現構文、フラグ構文などを拡張する可能性がある場合
            これを許容するということは、( eval の呼び出し、正規表現リテラルの使用、 FunctionコンストラクタやRegExpコンストラクタの使用のような)全ての操作は、プログラム構文、正規表現構文、フラグ構文などへの実装定義の拡張に遭遇する場合、SyntaxErrorを投げる(スローする)代わりに実装定義の動作を表す為に実行されるSyntaxErrorを投げる(スローする)ことが許容されるという事です。</li>
        <li>実装が、この仕様内で説明したそれらを超える型、値、オブジェクト、プロパティ、関数を提供する場合
            これは、( ReferenceError のような)エラーを投げる(スローする)代わりに実装定義の動作を持つように(グローバルスコープ内で変数を探すような)構成の要因となる場合があります。</li>
        <li>実装が、 fractionDigits (小数の桁)引数や precision (精度)引数が、指定した範囲を超える際に toFixed, toExponential, toPrecision の為にRangeErrorを投げる(スローする)のではなく、動作を定義する場合</li>
    </ul>
    <h2 id="-a-standard-ecma-262-5-1-edition">付録 A (有用情報) 文法の要約 / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="-a-">付録 A (有用情報) 文法の要約</h3>
    <p><a href="">A.1 語彙的な文法</a></p>
    <p><a href="">A.2 Number 変換</a></p>
    <p><a href="">A.3 式</a></p>
    <p><a href="">A.4 ステートメント・文</a></p>
    <p><a href="">A.5 関数とプログラム</a></p>
    <p><a href="">A.6 Universal Resource Identifier / URI 文字クラス</a></p>
    <p><a href="">A.7 正規表現</a></p>
    <p><a href="">A.8 JSON</a></p>
    <p>–<a href="">A.8.1 JSONの語彙的な文法</a></p>
    <p>–<a href="">A.8.2 JSON構文の文法</a></p>
    <h2 id="-b-standard-ecma-262-5-1-edition">付録 B (有益な情報) 互換性 Standard ECMA-262 5.1 Edition</h2>
    <h3 id="-b-">付録 B (有益な情報) 互換性</h3>
    <h3 id="b-1-">B.1 追加構文</h3>
    <p>　ECMAScriptの過去の版(エディション)には、8進数リテラルと8進数エスケープシーケンス指定の為の追加構文と追加セマンティックスが含まれていました。 (しかし、)これらは、ECMAScriptのこの版(エディション)からは削除されています。 この非標準の添付書では、一部の古いECMAScriptプログラムに伴う互換性において8進数リテラルと8進数エスケープシーケンスの為の一定の構文とセマンティックスを提示します。</p>
    <h3 id="b-1-1-">B.1.1 数値リテラル</h3>
    <p>　 7.8.3 の構文とセマンティックスは、strictモードのコードにおいて許容されないこの拡張を除き、次のように拡張することが可能です。</p>
<pre><code>【構文】
    NumericLiteral ::
    DecimalLiteral
    HexIntegerLiteral
    OctalIntegerLiteral

    OctalIntegerLiteral ::
    0 OctalDigit
    OctalIntegerLiteral OctalDigit

    OctalDigit ::
    0 1 2 3 4 5 6 7
    の内の1つ

    【セマンティックス】
    ・ NumericLiteral の  MV  :: OctalIntegerLiteral は、 OctalIntegerLiteral の MV
    ・ OctalDigit の  MV  :: 0 は、 0
    ・ OctalDigit の  MV  :: 1 は、 1
    ・ OctalDigit の  MV  :: 2 は、 2
    ・ OctalDigit の  MV  :: 3 は、 3
    ・ OctalDigit の  MV  :: 4 は、 4
    ・ OctalDigit の  MV  :: 5 は、 5
    ・ OctalDigit の  MV  :: 6 は、 6
    ・ OctalDigit の  MV  :: 7 は、 7
    ・ OctalIntegerLiteral の  MV :: 0 OctalDigit は、 OctalDigit の MV
    ・ OctalIntegerLiteral の  MV :: OctalIntegerLiteral OctalDigit は、 ( OctalIntegerLiteral の MV 8通り ) OctalDigit の MV をプラス
</code></pre><h3 id="b-1-2-">B.1.2 文字列リテラル</h3>
    <p>　 7.8.4 の構文とセマンティックスは、strictモードのコードにおいて許容されないこの拡張を除き、次のように拡張することが可能です。</p>
<pre><code>【構文】
    EscapeSequence ::
    CharacterEscapeSequence
    OctalEscapeSequence
    HexEscapeSequence
    UnicodeEscapeSequence

    OctalEscapeSequence ::
    OctalDigit[lookahead ? DecimalDigit]
    ZeroToThree OctalDigit [lookahead ? DecimalDigit]
    FourToSeven OctalDigit
    ZeroToThree OctalDigit
    (？は、∈の否定形)

    OctalDigit ZeroToThree ::
    0 1 2 3
    の1つ

    FourToSeven ::
    4 5 6 7
    の1つ

    【セマンティックス】
    ・  EscapeSequence の CV  :: OctalEscapeSequence は、OctalEscapeSequence の CV
    ・  OctalEscapeSequence の CV  :: OctalDigit [lookahead ? DecimalDigit] は、 コードユニット値が OctalDigit の  MV である文字
    ・  OctalEscapeSequence の CV  :: ZeroToThree OctalDigit [lookahead ? DecimalDigit] は、 コードユニット値が ( ZeroToThree の  MV を8通り) OctalDigit の  MV をプラス
    ・  OctalEscapeSequence の CV  :: FourToSeven OctalDigit は、 コードユニット値が  (  FourToSeven の  MV を8通り) OctalDigit の  MV をプラス
    ・  OctalEscapeSequence の CV  :: ZeroToThree OctalDigit OctalDigit は、 コードユニット値が ( ZeroToThree の MV の64(つまり8の2乗)通り) プラス (8 times the MV of the first OctalDigit の MV 8通り) プラス 2つめの OctalDigit の MV の文字
    ・  ZeroToThree の  MV  :: 0 は、 0
    ・  ZeroToThree の  MV  :: 1 は、 1
    ・  ZeroToThree の  MV  :: 2 は、 2
    ・  ZeroToThree の  MV  :: 3 は、 3
    ・  FourToSeven の  MV  :: 4 は、 4
    ・  FourToSeven の  MV  :: 5 は、 5
    ・  FourToSeven の  MV  :: 6 は、 6
    ・  FourToSeven の  MV  :: 7 は、 7
</code></pre><h3 id="b-2-">B.2 追加プロパティ</h3>
    <p>　ECMAScriptの一部の実装は、標準ネイティブオブジェクトの一部について追加プロパティを含みます。 この非標準の添付書では、この標準規格のプロパティやそれらのセマンティックス部分を作成することなく、このようなプロパティと同一のセマンティックスを示唆しています。</p>
    <h3 id="b-2-1-escape-string-">B.2.1 escape (string)</h3>
    <p>　 escape関数は、グローバルオブジェクトのプロパティです。 16進数エスケープシーケンスによって置換される特定の文字において文字列値の新しいバージョンを算出します。 それらの文字については、コードユニット値が 0xFF 、または、より小さい場合、書式 %xx という2ケタのエスケープシーケンス付きで置換されます。 それらの文字については、コードユニット値が 0xFF より大きい場合、書式 %uxxxx という4ケタ以下のエスケープシーケンス付きで置換されます。</p>
    <p>　 escape関数は、引数 string を1つ取って呼ばれる際には、次のステップが取られます。</p>
<pre><code>1. ToString(string) を呼ぶ
    2. 1項の結果内の文字数を算出する
    3. R は、カラの文字列とする
    4. k は、0とする
    5. k が、2項の数と等しい場合、R を返す
    6. 1項の結果内の位置 k にある(16ビット符号なし整数として表現した)文字を取得する
    7. 6項の結果が、ブランクのない69文字“ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789@*_+-./” である場合、ステップ13へ
    8. 6項の結果が、256よりも小さい場合、ステップ11へ
    9.  wxyz が、6項の結果の値である4つの16進数のエンコード方式である場合、 S は、“%uwxyz”という6文字を含んだ文字列とする
    10.ステップ14へ
    11. xy が、6項の結果の値である2つの16進数のエンコード方式である場合、 S は、“%xy”という3文字を含んだ文字列とする
    12.ステップ14へ
    13. S は、単一文字である6項の結果を含む文字列とする
    14. R は、 R の前の値 と S を連結することによって算出した新たな文字列値とする
    15. k を1で増分する
    16. ステップ5へ
</code></pre><p>[注釈]</p>
    <p>　エンコード方式は、部分的に RFC 1738 で説明したエンコード方式に基づきますが、 全体としては、RFC 1738 の内容とみなすことなく上記で説明されるこの標準規格内で指定したエンコード方式となります。 このエンコード方式は、 RFC 3986 によってなされた RFC 1738 への変更の影響は受けません。</p>
    <h3 id="b-2-2-unescape-string-">B.2.2 unescape (string)</h3>
    <p>　 unescape関数は、グローバルオブジェクトのプロパティです。 それは、ソート済みのエスケープシーケンスにおいて文字列値の新たなバージョンを算出し、それが表す文字で置換されるescape関数によって導入される場合があります。</p>
    <p>　 unescape関数が、引数 string を1つ伴って呼ばれる際には、次のステップが取られます。</p>
<pre><code>1. ToString(string) を呼ぶ
    2. 1項の結果内の文字数を算出する
    3. R は、カラの文字列とする
    4. k は、0とする
    5. k が、2項の数と等しい場合、R を返す
    6. c は、1項の結果の位置 k にある文字とする
    7. c が、 % ではない場合、ステップ18へ
    8. k が、 2項の結果-6 よりも大きい場合、ステップ14へ
    9. 1項の結果の位置 k+1 にある文字が、 u ではない場合、ステップ14へ
    10. 1項の結果の位置 k+2, k+3, k+4, k+5 にある4文字が、全て16進数値ではない場合、ステップ14へ
    11. c は、 1項の結果の位置 k+2, k+3, k+4, k+5 にある4つの16進数値によって表した整数であるコードユニット値を持つ文字とする
    12. k を5で増分する
    13. ステップ18へ
    14. k が、2項の結果-3 より大きい場合、ステップ18へ
    15. 1項の結果の位置 k+1 と k+2 にある2文字が、共に16進数ではない場合、ステップ18へ
    16. c は、2つのゼロにプラス1項の結果内の位置 k+1 と k+2 にある2つの16進数値によって表した整数であるコードユニット値を持つ文字とする
    17. kを2で増分する
    18. R は、 Rの前の値 と c を連結することによって算出した新たな文字列値とする
    19. kを1で増分する
    20.ステップ5へ
</code></pre><h3 id="b-2-3-string-prototype-substr-start-length-">B.2.3 String.prototype.substr (start, length)</h3>
    <p>　 substrメソッドは、 start と length という2つの引数を取り、このオブジェクトを文字位置 start から始まり、 length 文字め(、または、 length が、 undefined である場合、当該文字列の末尾)まで走査し、変換した結果の部分文字列を返します。 start が、負の値である場合、 sourceLength が、文字列の length である場合、 (sourceLength+start) として扱われます。 その結果は、String値であってStringオブジェクトではありません。</p>
    <p>　(substrメソッドは、)次のステップが取られます。</p>
<pre><code>1. ToStringを呼び、その引数として this 値を与える
    2. ToInteger(start) を呼ぶ
    3. length が、 undefined である場合、+∞ を使用し、それ以外の場合、 ToInteger(length) を呼ぶ
    4. 1項の結果にある文字数を算出する
    5. 2項の結果が、正の値または、ゼロである場合、2項の結果を使用し、それ以外の場合、 max(Result(4)+Result(2),0) を使用する
    6. min(max(Result(3),0), Result(4)-Result(5)) を算出する(3項、4項、5項の結果を使用して算出)
    7. 6項の結果 ≦ 0 となる場合、カラの文字列 &quot;&quot; を返す
    8. 5項の結果の位置にある文字を伴って始まる1項の結果から6項の結果が連続する複数文字を含む文字列を返す
</code></pre><p>　 substrメソッドのlengthプロパティは、2です。</p>
    <p>[注釈]</p>
    <p>　 substr関数は、汎用的であることが意図され、this 値がStringオブジェクトとなることを要求しません その為、メソッドとして使用される場合、オブジェクトの他の種類に転送することが可能です。</p>
    <h3 id="b-2-4-date-prototype-getyear-">B.2.4 Date.prototype.getYear ( )</h3>
    <p>[注釈]</p>
    <p>　2000年問題を回避することから(このgetYearよりも) getFullYear メソッドの方が、ほぼ全ての目的において好まれます。</p>
    <p>　 getYearメソッドが、引数を伴わずに呼ばれる際には、次のステップが取られます。</p>
<pre><code>1. t は、this 時間値とする
    2. t が、 NaN である場合、NaN を返す
    3. YearFromTime(LocalTime(t)) - 1900 を返す
</code></pre><h3 id="b-2-5-date-prototype-setyear-year-">B.2.5 Date.prototype.setYear (year)</h3>
    <p>[注釈]</p>
    <p>　2000年問題を回避することから(このsetYearよりも) setFullYear メソッドの方が、ほぼ全ての目的において好まれます。</p>
    <p>　 setYearメソッドが、 year という引数1つを伴って呼ばれる際には、次のステップが取られます。</p>
<pre><code>1. t は、 LocalTime(this time value) の結果とするが、 this 時間値が、 NaN である場合、 t は、 +0 とする
    2. ToNumber(year) を呼ぶ
    3. 2項の結果が、NaN である場合、 this 値の内部プロパティ[[PrimitiveValue]]にNaNを設定し、NaNを返す
    4. 2項の結果が、NaN ではなく、且つ、 0 ≦ ToInteger(Result(2)) ≦ 99 (2項の結果を代入)である場合、  ToInteger(Result(2)) + 1900 とし、それ以外の場合、4項の結果は、2項の結果とする
    5. MakeDay(Result(4), MonthFromTime(t), DateFromTime(t)) を算出する
    6. UTC(MakeDate(Result(5), TimeWithinDay(t))) を算出する
    7. this 値の内部プロパティ[[PrimitiveValue]]に TimeClip(Result(6)) を設定する
    8. this 値の内部プロパティ[[PrimitiveValue]] の値を返す
</code></pre><h3 id="b-2-6-date-prototype-togmtstring-">B.2.6 Date.prototype.toGMTString ( )</h3>
    <p>[注釈]</p>
    <p>　(この toGMTString よりも)プロパティ toUTCString が好んで使用されます。 toGMTString プロパティは、古いコードを伴う互換性の為に主に提供されます。 新たなECMAScriptコード内で使用される toUTCString プロパティが推奨されます。</p>
    <p>　 Date.prototype.toGMTString の初期値であるFunctionオブジェクトは、 Date.prototype.toUTCString の初期値であるFunctionオブジェクトと同一です。</p>
    <h2 id="-c-ecmascript-strict-standard-ecma-262-5-1-edition">付録 C (有益な情報) ECMAScriptのStrictモード / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="-c-ecmascript-strict-">付録 C (有益な情報) ECMAScriptのStrictモード</h3>
    <h3 id="strict-">strictモードの制限と例外</h3>
    <ul>
        <li>Identifier(識別子) “implements”, “interface”, “let”, “package”, “private”, “protected”, “public”, “static”, “yield” は、strictモード ( 7.6.12 )内のトークン(字句) FutureReservedWord(将来の予約語) として分類されます。</li>
        <li>準拠する実装は、strictモードのコードを処理中は、 B.1.1 で説明したように OctalIntegerLiteral を含む為に NumericLiteral (7.8.3)の構文を拡張しない場合があります。</li>
        <li>準拠する実装は、strictモードのコードを処理中 ( 10.1.1 参照)は、 B.1.2 で説明したように OctalEscapeSequence(8進エスケープシーケンス) を含む為に EscapeSequence(エスケープシーケンス) の構文を拡張しない場合があります。</li>
        <li>宣言されていない識別子やそれ以外の未解決の参照への関連付けについては、グローバルオブジェクト内でプロパティを生成しません。 単純な関連付けが、strictモードのコード内に現れる場合、その LeftHandSide は、未解決のReference(参照)を評価してはいけません。 評価するとReferenceError例外が投げられ(スローされ)ます(8.7.2)。 LeftHandSide(左辺) は、また、属性値 {[[Writable]]:false} を伴うデータプロパティ、属性値 {[[Set]]:undefined} を伴うアクセサプロパティや内部プロパティ[[Extensible]]が値 false を持つオブジェクトの実在しないプロパティへの参照にはならない場合があります。 これらのケースについては、TypeError例外が投げられ(スローされ)ます(11.13.1)。</li>
        <li>Identifier(識別子) eval や引数は、代入演算子(11.13)や PostfixExpression(後置式) (11.3)の LeftHandSideExpression(左辺式)として、または、前置増分演算子(11.4.4)や減分演算子(11.4.5)によって操作した UnaryExpression(単項式)として現れない場合があります。</li>
        <li>strictモードの関数における引数オブジェクトは、アクセス上のTypeError例外を投げる(スローする)場合、 “caller” と “callee” と名付けた設定なしのアクセサプロパティを定義します(10.6)。</li>
        <li>strictモードの関数における引数オブジェクトは、それらの関数の関連付けをする正規のパラメータと一致するプロパティ値をインデックスしたそれらの配列を直接共有しません。(10.6)。</li>
        <li>strictモードの関数においては、引数オブジェクトが、当該引数オブジェクトへのローカル識別子の引数の関連付けを生成した場合、不変であり、その為、関連付ける式のターゲットとならない場合があります(10.5)。</li>
        <li>strictモードのコードが、一部のデータプロパティ(11.1.5)の1つ以上の定義を伴う ObjectLiteral を含む場合、SyntaxErrorです。</li>
        <li>Identifier(識別子) “eval” やIdentifier(識別子) “arguments” が、任意の PropertyAssignment(プロパティの関連付け) の任意の PropertySetParameterList(プロパティへのパラメータリスト設定) 内にあるIdentifier(識別子)として現れ、それが厳格(strict)なコード内に含まれる場合や、その FunctionBody(関数本体) が、strictモードのコードである場合には、SyntaxErrorです。</li>
        <li>Strictモードの eval コードは、 eval への caller の環境変数内で変数や関数をインスタンス化することはできません。 その代わり、新しい環境変数が生成され、その環境は、当該 eval コードにおけるインスタンス化をバインディングする定義の為に使用されます(10.4.2)。</li>
        <li>this が、strictモードのコード内で評価される場合、 this 値は、オブジェクトに強制変換されます。 null や undefined である this 値は、グローバルオブジェクトに変換されませんし、プリミティブ(原始的な)値は、ラッパオブジェクトには変換されません。 ( Function.prototype.apply と Function.prototype.call を使用させる呼び出しを含む)関数呼び出し経由で解析した this 値は、解析した this 値をオブジェクトに強制変換することはありません(10.4.3, 11.1.1, 15.3.4.3, 15.3.4.4)。</li>
        <li>delete演算子が、strictモードのコード内に現れる場合、その UnaryExpression(単項式) が、直接変数、関数の引数、関数名等を参照する場合、SyntaxErrorが投げられ(スローされ)ます(11.4.1)。</li>
        <li>delete演算子が、strictモードのコード内に現れる場合、その削除されるプロパティが、属性 { [[Configurable]]:false } を持つ場合、TypeErrorが投げられ(スローされ)ます(11.4.1)。</li>
        <li>VariableDeclaration(変数宣言) や VariableDeclarationNoIn(変数宣言なし) が、厳格な(strict)コード内に現れたり、そのIdentifier(識別子)が、 eval や arguments である場合、SyntaxErrorです(12.2.1)。</li>
        <li>Strictモードのコードは、 WithStatement( with 文) を含まない場合があります。 このような文脈における WithStatement( with 文) の出現は、SyntaxErrorです(12.10)。</li>
        <li>Catch を伴う TryStatement( try 文) が、strictモードのコード内に現れたり、そのIdentifier(識別子)が、 eval や arguments である場合、SyntaxErrorです(12.14.1)。</li>
        <li>Identifier(識別子) eval や arguments が、strictモードの FunctionDeclaration(関数宣言) や FunctionExpression(関数式) の任意の FormalParameterList(正規のパラメータリスト) 内に現れる場合、SyntaxErrorです(13.1)。</li>
        <li>strictモードの関数は、同じ名称を持つ2つ以上の正規のパラメータを持たない場合があります。 FunctionDeclaration(関数宣言)、FunctionExpression(関数式)、Functionコンストラクタ を使って関数を生成する試行は、 SyntaxErrorです (13.1, 15.3.2)。</li>
        <li>実装は、 caller と名付けたプロパティのstrictモードの関数や関数のインスタンスの引数という意味においてこの仕様内で定義した範囲を超えて拡張しない場合があります。 ECMAScriptのコードは、strictモードの関数と一致する関数オブジェクト上でこれらの名称を持つプロパティを生成または編集しない場合があります( 10.6, 13.2, 15.3.4.5.3)。</li>
        <li>FunctionDeclaration(関数宣言) や FunctionExpression(関数式) のIdentifierとして、または、正規のパラメータ名としてIdentifier(識別子) eval や argments をstrictモードのコード内で使用することは、SyntaxErrorです(13.1)。 Functionコンストラクタ(15.3.2)を使用してこのようなstrictモードの関数を直接定義する試行には、SyntaxError例外を投げる(スローする)でしょう。</li>
    </ul>
    <h2 id="-d-3-5-standard-ecma-262-5-1-edition">付録 D (有益な情報) 利用可能な第3版互換性への影響を伴う第5版での訂正事項と明確化 / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="-d-3-5-">付録 D (有益な情報) 利用可能な第3版互換性への影響を伴う第5版での訂正事項と明確化</h3>
    <h4 id="-">全体を通して:</h4>
    <p>　第3版仕様にあった“式 new Array() によるかのような”のようなフレーズの意味は、誤解の対象となります。</p>
    <p>　第5版仕様では、全ての内部参照と標準組み込みオブジェクト、メソッド全てにおけるテキストは、現在、一致する名前付きプロパティの動的な値ではなく、その意図は、実際の組み込みオブジェクトが使用されることであり、それを明示的にさせることによって明確にしています。</p>
    <h4 id="11-8-2-11-8-3-11-8-5-">11.8.2, 11.8.3, 11.8.5:</h4>
    <p>　ECMAScriptでは一般に評価順を左から右に使用しますが、エディション3仕様の言語では、 > と \&lt;= 演算子については、部分的に右から左の順に結果を出していました。</p>
    <p>　仕様書では、現在、全ての評価順を左から右に指定するようにこれらの演算子について修正されています。</p>
    <p>　しかしながら、この順序の変更は、評価処理中に副作用が現れる場合、潜在的に観測可能となっています。</p>
    <h4 id="11-1-4-">11.1.4:</h4>
    <p>　第5版では、 ArrayInitialiser の末尾にある後続するカンマは、配列の大きさに追加しないという事実を明確にしておきます。</p>
    <p>　これは、第3版仕様からのセマンティック変更ではありませんが、一部の実装では、この誤解を以前から持つ場合があります。</p>
    <h4 id="11-2-3-">11.2.3:</h4>
    <p>　第5版では、当該アルゴリズムのステップ2と3の順を逆転させています。</p>
    <p>　エディション1～3内で指定したようにオリジナルの順は、 MemberExpression (メンバ式)を評価した結果に影響する可能性がある Arguments を評価中の副作用のように間違った指定でした。</p>
    <h4 id="12-4-">12.4:</h4>
    <p>　第3版では、tryステートメントの catch 句に渡した例外パラメータの名称解決におけるスコープとして提供する new Object() によるかのように任意のオブジェクトが生成されます。</p>
    <p>　実際の例外オブジェクトが、関数で且つ、 catch 句の中から呼ばれる場合、そのスコープのオブジェクトは、その呼び出しの this 値として渡されるでしょう。</p>
    <p>　関数の本体は、その後、その this 値上に新たなプロパティを定義し、それらのプロパティは、関数が返した後に catch 句のスコープ内にあるバインディングする識別子が見えるようになります。</p>
    <p>　第5版では、例外パラメータが関数として呼ばれる場合、 this 値として undefined (未定義)が、渡されます。</p>
    <h4 id="13-">13:</h4>
    <p>　第3版では、任意の識別子を伴うプロダクション FunctionExpression (関数式)は、関数の名称を検索する為のスコープとして提供する為のスコープチェーンに new Object() によるかのように生成したオブジェクトを追加します。</p>
    <p>　このようなオブジェクトに適用する識別子解決の規則(第3版の 10.1.4 )は、識別子を解決する為に試行される際には、おそらく必要に応じてオブジェクトのプロトタイプチェーンに続くでしょう。</p>
    <p>　これは、そのスコープ内にある識別子として可視である Object.prototype のプロパティ全てを意味します。</p>
    <p>　実際には、第3版に完全に準拠している実装は、このセマンティックスを実装していません。</p>
    <p>　第5版では、その関数の名称をバインドする宣言型環境レコードを使用することによって指定したセマンティックスを変更します。</p>
    <h4 id="14-">14:</h4>
    <p>　第3版では、プロダクション</p>
<pre><code>SourceElements : SourceElements SourceElement
</code></pre><p>におけるアルゴリズムは、Blockと同じ方法で値を出す文を正しく伝達するようにはなりません。</p>
    <p>　これは、Programのテキスト評価中に誤った結果を生成してしまう eval 関数内で結果を得ることが可能でした。</p>
    <p>　実際には、第3版に完全に準拠している実装は、第5版で指定したものではなく、正確な伝達が実装されています。</p>
    <h4 id="15-10-6-">15.10.6:</h4>
    <p>　 RegExp.prototype は、現在、オブジェクトのインスタンスではなく、 RegExp オブジェクトとなっています。</p>
    <p>　 Object.prototype.toString を使用することによって観測可能なその内部プロパティ[[Class]]の値は、現在、“Object”ではなく、“RegExp”となっています。</p>
    <h2 id="-e-3-5-standard-ecma-262-5-1-edition">付録 E (有益な情報) 第3版と非互換として導入する第5版での追加と変更 / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="-e-3-5-">付録 E (有益な情報) 第3版と非互換として導入する第5版での追加と変更</h3>
    <h4 id="7-1-">7.1:</h4>
    <p>　Unicode形式の制御文字が、処理する前にECMAScriptのソーステキストから取り除かれることは、もはや、なくなりました。</p>
    <p>　第5版では、そのような文字が、 StringLiteral や RegularExpressionLiteral 内に現れる場合、その文字が、リテラルに組み込まれないであろう第3版の文字の中にあるリテラルに組み込まれることはないでしょう。</p>
    <h4 id="7-2-">7.2:</h4>
    <p>　Unicode文字 \&lt;BOM\&gt; は、識別子となって現れる途中にあるその存在は、第3版では(実際には)発生しなかったと思われる構文エラーの中で結果として現れる可能性がありましたが、現在は、ホワイトスペースとして扱われるようになっています。</p>
    <h4 id="7-3-">7.3:</h4>
    <p>　エスケープシーケンスが先行する行終端文字は、現在、文字列リテラルトークン(文字どおりの字句)内にあることも許容されるようになっています。</p>
    <p>　(ちなみに)第3版では、(この場合、)構文エラーが、出されていたことでしょう。</p>
    <h4 id="7-8-5-">7.8.5:</h4>
    <p>　正規表現リテラルは、現在、当該リテラルが評価される都度、一意のオブジェクトを返すようになっています。</p>
    <p>　この変更により、そのようなリテラル値の当該オブジェクトの素性をテストしたり、共有した副作用に敏感な任意のプログラムによって検出されます。</p>
    <h4 id="7-8-5-">7.8.5:</h4>
    <p>　第5版は、RegExp オブジェクト を RegularExpressionLiteral に変換する際に生成されるであろう利用可能なRegExpコンストラクタのエラーについて初期に報告することを要求します。</p>
    <p>　第5版より以前の実装は、実際のオブジェクトの生成実行時までそのようなエラーを報告することを遅延させていました。</p>
    <h4 id="7-8-5-">7.8.5:</h4>
    <p>　第5版では、復号・復号化(アンエスケープ)した “/” (スラッシュ)文字が、正規表現リテラル内で任意の CharacterClass として現れる場合があります。</p>
    <p>　第3版では、そのような文字は、リテラルの末尾の文字として解釈されていたことでしょう。</p>
    <h4 id="10-4-2-">10.4.2:</h4>
    <p>　第5版では、 eval コードにおける環境変数と語彙的な環境両方であるものとしてグローバル環境を使用する eval 関数を間接的に呼びます。</p>
    <p>　第3版では、間接的な eval における caller の変数と語彙的な環境は、 eval コード(自体)における環境として使用されていました。</p>
    <h4 id="15-4-4-">15.4.4:</h4>
    <p>　第5版では、 Array.prototype の全てのメソッドは、汎用的であることが意図されます。</p>
    <p>　第3版では、 toString と toLocaleString は、汎用的ではありませんでしたから、Arrayのインスタンスではないオブジェクトに適用した場合、TypeError例外を投げる(スローする)でしょう。</p>
    <h4 id="10-6-">10.6:</h4>
    <p>　第5版では、引数オブジェクトのプロパティをインデックスした配列は、列挙される実際の正規パラメータと一致します。</p>
    <p>　第3版では、そのようなプロパティは、列挙されませんでした。</p>
    <h4 id="10-6-">10.6:</h4>
    <p>　第5版では、引数オブジェクトの内部プロパティ[[Class]]の値は、“Arguments”です。</p>
    <p>　第3版では、それは、“Object”でした。</p>
    <p>　これにより toString が、引数オブジェクトのメソッドとして呼ばれる際には、観測可能となっています。</p>
    <h4 id="12-6-4-">12.6.4:</h4>
    <p>　 for-in 文は、もはや null や undefined を評価する式では、TypeErrorを投げ(スローし)ないようになっています。</p>
    <p>　代わりにその文は、式の値が、何も列挙されないプロパティを伴うオブジェクトであった場合のように動作します。</p>
    <h4 id="15-">15:</h4>
    <p>　第5版内では、次の新しいプロパティは、第3版に存在する組み込みオブジェクトについて定義されます。</p>
<pre><code>Object.getPrototypeOf ,
    Object.getOwnPropertyDescriptor ,
    Object.getOwnPropertyNames ,
    Object.create ,
    Object.defineProperty ,
    Object.defineProperties ,
    Object.seal ,
    Object.freeze ,
    Object.preventExtensions ,
    Object.isSealed ,
    Object.isFrozen ,
    Object.isExtensible ,
    Object.keys ,
    Function.prototype.bind ,
    Array.prototype.indexOf ,
    Array.prototype.lastIndexOf ,
    Array.prototype.every ,
    Array.prototype.some ,
    Array.prototype.forEach ,
    Array.prototype.map ,
    Array.prototype.filter ,
    Array.prototype.reduce ,
    Array.prototype.reduceRight ,
    String.prototype.trim ,
    Date.now ,
    Date.prototype.toISOString ,
    Date.prototype.toJSON
</code></pre><h4 id="15-">15:</h4>
    <p>　実装は、現在、明示的に指定されない限り、標準組み込みメソッドについて外部の引数を無視することが要求されることになっています。</p>
    <p>　第3版では、外部引数の操作については指定されておらず、実装は、明示的にTypeError例外を投げる(スローする)ことが許容されていました。</p>
    <h4 id="15-1-1-">15.1.1:</h4>
    <p>　Globalオブジェクトの値プロパティ NaN、∞、undefinedは、読み取り専用プロパティとするように変更されています。</p>
    <h4 id="15-1-2-1-">15.1.2.1:</h4>
    <p>　実装は、もはや直接呼ばれない方法において eval の使用を制限することを許容されなくなりました。</p>
    <p>　追記すると任意の eval の呼び出しは、 caller の変数環境ではなく、その( eval の)変数環境としてグローバル環境を使用する直接呼び出しではなくなっています。</p>
    <h4 id="15-1-2-2-">15.1.2.2:</h4>
    <p>　関数 parseInt の仕様は、もはや8進数値としての0を伴って始まる文字列を扱うことを実装に許容しなくなりました。</p>
    <h4 id="15-3-4-3-">15.3.4.3:</h4>
    <p>　第3版では、2つめの引数が、配列オブジェクトや引数オブジェクトの何れでもない Function.prototype.apply に渡される場合、TypeErrorが、投げられ(スローされ)ます。</p>
    <p>　第5版では、2つめの引数は、有効な length プロパティを持つ任意の一般的な配列風のオブジェクトの種類となる場合があります。</p>
    <h4 id="15-3-4-3-15-3-4-4-">15.3.4.3, 15.3.4.4:</h4>
    <p>　第3版では、 Function.prototype.apply や Function.prototype.call の何れかに1つめの引数として undefined や null を渡すとGlobalオブジェクトが、 this 値として間接的に呼び出した対象となる関数に渡される要因になります。</p>
    <p>　1つめの引数が、プリミティブ(原始的な)値である場合、 this 値として渡されるプリミティブ(原始的な)値上で ToObject を呼んだ結果とします。</p>
    <p>　第5版では、これらの変換は、実行されず、実際の1つめの引数は、 this 値として渡されます。</p>
    <p>　この違いは、対象となる関数を実行する変換と一致する為、通常は、既存のECMAScript第3版には見られることではないでしょう。</p>
    <p>　しかしながら、実装によっては、この違いが、 apply や call を使って呼んだホストオブジェクト関数に見られる場合があります。</p>
    <p>　追記すると this 値として渡した null や undefined を伴うこの方法で標準組み込み関数を呼び出すと、多くの場合、第3版の動作とは異なる第5版での実装における動作をするでしょう。</p>
    <p>　特に第5版の組み込み関数は、 this 値として null や undefined を渡した場合、一般にTypeError例外を投げる(スローする)任意のオブジェクトとして、渡した this 値を実際に使用する為に指定されます。</p>
    <h4 id="15-3-5-2-">15.3.5.2:</h4>
    <p>　第5版では、Functionインスタンスのプロトタイププロパティは、列挙されません。</p>
    <p>　第3版では、このプロパティは、列挙されました。</p>
    <h4 id="15-5-5-2-">15.5.5.2:</h4>
    <p>　第5版では、Stringオブジェクトの[[PrimitiveValue]の個々の文字は、Stringオブジェクトのプロパティをインデックスした配列としてアクセスされる場合があります。</p>
    <p>　これらのプロパティは、書き込み不可、かつ、設定不可であり、同名の継承したプロパティを覆い(シャドウし)ます。</p>
    <p>　第3版では、これらのプロパティは、存在せず、ECMAScriptのコードは、そのような名称を持つ書き込み可能なプロパティを動的に追加または削除可能であり、そのような名称を持つ継承したプロパティにアクセスすることが可能でした。</p>
    <h4 id="15-9-4-2-">15.9.4.2:</h4>
    <p>　 Date.parse は、現在、最初に ISO フォーマット文字としてその引数を解析する試行を要求するようになっています。</p>
    <p>　このフォーマットを使用する一方、(失敗(failure)を含む)実装仕様固有の動作に依存しないプログラムは、異なる動作をする場合があります。</p>
    <h4 id="15-10-2-12-">15.10.2.12:</h4>
    <p>　第5版では、 \s は、併せて \&lt;BOM\&gt; ともマッチするようになっています。</p>
    <h4 id="15-10-4-1-">15.10.4.1:</h4>
    <p>　第3版では、オブジェクトのソースプロパティのString値の書式は、実装定義であるRegExpコンストラクタによって正確に生成しました。</p>
    <p>　第5版では、Stringは、特定の指定した必要条件と一致しなければならず、その為、第3版の実装によって生成した書式とは異なる場合があります。</p>
    <h4 id="15-10-6-4-">15.10.6.4:</h4>
    <p>　第3版では、 RegExp.prototype.toString の結果は、RegExpオブジェクトのソースプロパティから伝送される必要はありませんでした。</p>
    <p>　第5版では、その結果は、特定の方法でソースプロパティから伝送されなければならず、その為、第3版の実装によって生成した結果から伝送される場合があります。</p>
    <h4 id="15-11-2-1-15-11-4-3-">15.11.2.1, 15.11.4.3:</h4>
    <p>　第5版では、Errorオブジェクトのmessageプロパティにおける初期値が、Errorコンストラクタ経由で指定されない場合、プロパティの初期値は、カラの文字列となります。</p>
    <p>　第3版では、このような初期値は、実装定義とされていました。</p>
    <h4 id="15-11-4-4-">15.11.4.4:</h4>
    <p>　第3版では、 Error.prototype.toString の結果は、実装定義です。</p>
    <p>　第5版では、その結果は、完全に特定され、その為、一部の第3版の実装とは異なる場合があります。</p>
    <h4 id="15-12-">15.12:</h4>
    <p>　第5版では、名称 JSON は、グローバル環境で定義されます。</p>
    <p>　第3版では、名称の存在についてのテストを行うとプログラムや実装で定義されない限りは、undefined (未定義)であることが示されるでしょう。</p>
    <h2 id="-f-5-1-standard-ecma-262-5-1-edition">付録 F (有益な情報) 第5.1版での技術的に重要な訂正事項と明確化 Standard ECMA-262 5.1 Edition</h2>
    <h3 id="-f-5-1-">付録 F (有益な情報) 第5.1版での技術的に重要な訂正事項と明確化</h3>
    <h4 id="7-8-4-">7.8.4:</h4>
    <p>　 CV定義は、DoubleStringCharacter :: LineContinuation と SingleStringCharacter :: LineContinuation について追加しました。</p>
    <h4 id="10-2-1-1-3-">10.2.1.1.3:</h4>
    <p>　引数 S は、無視されます。</p>
    <p>　それは、恒久的なバインディングの設定を試行する際に例外が投げられる(スローされる)かどうかを制御します。</p>
    <h4 id="10-2-1-2-2-">10.2.1.2.2:</h4>
    <p>　アルゴリズムのステップ 5 では、trueは、[[DefineOwnProperty]]への最後の引数として渡されます。</p>
    <h4 id="10-5-">10.5:</h4>
    <p>　ステップ 5.e の前者のアルゴリズムは、現在、 5.f となるようになっており、新しいステップ 5.e は、グローバル関数を再定義する際に第3版との互換性を復元する為に追加されていました。</p>
    <h4 id="11-5-3-">11.5.3:</h4>
    <p>　箇条書きの最後のアイテムには、 IEEE 754 round-to-nearest (近似値への丸め処理)モードの使用が指定されます。</p>
    <h4 id="12-6-3-">12.6.3:</h4>
    <p>　欠落した ToBoolean は、双方のアルゴリズムのステップ 3.a.ii の中で復元しました。</p>
    <h4 id="12-6-4-">12.6.4:</h4>
    <p>　2つの段落のそれぞれに追加した最後の文章は、特定のプロパティの列挙の要件を明確にします。</p>
    <h4 id="12-7-12-8-12-9-">12.7, 12.8, 12.9:</h4>
    <p>　 BNF / Backus-Naur Form (バッカス・ナウア記法)は、任意の式がセミコロンの前にLineTerminatorを持つことなく、識別子や文を返すことなく、 continue 文や break 文を明確にする為に修正されました。</p>
    <h4 id="12-14-">12.14:</h4>
    <p>　アルゴリズム1のステップ 3 とアルゴリズム3のステップ 2.a は、Bそれ自身ではなく、Bの値項目のように補正されます。</p>
    <h4 id="15-1-2-2-">15.1.2.2:</h4>
    <p>　アルゴリズムのステップ 2 では、 S が、カラの文字列となる場合があることを明確にします。</p>
    <h4 id="15-1-2-3-">15.1.2.3:</h4>
    <p>　アルゴリズムのステップ 2 では、 trimmedString が、カラの文字列となる場合があることを明確にします。</p>
    <h4 id="15-1-3-">15.1.3:</h4>
    <p>　追加した注釈は、新しい RFC 3986 ではなく、 RFC 2396 を基準としたECMAScriptのURI構文であることを明確にしています。</p>
    <p>　デコード(復号・復号化)におけるアルゴリズムについては、ステップでは、発生不可能な条件においてテストした為、現在のステップ 4.d.vii.10.a の直前部分が削除されました。</p>
    <h4 id="15-2-3-7-">15.2.3.7:</h4>
    <p>　アルゴリズムのステップ5と6にある変数 P の使用を訂正しました。</p>
    <h4 id="15-2-4-2-">15.2.4.2:</h4>
    <p>　 this 値として undefined と null の制御をする第5版は、既存の失敗するコードを基にしていました。</p>
    <p>　仕様は、このようなコードを伴う互換性を維持する為に部分修正しました。</p>
    <p>　新しいステップ 1 と 2 は、アルゴリズムに追加しました。</p>
    <h4 id="15-3-4-3-">15.3.4.3:</h4>
    <p>　第5版のアルゴリズムのステップ 5 と 7 は、一般的な配列風のオブジェクトの使用するもの以外を伴う一貫性のないargArrayの引数について要件を課せられた為、削除されています。</p>
    <h4 id="15-4-4-12-">15.4.4.12:</h4>
    <p>　ステップ 9.a では、 relativeStart への誤った参照が、actualStart への参照と置き換えられました。</p>
    <h4 id="15-4-4-15-">15.4.4.15:</h4>
    <p>　 fromIndex における既定値は、配列のマイナス1の大きさであるということを明確にしました。</p>
    <h4 id="15-4-4-18-">15.4.4.18:</h4>
    <p>　アルゴリズムのステップ 9 にある undefined は、現在、指定した戻り値とすることになっています。</p>
    <h4 id="15-4-4-22-">15.4.4.22:</h4>
    <p>　ステップ 9.c.ii では、内部メソッド[[Call]]への最初の引数が、 Array.prototype.reduce の定義に伴う整合性の為に undefined に変更されています。</p>
    <h4 id="15-4-5-1-">15.4.5.1:</h4>
    <p>　アルゴリズムのステップ 3.l.ii と 3.l.iii では、変数名が、誤った反転テストの中で反転した結果となっていました。</p>
    <h4 id="15-5-4-9-">15.5.4.9:</h4>
    <p>　正規の等価文字列に関する規範的な要件は、注釈 2 で推奨したように列挙される為、後続のアルゴリズムを段落から削除しました。</p>
    <h4 id="15-5-4-14-">15.5.4.14:</h4>
    <p>　 splitのアルゴリズムのステップ 11.a と 13.a では、 SplitMatch への引数の配置順が、実際の SplitMatch のパラメータ署名と一致するように補正されました。</p>
    <p>　ステップ 13.a.iii.7.d では、 lengthA を A.length に置き換えました。</p>
    <h4 id="15-5-5-2-">15.5.5.2:</h4>
    <p>　最初の段落では、“配列インデックス”の構文を持っていた個々の文字へのプロパティアクセスを含め、削除しました。</p>
    <p>　修正したアルゴリズムのステップ 3 と 5 は、そのような“配列インデックス”の要件を強制しません。</p>
    <h4 id="15-9-1-15-">15.9.1.15:</h4>
    <p>　それらに欠けていた項目における範囲に正規の値を指定しました。</p>
    <p>　“time-only”フォーマットを除去しました。</p>
    <p>　全てのオブション項目における既定値を指定しました。</p>
    <h4 id="15-10-2-2-">15.10.2.2:</h4>
    <p>　ステップ 2 によって生成した内部クロージャにおけるアルゴリズムのステップ数は、外部アルゴリズムのステップであった暗黙の方法で間違った番号付けがなされていました。</p>
    <h4 id="15-10-2-6-">15.10.2.6:</h4>
    <p>　抽象操作 IsWordChar について、ステップ 3 にあるリスト内の最初の文字は、 “A” ではなく、 “a” です。</p>
    <h4 id="15-10-2-8-">15.10.2.8:</h4>
    <p>　抽象操作 CharacterSetMatcher によって返されたクロージャにおけるアルゴリズムでは、ステップ 3 によって定義し、ステップ 4 で引数として渡した変数は、クロージャの正規のパラメータとの名称の衝突を回避する為、 ch に改名されました。</p>
    <h4 id="15-10-6-2-">15.10.6.2:</h4>
    <p>　ステップ 9.e は、i の余分な増分を実行する為、削除されました。</p>
    <h4 id="15-11-1-1-">15.11.1.1:</h4>
    <p>　 message 自身のプロパティが、 message の引数が、undefinedである場合、カラの文字列に設定されるという要件を削除しました。</p>
    <h4 id="15-11-1-2-">15.11.1.2:</h4>
    <p>　 message 自身のプロパティが、 message の引数が、undefinedである場合、カラの文字列に設定されるという要件を削除しました。</p>
    <h4 id="15-11-4-4-">15.11.4.4:</h4>
    <p>　ステップ 6-10 は、欠落やカラの message プロパティ値を正常とする為に修正・追加されました。</p>
    <h4 id="15-11-1-2-">15.11.1.2:　（？ダブり？章番号間違い？）</h4>
    <p>　 message 自身のプロパティが、 message の引数が、undefinedである場合、カラの文字列に設定されるという要件を削除しました。</p>
    <h4 id="15-12-3-">15.12.3:</h4>
    <p>　内部制御 JA のステップ 10.b.iii では、連結する最後の要素は、“]” です。</p>
    <h4 id="b-2-1-">B.2.1:</h4>
    <p>　エンコード方式が、新しい RFC 3986 ではなく、 RFC 1738 を基準にするという注釈を追加しました。</p>
    <h4 id="-c-">付録 C:</h4>
    <p>　任意のアイテムが、strictモードで FutureReservedWords について 7.6.12 と一致するということが追加されました。</p>
    <h2 id="-bibliography-standard-ecma-262-5-1-edition">参考文献 / Bibliography / Standard ECMA-262 5.1 Edition</h2>
    <h3 id="-bibliography-">【Bibliography / 参考文献】</h3>
<pre><code>[1]
    IEEE Std 754-2008: IEEE Standard for Floating-Point Arithmetic.
    Institute of Electrical and Electronic Engineers, New York (2008)

    IEEE標準規格 754-2008: 浮動小数点数演算におけるIEEE標準規格
    IEEE / Institute of Electrical and Electronic Engineers, New York (2008)

    [2]
    The Unicode Consortium.
    The Unicode Standard, Version 3.0, defined by: The Unicode Standard, Version 3.0 (Reading, MA, Addison-Wesley, 2000.ISBN 0-201-61633-5)

    Unicodeコンソーシアム
    書籍『The Unicode Standard, Version 3.0』(Reading, MA, Addison-Wesley, 2000.ISBN 0-201-61633-5)によって定義したUnicode標準規格バージョン3.0

    [3]
    Unicode Inc. (2010), Unicode Technical Report #15: Unicode Normalization Forms

    Unicode Inc. (2010)発行のUnicodeテクニカルリポート #15：Unicode正規化の形式

    [4]
    ISO 8601:2004(E) Data elements and interchange formats -- Information interchange -- Representation of dates and times

    ISO規格 8601:2004(E) データ要素と書式変換 -- 情報変換 -- 日付と時刻の表現

    [5]
    RFC 1738 &quot;Uniform Resource Locators (URL)&quot;, available at &lt;http://tools.ietf.org/html/rfc1738&gt;

    RFC 1738 http://tools.ietf.org/html/rfc1738で利用可能な&quot;Uniform Resource Locators (URL)&quot;

    [6]
    RFC 2396 &quot;Uniform Resource Identifiers (URI): Generic Syntax&quot;, available at &lt;http://tools.ietf.org/html/rfc2396&gt;

    RFC 2396 http://tools.ietf.org/html/rfc2396で利用可能な&quot;Uniform Resource Identifiers (URI): 一般的な構文&quot;

    [7]
    RFC 3629 &quot;UTF-8, a transformation format of ISO 10646&quot;, available at &lt;http://tools.ietf.org/html/rfc3629&gt;

    RFC 3629 http://tools.ietf.org/html/rfc3629で利用可能な&quot;UTF-8 ISO 10646 の変換書式&quot;

    [8]
    RFC 4627 &quot;The application/json Media Type for JavaScript Object Notation (JSON)&quot; , available at &lt;http://tools.ietf.org/html/rfc4627&gt;

    RFC 4627 http://tools.ietf.org/html/rfc4627で利用可能な&quot;JSON / JavaScript Object Notation におけるメディアタイプ application/json&quot;
</code></pre>
</article>